<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>reactor-c: Utilities</title>
<link rel="icon" href="favicon.ico" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">reactor-c<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">C Runtime for Lingua Franca</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__Utilities.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Utilities </div></div>
</div><!--header-->
<div class="contents">

<p>Useful functions for application developers.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-files" class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:audio_5Floop_2Eh" id="r_audio_5Floop_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="audio__loop_8h.html">audio_loop.h</a></td></tr>
<tr class="memdesc:audio__loop_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for playing audio on Linux or MacOS. <br /></td></tr>
<tr class="memitem:deque_2Eh" id="r_deque_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="deque_8h.html">deque.h</a></td></tr>
<tr class="memdesc:deque_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of a double-ended queue. <br /></td></tr>
<tr class="memitem:generics_2Eh" id="r_generics_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generics_8h.html">generics.h</a></td></tr>
<tr class="memdesc:generics_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file provides macros for Generic Reactors in C-Target. <br /></td></tr>
<tr class="memitem:hashmap_2Eh" id="r_hashmap_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8h.html">hashmap.h</a></td></tr>
<tr class="memdesc:hashmap_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a generic, non-resizing hashmap data type. <br /></td></tr>
<tr class="memitem:hashset_2Eh" id="r_hashset_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashset_8h.html">hashset.h</a></td></tr>
<tr class="memdesc:hashset_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hash set implementation in C. <br /></td></tr>
<tr class="memitem:hashset_5Fitr_2Eh" id="r_hashset_5Fitr_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashset__itr_8h.html">hashset_itr.h</a></td></tr>
<tr class="memdesc:hashset__itr_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">A C hashset iterator implemenation. <br /></td></tr>
<tr class="memitem:pointer_5Fhashmap_2Eh" id="r_pointer_5Fhashmap_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pointer__hashmap_8h.html">pointer_hashmap.h</a></td></tr>
<tr class="memdesc:pointer__hashmap_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a hashmap type that maps void pointers to integers. <br /></td></tr>
<tr class="memitem:sensor_5Fsimulator_2Eh" id="r_sensor_5Fsimulator_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sensor__simulator_8h.html">sensor_simulator.h</a></td></tr>
<tr class="memdesc:sensor__simulator_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple terminal-based user interface based on ncurses. <br /></td></tr>
<tr class="memitem:type_5Fconverter_2Eh" id="r_type_5Fconverter_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="type__converter_8h.html">type_converter.h</a></td></tr>
<tr class="memdesc:type__converter_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file provides macro <span class="tt"><a class="el" href="#ga9cbcaad341a5b5a807196f116619b9c0" title="Convert the specified value from one type to another.">DO_CONVERT(fromType, toType, value)</a></span>. <br /></td></tr>
<tr class="memitem:wave_5Ffile_5Freader_2Eh" id="r_wave_5Ffile_5Freader_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="wave__file__reader_8h.html">wave_file_reader.h</a></td></tr>
<tr class="memdesc:wave__file__reader_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for reading WAV audio files. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:deque_5Ft" id="r_deque_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdeque__t.html">deque_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A double-ended queue data structure.  <a href="structdeque__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:hashmap_5Fentry_5Ft" id="r_hashmap_5Fentry_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhashmap__entry__t.html">hashmap_entry_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hashmap entry.  <a href="structhashmap__entry__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:hashmap_5Ft" id="r_hashmap_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhashmap__t.html">hashmap_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hashmap.  <a href="structhashmap__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:hashset_5Fitr_5Fst" id="r_hashset_5Fitr_5Fst"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhashset__itr__st.html">hashset_itr_st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hashset iterator.  <a href="structhashset__itr__st.html#details">More...</a><br /></td></tr>
<tr class="memitem:hashset_5Fst" id="r_hashset_5Fst"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhashset__st.html">hashset_st</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hashset.  <a href="structhashset__st.html#details">More...</a><br /></td></tr>
<tr class="memitem:lf_5Fwaveform_5Ft" id="r_lf_5Fwaveform_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlf__waveform__t.html">lf_waveform_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waveform in 16-bit linear-PCM format.  <a href="structlf__waveform__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:vector_5Ft" id="r_vector_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvector__t.html">vector_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector (resizing array) data type.  <a href="structvector__t.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga1d48237cb63c5ae67aab6d00cc64afb6" id="r_ga1d48237cb63c5ae67aab6d00cc64afb6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1d48237cb63c5ae67aab6d00cc64afb6">AUDIO_BUFFER_SIZE</a>&#160;&#160;&#160;4410</td></tr>
<tr class="memdesc:ga1d48237cb63c5ae67aab6d00cc64afb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the audio buffer.  <br /></td></tr>
<tr class="memitem:gaaee12bd1b49481f758a5a3cf1876268c" id="r_gaaee12bd1b49481f758a5a3cf1876268c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaee12bd1b49481f758a5a3cf1876268c">BUFFER_DURATION_NS</a>&#160;&#160;&#160;100000000LL</td></tr>
<tr class="memdesc:gaaee12bd1b49481f758a5a3cf1876268c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duration of the audio buffer.  <br /></td></tr>
<tr class="memitem:ga9cbcaad341a5b5a807196f116619b9c0" id="r_ga9cbcaad341a5b5a807196f116619b9c0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9cbcaad341a5b5a807196f116619b9c0">DO_CONVERT</a>(fromType,  toType,  value)</td></tr>
<tr class="memdesc:ga9cbcaad341a5b5a807196f116619b9c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the specified value from one type to another.  <br /></td></tr>
<tr class="memitem:ga9505134796fc957eb9fedf172cab3527" id="r_ga9505134796fc957eb9fedf172cab3527"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9505134796fc957eb9fedf172cab3527">lf_decay</a>(p)</td></tr>
<tr class="memdesc:ga9505134796fc957eb9fedf172cab3527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decay the specified pointer.  <br /></td></tr>
<tr class="memitem:gafe05484f1ece6fa30ba7b3bcf33f03b9" id="r_gafe05484f1ece6fa30ba7b3bcf33f03b9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafe05484f1ece6fa30ba7b3bcf33f03b9">lf_get_pointer</a>(p)</td></tr>
<tr class="memdesc:gafe05484f1ece6fa30ba7b3bcf33f03b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the pointer for specified <span class="tt">p</span>.  <br /></td></tr>
<tr class="memitem:ga9edb07d852ce1b4e090b36f8683c8017" id="r_ga9edb07d852ce1b4e090b36f8683c8017"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9edb07d852ce1b4e090b36f8683c8017">lf_is_pointer</a>(p)</td></tr>
<tr class="memdesc:ga9edb07d852ce1b4e090b36f8683c8017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the passed variable <span class="tt">p</span> is a pointer.  <br /></td></tr>
<tr class="memitem:ga271f353ddab44fb05a4b0f8627904fbe" id="r_ga271f353ddab44fb05a4b0f8627904fbe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga271f353ddab44fb05a4b0f8627904fbe">lf_is_pointer_or_array</a>(p)</td></tr>
<tr class="memdesc:ga271f353ddab44fb05a4b0f8627904fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the passed variable <span class="tt">p</span> is an array or a pointer.  <br /></td></tr>
<tr class="memitem:ga785378b93bab907d10fee21425a292e5" id="r_ga785378b93bab907d10fee21425a292e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga785378b93bab907d10fee21425a292e5">lf_is_same</a>(typename,  b)</td></tr>
<tr class="memdesc:ga785378b93bab907d10fee21425a292e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the type of <span class="tt">b</span> is same as the specified <span class="tt">typename</span>.  <br /></td></tr>
<tr class="memitem:ga886f2df25fcc1b16e512d6143e910b6f" id="r_ga886f2df25fcc1b16e512d6143e910b6f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga886f2df25fcc1b16e512d6143e910b6f">lf_is_same_type</a>(a,  b)</td></tr>
<tr class="memdesc:ga886f2df25fcc1b16e512d6143e910b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the types of both <span class="tt">a</span> and <span class="tt">b</span> are same.  <br /></td></tr>
<tr class="memitem:ga7d7827494787f07637043eb90e285d44" id="r_ga7d7827494787f07637043eb90e285d44"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7d7827494787f07637043eb90e285d44">lf_is_type_equal</a>(typename_a,  typename_b)</td></tr>
<tr class="memdesc:ga7d7827494787f07637043eb90e285d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the type of <span class="tt">typename_a</span> is same as the type of <span class="tt">typename_b</span>.  <br /></td></tr>
<tr class="memitem:ga99938402e4e9202fe51e67f6e916f0f5" id="r_ga99938402e4e9202fe51e67f6e916f0f5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga99938402e4e9202fe51e67f6e916f0f5">lf_to_left_type</a>(left,  right)</td></tr>
<tr class="memdesc:ga99938402e4e9202fe51e67f6e916f0f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check types for both <span class="tt">left</span> and <span class="tt">right</span> and return appropriate value based on <span class="tt">left</span> type.  <br /></td></tr>
<tr class="memitem:ga141b139da77580918b0f9821ab3dbb99" id="r_ga141b139da77580918b0f9821ab3dbb99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga141b139da77580918b0f9821ab3dbb99">MAX_AMPLITUDE</a>&#160;&#160;&#160;32765</td></tr>
<tr class="memdesc:ga141b139da77580918b0f9821ab3dbb99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum amplitude for audio playback.  <br /></td></tr>
<tr class="memitem:gae5597ce31d23d11493e6e674fe257d73" id="r_gae5597ce31d23d11493e6e674fe257d73"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae5597ce31d23d11493e6e674fe257d73">NUM_CHANNELS</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gae5597ce31d23d11493e6e674fe257d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of channels for audio playback.  <br /></td></tr>
<tr class="memitem:ga5b0b677cb9527865430a9b3d7a71cb03" id="r_ga5b0b677cb9527865430a9b3d7a71cb03"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5b0b677cb9527865430a9b3d7a71cb03">NUM_NOTES</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:ga5b0b677cb9527865430a9b3d7a71cb03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of notes that can play simultaneously.  <br /></td></tr>
<tr class="memitem:ga4b76a0c2859cfd819a343a780070ee2b" id="r_ga4b76a0c2859cfd819a343a780070ee2b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4b76a0c2859cfd819a343a780070ee2b">SAMPLE_RATE</a>&#160;&#160;&#160;44100</td></tr>
<tr class="memdesc:ga4b76a0c2859cfd819a343a780070ee2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample rate for audio playback.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gafc1887f5ebd7da3ce7dfc73beb195598" id="r_gafc1887f5ebd7da3ce7dfc73beb195598"><td class="memItemLeft" align="right" valign="top">typedef struct deque_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafc1887f5ebd7da3ce7dfc73beb195598">deque_t</a></td></tr>
<tr class="memdesc:gafc1887f5ebd7da3ce7dfc73beb195598"><td class="mdescLeft">&#160;</td><td class="mdescRight">A double-ended queue data structure.  <br /></td></tr>
<tr class="memitem:ga1044f93547018a97e5d3b50cac8a1516" id="r_ga1044f93547018a97e5d3b50cac8a1516"><td class="memItemLeft" align="right" valign="top">typedef struct hashmap_entry_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1044f93547018a97e5d3b50cac8a1516">hashmap_entry_t</a></td></tr>
<tr class="memdesc:ga1044f93547018a97e5d3b50cac8a1516"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hashmap entry.  <br /></td></tr>
<tr class="memitem:ga19e5de2971328f1de610c3a3f42d295f" id="r_ga19e5de2971328f1de610c3a3f42d295f"><td class="memItemLeft" align="right" valign="top">typedef struct hashmap_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga19e5de2971328f1de610c3a3f42d295f">hashmap_t</a></td></tr>
<tr class="memdesc:ga19e5de2971328f1de610c3a3f42d295f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hashmap.  <br /></td></tr>
<tr class="memitem:ga464bd5c31a1a562536e2a54213135604" id="r_ga464bd5c31a1a562536e2a54213135604"><td class="memItemLeft" align="right" valign="top">typedef struct lf_waveform_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga464bd5c31a1a562536e2a54213135604">lf_waveform_t</a></td></tr>
<tr class="memdesc:ga464bd5c31a1a562536e2a54213135604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waveform in 16-bit linear-PCM format.  <br /></td></tr>
<tr class="memitem:gac6a5b15223a2905669f2ee7377fd3dbd" id="r_gac6a5b15223a2905669f2ee7377fd3dbd"><td class="memItemLeft" align="right" valign="top">typedef struct vector_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac6a5b15223a2905669f2ee7377fd3dbd">vector_t</a></td></tr>
<tr class="memdesc:gac6a5b15223a2905669f2ee7377fd3dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector (resizing array) data type.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae0d2efe97b2aac751245705e32d2c927" id="r_gae0d2efe97b2aac751245705e32d2c927"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae0d2efe97b2aac751245705e32d2c927">add_to_sound</a> (int index_offset, double value)</td></tr>
<tr class="memdesc:gae0d2efe97b2aac751245705e32d2c927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given value to the current write buffer at the specified index.  <br /></td></tr>
<tr class="memitem:ga0e4768355c448b3b0489d851271515bc" id="r_ga0e4768355c448b3b0489d851271515bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0e4768355c448b3b0489d851271515bc">deque_initialize</a> (<a class="el" href="structdeque__t.html">deque_t</a> *d)</td></tr>
<tr class="memdesc:ga0e4768355c448b3b0489d851271515bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the specified deque to an empty deque.  <br /></td></tr>
<tr class="memitem:gac22527818b92ea67851c2fd4a2790cb7" id="r_gac22527818b92ea67851c2fd4a2790cb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac22527818b92ea67851c2fd4a2790cb7">deque_is_empty</a> (<a class="el" href="structdeque__t.html">deque_t</a> *d)</td></tr>
<tr class="memdesc:gac22527818b92ea67851c2fd4a2790cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the queue is empty.  <br /></td></tr>
<tr class="memitem:ga3530b26ded106a84ef8571fab0e73d9e" id="r_ga3530b26ded106a84ef8571fab0e73d9e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3530b26ded106a84ef8571fab0e73d9e">deque_peek_back</a> (<a class="el" href="structdeque__t.html">deque_t</a> *d)</td></tr>
<tr class="memdesc:ga3530b26ded106a84ef8571fab0e73d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at the value on the front of the queue, leaving it on the queue.  <br /></td></tr>
<tr class="memitem:ga4b9e8a9de89f124d0cdc1199debb70be" id="r_ga4b9e8a9de89f124d0cdc1199debb70be"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4b9e8a9de89f124d0cdc1199debb70be">deque_peek_front</a> (<a class="el" href="structdeque__t.html">deque_t</a> *d)</td></tr>
<tr class="memdesc:ga4b9e8a9de89f124d0cdc1199debb70be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at the value on the back of the queue, leaving it on the queue.  <br /></td></tr>
<tr class="memitem:ga841ec80a70a2e63f08aab990e528e1f9" id="r_ga841ec80a70a2e63f08aab990e528e1f9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga841ec80a70a2e63f08aab990e528e1f9">deque_pop_back</a> (<a class="el" href="structdeque__t.html">deque_t</a> *d)</td></tr>
<tr class="memdesc:ga841ec80a70a2e63f08aab990e528e1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop a value from the back of the queue, removing it from the queue.  <br /></td></tr>
<tr class="memitem:ga4acd616a7c971b1c137010c64801d746" id="r_ga4acd616a7c971b1c137010c64801d746"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4acd616a7c971b1c137010c64801d746">deque_pop_front</a> (<a class="el" href="structdeque__t.html">deque_t</a> *d)</td></tr>
<tr class="memdesc:ga4acd616a7c971b1c137010c64801d746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop a value from the front of the queue, removing it from the queue.  <br /></td></tr>
<tr class="memitem:gac1ffd77da7496612086ea430f7d29563" id="r_gac1ffd77da7496612086ea430f7d29563"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac1ffd77da7496612086ea430f7d29563">deque_push_back</a> (<a class="el" href="structdeque__t.html">deque_t</a> *d, void *value)</td></tr>
<tr class="memdesc:gac1ffd77da7496612086ea430f7d29563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a value to the back of the queue.  <br /></td></tr>
<tr class="memitem:ga19a0d218efcb14cc2c3d7b009a5d0f16" id="r_ga19a0d218efcb14cc2c3d7b009a5d0f16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga19a0d218efcb14cc2c3d7b009a5d0f16">deque_push_front</a> (<a class="el" href="structdeque__t.html">deque_t</a> *d, void *value)</td></tr>
<tr class="memdesc:ga19a0d218efcb14cc2c3d7b009a5d0f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a value to the front of the queue.  <br /></td></tr>
<tr class="memitem:gad7e6969a2e1a7e7529575558103d512d" id="r_gad7e6969a2e1a7e7529575558103d512d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad7e6969a2e1a7e7529575558103d512d">deque_size</a> (<a class="el" href="structdeque__t.html">deque_t</a> *d)</td></tr>
<tr class="memdesc:gad7e6969a2e1a7e7529575558103d512d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the queue.  <br /></td></tr>
<tr class="memitem:ga562a694d5b2ed8c935aa08d78c488114" id="r_ga562a694d5b2ed8c935aa08d78c488114"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga562a694d5b2ed8c935aa08d78c488114">end_sensor_simulator</a> ()</td></tr>
<tr class="memdesc:ga562a694d5b2ed8c935aa08d78c488114"><td class="mdescLeft">&#160;</td><td class="mdescRight">End ncurses control of the terminal.  <br /></td></tr>
<tr class="memitem:gafa5597a9582cc604eb0da7aac536ce4c" id="r_gafa5597a9582cc604eb0da7aac536ce4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafa5597a9582cc604eb0da7aac536ce4c">hashmap_free</a> (<a class="el" href="structhashmap__t.html">hashmap_t</a> *hashmap)</td></tr>
<tr class="memdesc:gafa5597a9582cc604eb0da7aac536ce4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all memory used by the given hashmap.  <br /></td></tr>
<tr class="memitem:ga510dfb7539122a20f4f0e299a2d33c88" id="r_ga510dfb7539122a20f4f0e299a2d33c88"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga510dfb7539122a20f4f0e299a2d33c88">hashmap_get</a> (<a class="el" href="structhashmap__t.html">hashmap_t</a> *hashmap, void *key)</td></tr>
<tr class="memdesc:ga510dfb7539122a20f4f0e299a2d33c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value associated with the given key.  <br /></td></tr>
<tr class="memitem:ga67344ac16c34de2b935e8ff5f343cf6c" id="r_ga67344ac16c34de2b935e8ff5f343cf6c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structhashmap__entry__t.html">hashmap_entry_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga67344ac16c34de2b935e8ff5f343cf6c">hashmap_get_actual_address</a> (<a class="el" href="structhashmap__t.html">hashmap_t</a> *hashmap, void *key)</td></tr>
<tr class="memdesc:ga67344ac16c34de2b935e8ff5f343cf6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the actual address of the hashmap entry corresponding to <span class="tt">key</span>, or the address of the closest empty entry if no such entry exists.  <br /></td></tr>
<tr class="memitem:gac0b6f823784483f653698db3371a7036" id="r_gac0b6f823784483f653698db3371a7036"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhashmap__t.html">hashmap_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac0b6f823784483f653698db3371a7036">hashmap_new</a> (size_t capacity, void *nothing)</td></tr>
<tr class="memdesc:gac0b6f823784483f653698db3371a7036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new hashmap object.  <br /></td></tr>
<tr class="memitem:ga47e0b1518c46a6cf0ea799c49490581e" id="r_ga47e0b1518c46a6cf0ea799c49490581e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga47e0b1518c46a6cf0ea799c49490581e">hashmap_put</a> (<a class="el" href="structhashmap__t.html">hashmap_t</a> *hashmap, void *key, void *value)</td></tr>
<tr class="memdesc:ga47e0b1518c46a6cf0ea799c49490581e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate a value with the given key.  <br /></td></tr>
<tr class="memitem:ga31e95da7ee1f76c30b9fec773d9b380c" id="r_ga31e95da7ee1f76c30b9fec773d9b380c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga31e95da7ee1f76c30b9fec773d9b380c">hashset_add</a> (<a class="el" href="hashset_8h.html#ad69fd91d4c662d832841b95188dd47f4">hashset_t</a> set, void *item)</td></tr>
<tr class="memdesc:ga31e95da7ee1f76c30b9fec773d9b380c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a pointer to the hashset.  <br /></td></tr>
<tr class="memitem:ga2c94a06d31c15e8da48b04b3de1a9113" id="r_ga2c94a06d31c15e8da48b04b3de1a9113"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hashset_8h.html#ad69fd91d4c662d832841b95188dd47f4">hashset_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2c94a06d31c15e8da48b04b3de1a9113">hashset_create</a> (unsigned short nbits)</td></tr>
<tr class="memdesc:ga2c94a06d31c15e8da48b04b3de1a9113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a hashset instance.  <br /></td></tr>
<tr class="memitem:ga6e280b06a1572145d3211e36e47eea6e" id="r_ga6e280b06a1572145d3211e36e47eea6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6e280b06a1572145d3211e36e47eea6e">hashset_destroy</a> (<a class="el" href="hashset_8h.html#ad69fd91d4c662d832841b95188dd47f4">hashset_t</a> set)</td></tr>
<tr class="memdesc:ga6e280b06a1572145d3211e36e47eea6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the hashset instance, freeing allocated memory.  <br /></td></tr>
<tr class="memitem:ga55de036dbc978294c262a7751f4caa81" id="r_ga55de036dbc978294c262a7751f4caa81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga55de036dbc978294c262a7751f4caa81">hashset_is_member</a> (<a class="el" href="hashset_8h.html#ad69fd91d4c662d832841b95188dd47f4">hashset_t</a> set, void *item)</td></tr>
<tr class="memdesc:ga55de036dbc978294c262a7751f4caa81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns non-zero if the item is in the hashset and zero otherwise.  <br /></td></tr>
<tr class="memitem:ga5350d2cd6a1be22846c5541816fb857f" id="r_ga5350d2cd6a1be22846c5541816fb857f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="hashset__itr_8h.html#aabacd1abe5de3d3d03fb2b649a1f2ba5">hashset_itr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5350d2cd6a1be22846c5541816fb857f">hashset_iterator</a> (<a class="el" href="hashset_8h.html#ad69fd91d4c662d832841b95188dd47f4">hashset_t</a> set)</td></tr>
<tr class="memdesc:ga5350d2cd6a1be22846c5541816fb857f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a hashset iterator.  <br /></td></tr>
<tr class="memitem:ga50a2126c05927f7d11b0859af5a38f02" id="r_ga50a2126c05927f7d11b0859af5a38f02"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga50a2126c05927f7d11b0859af5a38f02">hashset_iterator_has_next</a> (<a class="el" href="hashset__itr_8h.html#aabacd1abe5de3d3d03fb2b649a1f2ba5">hashset_itr_t</a> itr)</td></tr>
<tr class="memdesc:ga50a2126c05927f7d11b0859af5a38f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if there is a next value in the hashset and 0 otherwise.  <br /></td></tr>
<tr class="memitem:ga1f8e715379e1c95db280451114056bd8" id="r_ga1f8e715379e1c95db280451114056bd8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1f8e715379e1c95db280451114056bd8">hashset_iterator_next</a> (<a class="el" href="hashset__itr_8h.html#aabacd1abe5de3d3d03fb2b649a1f2ba5">hashset_itr_t</a> itr)</td></tr>
<tr class="memdesc:ga1f8e715379e1c95db280451114056bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance to the next value in the hashset.  <br /></td></tr>
<tr class="memitem:ga08d3680504ca63e10abbf03b115acb1b" id="r_ga08d3680504ca63e10abbf03b115acb1b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga08d3680504ca63e10abbf03b115acb1b">hashset_iterator_value</a> (<a class="el" href="hashset__itr_8h.html#aabacd1abe5de3d3d03fb2b649a1f2ba5">hashset_itr_t</a> itr)</td></tr>
<tr class="memdesc:ga08d3680504ca63e10abbf03b115acb1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value at the current index.  <br /></td></tr>
<tr class="memitem:ga8d4800d73d1a58ad953501d9035de5ec" id="r_ga8d4800d73d1a58ad953501d9035de5ec"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8d4800d73d1a58ad953501d9035de5ec">hashset_num_items</a> (<a class="el" href="hashset_8h.html#ad69fd91d4c662d832841b95188dd47f4">hashset_t</a> set)</td></tr>
<tr class="memdesc:ga8d4800d73d1a58ad953501d9035de5ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of items in the hashset.  <br /></td></tr>
<tr class="memitem:ga5b0ad513d6e64cd754213b0103a094e0" id="r_ga5b0ad513d6e64cd754213b0103a094e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5b0ad513d6e64cd754213b0103a094e0">hashset_remove</a> (<a class="el" href="hashset_8h.html#ad69fd91d4c662d832841b95188dd47f4">hashset_t</a> set, void *item)</td></tr>
<tr class="memdesc:ga5b0ad513d6e64cd754213b0103a094e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an item from the hashset.  <br /></td></tr>
<tr class="memitem:ga20d5fc7b37764eb8c3a4e917e93ad7d7" id="r_ga20d5fc7b37764eb8c3a4e917e93ad7d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga20d5fc7b37764eb8c3a4e917e93ad7d7">lf_play_audio_waveform</a> (<a class="el" href="structlf__waveform__t.html">lf_waveform_t</a> *waveform, float emphasis, <a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a> <a class="el" href="trace__util_8h.html#a20b56e8fb05c017508f1c4fa2e311a87">start_time</a>)</td></tr>
<tr class="memdesc:ga20d5fc7b37764eb8c3a4e917e93ad7d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Play the specified waveform with the specified emphasis at the specified time.  <br /></td></tr>
<tr class="memitem:ga7e03b277fd2f2b3ae6aa029e5256da3e" id="r_ga7e03b277fd2f2b3ae6aa029e5256da3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7e03b277fd2f2b3ae6aa029e5256da3e">lf_start_audio_loop</a> (<a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a> <a class="el" href="trace__util_8h.html#a20b56e8fb05c017508f1c4fa2e311a87">start_time</a>)</td></tr>
<tr class="memdesc:ga7e03b277fd2f2b3ae6aa029e5256da3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an audio loop thread that becomes ready to receive audio amplitude samples via <a class="el" href="#gae0d2efe97b2aac751245705e32d2c927">add_to_sound()</a>.  <br /></td></tr>
<tr class="memitem:ga65266402bd1ede8be91b6a0a5a34f767" id="r_ga65266402bd1ede8be91b6a0a5a34f767"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga65266402bd1ede8be91b6a0a5a34f767">lf_stop_audio_loop</a> ()</td></tr>
<tr class="memdesc:ga65266402bd1ede8be91b6a0a5a34f767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the audio loop thread.  <br /></td></tr>
<tr class="memitem:ga149d009d65a3c20d73bcf2ae7c9d6814" id="r_ga149d009d65a3c20d73bcf2ae7c9d6814"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlf__waveform__t.html">lf_waveform_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga149d009d65a3c20d73bcf2ae7c9d6814">read_wave_file</a> (const char *path)</td></tr>
<tr class="memdesc:ga149d009d65a3c20d73bcf2ae7c9d6814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a wave file, check that the format is supported, allocate memory for the sample data, and fill the memory with the sample data.  <br /></td></tr>
<tr class="memitem:ga196614841046dea5b94b2a60108fff40" id="r_ga196614841046dea5b94b2a60108fff40"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga196614841046dea5b94b2a60108fff40">register_sensor_key</a> (char key, void *action)</td></tr>
<tr class="memdesc:ga196614841046dea5b94b2a60108fff40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a keyboard key to trigger the specified action.  <br /></td></tr>
<tr class="memitem:ga3c9ec0901afe8264c0e75d40c940bd5a" id="r_ga3c9ec0901afe8264c0e75d40c940bd5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3c9ec0901afe8264c0e75d40c940bd5a">show_tick</a> (const char *character)</td></tr>
<tr class="memdesc:ga3c9ec0901afe8264c0e75d40c940bd5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place a tick (usually a single character) in the tick window.  <br /></td></tr>
<tr class="memitem:ga491b52110965df05da5f18cb820ae99f" id="r_ga491b52110965df05da5f18cb820ae99f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga491b52110965df05da5f18cb820ae99f">start_sensor_simulator</a> (const char *message_lines[], int number_of_lines, int tick_window_width, char *log_file, int log_level)</td></tr>
<tr class="memdesc:ga491b52110965df05da5f18cb820ae99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the sensor simulator if it has not been already started.  <br /></td></tr>
<tr class="memitem:ga201cb1fd5299e01b6fdfb499d3008952" id="r_ga201cb1fd5299e01b6fdfb499d3008952"><td class="memItemLeft" align="right" valign="top">void **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga201cb1fd5299e01b6fdfb499d3008952">vector_at</a> (<a class="el" href="structvector__t.html">vector_t</a> *v, size_t idx)</td></tr>
<tr class="memdesc:ga201cb1fd5299e01b6fdfb499d3008952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to where the vector element at 'idx' is stored.  <br /></td></tr>
<tr class="memitem:gab6ea681ea89fa128392d61ec7a516e31" id="r_gab6ea681ea89fa128392d61ec7a516e31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab6ea681ea89fa128392d61ec7a516e31">vector_free</a> (<a class="el" href="structvector__t.html">vector_t</a> *v)</td></tr>
<tr class="memdesc:gab6ea681ea89fa128392d61ec7a516e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the memory held by the given vector, invalidating it.  <br /></td></tr>
<tr class="memitem:ga640489760dfb72c2001de6ec560fb75f" id="r_ga640489760dfb72c2001de6ec560fb75f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvector__t.html">vector_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga640489760dfb72c2001de6ec560fb75f">vector_new</a> (size_t initial_capacity)</td></tr>
<tr class="memdesc:ga640489760dfb72c2001de6ec560fb75f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a new vector.  <br /></td></tr>
<tr class="memitem:ga85cdea38a35554168aa2277d83f5a957" id="r_ga85cdea38a35554168aa2277d83f5a957"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga85cdea38a35554168aa2277d83f5a957">vector_pop</a> (<a class="el" href="structvector__t.html">vector_t</a> *v)</td></tr>
<tr class="memdesc:ga85cdea38a35554168aa2277d83f5a957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove and return some pointer that is contained in the given vector, or return NULL if the given vector is empty.  <br /></td></tr>
<tr class="memitem:ga85a9501c4a715501dc0adeb04bd84dcb" id="r_ga85a9501c4a715501dc0adeb04bd84dcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga85a9501c4a715501dc0adeb04bd84dcb">vector_push</a> (<a class="el" href="structvector__t.html">vector_t</a> *v, void *element)</td></tr>
<tr class="memdesc:ga85a9501c4a715501dc0adeb04bd84dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given element to the vector.  <br /></td></tr>
<tr class="memitem:gab5ad2a2c71548435b6072b31ac21a9c2" id="r_gab5ad2a2c71548435b6072b31ac21a9c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab5ad2a2c71548435b6072b31ac21a9c2">vector_pushall</a> (<a class="el" href="structvector__t.html">vector_t</a> *v, void **array, size_t size)</td></tr>
<tr class="memdesc:gab5ad2a2c71548435b6072b31ac21a9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add all elements of the given array to the vector.  <br /></td></tr>
<tr class="memitem:gaaa8f4318bf03a7886169e85c151b6903" id="r_gaaa8f4318bf03a7886169e85c151b6903"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaa8f4318bf03a7886169e85c151b6903">vector_size</a> (<a class="el" href="structvector__t.html">vector_t</a> *v)</td></tr>
<tr class="memdesc:gaaa8f4318bf03a7886169e85c151b6903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the vector.  <br /></td></tr>
<tr class="memitem:ga41e7b0b4a43deefd94df37fd128de0bb" id="r_ga41e7b0b4a43deefd94df37fd128de0bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga41e7b0b4a43deefd94df37fd128de0bb">vector_vote</a> (<a class="el" href="structvector__t.html">vector_t</a> *v)</td></tr>
<tr class="memdesc:ga41e7b0b4a43deefd94df37fd128de0bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vote on whether this vector should be given less memory.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<p>Useful functions for application developers. </p>
<p>This collection of functions provides commonly used functionality that is not part of the core API. </p>
<a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="ga1d48237cb63c5ae67aab6d00cc64afb6" name="ga1d48237cb63c5ae67aab6d00cc64afb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d48237cb63c5ae67aab6d00cc64afb6">&#9670;&#160;</a></span>AUDIO_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AUDIO_BUFFER_SIZE&#160;&#160;&#160;4410</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="audio__loop_8h.html">/Users/runner/work/reactor-c/reactor-c/util/audio_loop.h</a>&gt;</code></p>

<p>Size of the audio buffer. </p>

</div>
</div>
<a id="gaaee12bd1b49481f758a5a3cf1876268c" name="gaaee12bd1b49481f758a5a3cf1876268c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaee12bd1b49481f758a5a3cf1876268c">&#9670;&#160;</a></span>BUFFER_DURATION_NS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BUFFER_DURATION_NS&#160;&#160;&#160;100000000LL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="audio__loop_8h.html">/Users/runner/work/reactor-c/reactor-c/util/audio_loop.h</a>&gt;</code></p>

<p>Duration of the audio buffer. </p>

</div>
</div>
<a id="ga9cbcaad341a5b5a807196f116619b9c0" name="ga9cbcaad341a5b5a807196f116619b9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cbcaad341a5b5a807196f116619b9c0">&#9670;&#160;</a></span>DO_CONVERT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DO_CONVERT</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>fromType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>toType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="type__converter_8h.html">/Users/runner/work/reactor-c/reactor-c/util/type_converter.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="type__converter_8h.html#abfdc65c203d58dcfbd3c10da587afd77">RESOLVE</a>(fromType, toType, value)</div>
<div class="ttc" id="atype__converter_8h_html_abfdc65c203d58dcfbd3c10da587afd77"><div class="ttname"><a href="type__converter_8h.html#abfdc65c203d58dcfbd3c10da587afd77">RESOLVE</a></div><div class="ttdeci">#define RESOLVE(i, o, in)</div><div class="ttdef"><b>Definition</b> type_converter.h:20</div></div>
</div><!-- fragment -->
<p>Convert the specified value from one type to another. </p>
<p>This macro enables user to provide their own converter libraries as long as they follow the convention for naming their conversion functions. </p><dl class="section note"><dt>Note</dt><dd>Converter library functions must follow this convention: <span class="tt">toType convert__fromType_to__toType(fromType x)</span>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromType</td><td>Typename of <span class="tt">value</span> field </td></tr>
    <tr><td class="paramname">toType</td><td>Typename of desired type </td></tr>
    <tr><td class="paramname">value</td><td>Actual value of type <span class="tt">fromType</span> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9505134796fc957eb9fedf172cab3527" name="ga9505134796fc957eb9fedf172cab3527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9505134796fc957eb9fedf172cab3527">&#9670;&#160;</a></span>lf_decay</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lf_decay</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="generics_8h.html">/Users/runner/work/reactor-c/reactor-c/util/generics.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">(&amp;*__builtin_choose_expr(<a class="code hl_define" href="#ga271f353ddab44fb05a4b0f8627904fbe">lf_is_pointer_or_array</a>(p), p, NULL))</div>
<div class="ttc" id="agroup__Utilities_html_ga271f353ddab44fb05a4b0f8627904fbe"><div class="ttname"><a href="#ga271f353ddab44fb05a4b0f8627904fbe">lf_is_pointer_or_array</a></div><div class="ttdeci">#define lf_is_pointer_or_array(p)</div><div class="ttdoc">Check whether the passed variable p is an array or a pointer.</div><div class="ttdef"><b>Definition</b> generics.h:57</div></div>
</div><!-- fragment -->
<p>Decay the specified pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pointer to decay. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The decayed pointer. </dd></dl>

</div>
</div>
<a id="gafe05484f1ece6fa30ba7b3bcf33f03b9" name="gafe05484f1ece6fa30ba7b3bcf33f03b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe05484f1ece6fa30ba7b3bcf33f03b9">&#9670;&#160;</a></span>lf_get_pointer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lf_get_pointer</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="generics_8h.html">/Users/runner/work/reactor-c/reactor-c/util/generics.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">__builtin_choose_expr(<a class="code hl_define" href="#ga9edb07d852ce1b4e090b36f8683c8017">lf_is_pointer</a>(p), p, &amp;p)</div>
<div class="ttc" id="agroup__Utilities_html_ga9edb07d852ce1b4e090b36f8683c8017"><div class="ttname"><a href="#ga9edb07d852ce1b4e090b36f8683c8017">lf_is_pointer</a></div><div class="ttdeci">#define lf_is_pointer(p)</div><div class="ttdoc">Check whether the passed variable p is a pointer.</div><div class="ttdef"><b>Definition</b> generics.h:75</div></div>
</div><!-- fragment -->
<p>Return the pointer for specified <span class="tt">p</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The variable to get the pointer for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer for the specified variable. </dd></dl>

</div>
</div>
<a id="ga9edb07d852ce1b4e090b36f8683c8017" name="ga9edb07d852ce1b4e090b36f8683c8017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9edb07d852ce1b4e090b36f8683c8017">&#9670;&#160;</a></span>lf_is_pointer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lf_is_pointer</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="generics_8h.html">/Users/runner/work/reactor-c/reactor-c/util/generics.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="#ga886f2df25fcc1b16e512d6143e910b6f">lf_is_same_type</a>(p, <a class="code hl_define" href="#ga9505134796fc957eb9fedf172cab3527">lf_decay</a>(p))</div>
<div class="ttc" id="agroup__Utilities_html_ga886f2df25fcc1b16e512d6143e910b6f"><div class="ttname"><a href="#ga886f2df25fcc1b16e512d6143e910b6f">lf_is_same_type</a></div><div class="ttdeci">#define lf_is_same_type(a, b)</div><div class="ttdoc">Check whether the types of both a and b are same.</div><div class="ttdef"><b>Definition</b> generics.h:28</div></div>
<div class="ttc" id="agroup__Utilities_html_ga9505134796fc957eb9fedf172cab3527"><div class="ttname"><a href="#ga9505134796fc957eb9fedf172cab3527">lf_decay</a></div><div class="ttdeci">#define lf_decay(p)</div><div class="ttdoc">Decay the specified pointer.</div><div class="ttdef"><b>Definition</b> generics.h:66</div></div>
</div><!-- fragment -->
<p>Check whether the passed variable <span class="tt">p</span> is a pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The variable to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the variable is a pointer, false otherwise. </dd></dl>

</div>
</div>
<a id="ga271f353ddab44fb05a4b0f8627904fbe" name="ga271f353ddab44fb05a4b0f8627904fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga271f353ddab44fb05a4b0f8627904fbe">&#9670;&#160;</a></span>lf_is_pointer_or_array</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lf_is_pointer_or_array</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="generics_8h.html">/Users/runner/work/reactor-c/reactor-c/util/generics.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">(__builtin_classify_type(p) == 5)</div>
</div><!-- fragment -->
<p>Check whether the passed variable <span class="tt">p</span> is an array or a pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The variable to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the variable is an array or a pointer, false otherwise. </dd></dl>

</div>
</div>
<a id="ga785378b93bab907d10fee21425a292e5" name="ga785378b93bab907d10fee21425a292e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga785378b93bab907d10fee21425a292e5">&#9670;&#160;</a></span>lf_is_same</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lf_is_same</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>typename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="generics_8h.html">/Users/runner/work/reactor-c/reactor-c/util/generics.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">__builtin_types_compatible_p(<span class="keyword">typename</span>, __typeof__(b))</div>
</div><!-- fragment -->
<p>Check whether the type of <span class="tt">b</span> is same as the specified <span class="tt">typename</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typename</td><td>The type to compare against. </td></tr>
    <tr><td class="paramname">b</td><td>The value to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the types are the same, false otherwise. </dd></dl>

</div>
</div>
<a id="ga886f2df25fcc1b16e512d6143e910b6f" name="ga886f2df25fcc1b16e512d6143e910b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga886f2df25fcc1b16e512d6143e910b6f">&#9670;&#160;</a></span>lf_is_same_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lf_is_same_type</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="generics_8h.html">/Users/runner/work/reactor-c/reactor-c/util/generics.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">__builtin_types_compatible_p(__typeof__(a), __typeof__(b))</div>
</div><!-- fragment -->
<p>Check whether the types of both <span class="tt">a</span> and <span class="tt">b</span> are same. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first value to compare. </td></tr>
    <tr><td class="paramname">b</td><td>The second value to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the types are the same, false otherwise. </dd></dl>

</div>
</div>
<a id="ga7d7827494787f07637043eb90e285d44" name="ga7d7827494787f07637043eb90e285d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d7827494787f07637043eb90e285d44">&#9670;&#160;</a></span>lf_is_type_equal</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lf_is_type_equal</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>typename_a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>typename_b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="generics_8h.html">/Users/runner/work/reactor-c/reactor-c/util/generics.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">__builtin_types_compatible_p(typename_a, typename_b)</div>
</div><!-- fragment -->
<p>Check whether the type of <span class="tt">typename_a</span> is same as the type of <span class="tt">typename_b</span>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typename_a</td><td>The first type to compare against. </td></tr>
    <tr><td class="paramname">typename_b</td><td>The second type to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the types are the same, false otherwise. </dd></dl>

</div>
</div>
<a id="ga99938402e4e9202fe51e67f6e916f0f5" name="ga99938402e4e9202fe51e67f6e916f0f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99938402e4e9202fe51e67f6e916f0f5">&#9670;&#160;</a></span>lf_to_left_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lf_to_left_type</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>left</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>right</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="generics_8h.html">/Users/runner/work/reactor-c/reactor-c/util/generics.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">  __builtin_choose_expr(<a class="code hl_define" href="#ga271f353ddab44fb05a4b0f8627904fbe">lf_is_pointer_or_array</a>(left),                                                                  \</div>
<div class="line">                        __builtin_choose_expr(<a class="code hl_define" href="#ga271f353ddab44fb05a4b0f8627904fbe">lf_is_pointer_or_array</a>(right), (right), &amp;(right)),                       \</div>
<div class="line">                        __builtin_choose_expr(<a class="code hl_define" href="#ga271f353ddab44fb05a4b0f8627904fbe">lf_is_pointer_or_array</a>(right), *(right), (right)))</div>
</div><!-- fragment -->
<p>Check types for both <span class="tt">left</span> and <span class="tt">right</span> and return appropriate value based on <span class="tt">left</span> type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>The left value to check. </td></tr>
    <tr><td class="paramname">right</td><td>The right value to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The appropriate value based on <span class="tt">left</span> type. </dd></dl>

</div>
</div>
<a id="ga141b139da77580918b0f9821ab3dbb99" name="ga141b139da77580918b0f9821ab3dbb99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga141b139da77580918b0f9821ab3dbb99">&#9670;&#160;</a></span>MAX_AMPLITUDE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_AMPLITUDE&#160;&#160;&#160;32765</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="audio__loop_8h.html">/Users/runner/work/reactor-c/reactor-c/util/audio_loop.h</a>&gt;</code></p>

<p>Maximum amplitude for audio playback. </p>

</div>
</div>
<a id="gae5597ce31d23d11493e6e674fe257d73" name="gae5597ce31d23d11493e6e674fe257d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5597ce31d23d11493e6e674fe257d73">&#9670;&#160;</a></span>NUM_CHANNELS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUM_CHANNELS&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="audio__loop_8h.html">/Users/runner/work/reactor-c/reactor-c/util/audio_loop.h</a>&gt;</code></p>

<p>Number of channels for audio playback. </p>

</div>
</div>
<a id="ga5b0b677cb9527865430a9b3d7a71cb03" name="ga5b0b677cb9527865430a9b3d7a71cb03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b0b677cb9527865430a9b3d7a71cb03">&#9670;&#160;</a></span>NUM_NOTES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUM_NOTES&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="audio__loop_8h.html">/Users/runner/work/reactor-c/reactor-c/util/audio_loop.h</a>&gt;</code></p>

<p>Maximum number of notes that can play simultaneously. </p>

</div>
</div>
<a id="ga4b76a0c2859cfd819a343a780070ee2b" name="ga4b76a0c2859cfd819a343a780070ee2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b76a0c2859cfd819a343a780070ee2b">&#9670;&#160;</a></span>SAMPLE_RATE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SAMPLE_RATE&#160;&#160;&#160;44100</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="audio__loop_8h.html">/Users/runner/work/reactor-c/reactor-c/util/audio_loop.h</a>&gt;</code></p>

<p>Sample rate for audio playback. </p>

</div>
</div>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="gafc1887f5ebd7da3ce7dfc73beb195598" name="gafc1887f5ebd7da3ce7dfc73beb195598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc1887f5ebd7da3ce7dfc73beb195598">&#9670;&#160;</a></span>deque_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct deque_t deque_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="deque_8h.html">/Users/runner/work/reactor-c/reactor-c/util/deque.h</a>&gt;</code></p>

<p>A double-ended queue data structure. </p>

</div>
</div>
<a id="ga1044f93547018a97e5d3b50cac8a1516" name="ga1044f93547018a97e5d3b50cac8a1516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1044f93547018a97e5d3b50cac8a1516">&#9670;&#160;</a></span>hashmap_entry_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct hashmap_entry_t hashmap_entry_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="hashmap_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/impl/hashmap.h</a>&gt;</code></p>

<p>A hashmap entry. </p>

</div>
</div>
<a id="ga19e5de2971328f1de610c3a3f42d295f" name="ga19e5de2971328f1de610c3a3f42d295f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19e5de2971328f1de610c3a3f42d295f">&#9670;&#160;</a></span>hashmap_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct hashmap_t hashmap_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="hashmap_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/impl/hashmap.h</a>&gt;</code></p>

<p>A hashmap. </p>

</div>
</div>
<a id="ga464bd5c31a1a562536e2a54213135604" name="ga464bd5c31a1a562536e2a54213135604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga464bd5c31a1a562536e2a54213135604">&#9670;&#160;</a></span>lf_waveform_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct lf_waveform_t lf_waveform_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="wave__file__reader_8h.html">/Users/runner/work/reactor-c/reactor-c/util/wave_file_reader.h</a>&gt;</code></p>

<p>Waveform in 16-bit linear-PCM format. </p>
<p>The waveform element is an array containing audio samples. If there are two channels, then they are interleaved left and right channel. The length is the total number of samples, a multiple of the number of channels. </p>

</div>
</div>
<a id="gac6a5b15223a2905669f2ee7377fd3dbd" name="gac6a5b15223a2905669f2ee7377fd3dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6a5b15223a2905669f2ee7377fd3dbd">&#9670;&#160;</a></span>vector_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct vector_t vector_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="vector_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/vector.h</a>&gt;</code></p>

<p>A vector (resizing array) data type. </p>
<p>This struct implements a dynamic array that can grow as needed. It is designed to be a simple way of storing a collection of pointers that is frequently filled and then completely emptied. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="gae0d2efe97b2aac751245705e32d2c927" name="gae0d2efe97b2aac751245705e32d2c927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0d2efe97b2aac751245705e32d2c927">&#9670;&#160;</a></span>add_to_sound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_to_sound </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index_offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="audio__loop_8h.html">/Users/runner/work/reactor-c/reactor-c/util/audio_loop.h</a>&gt;</code></p>

<p>Add the given value to the current write buffer at the specified index. </p>
<p>If the resulting value is larger than what can be represented in the 16-bit short, truncate it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index_offset</td><td>Where in the buffer to add the amplitude. </td></tr>
    <tr><td class="paramname">value</td><td>The amplitude to add to whatever amplitude is already there. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0e4768355c448b3b0489d851271515bc" name="ga0e4768355c448b3b0489d851271515bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e4768355c448b3b0489d851271515bc">&#9670;&#160;</a></span>deque_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deque_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdeque__t.html">deque_t</a> *</td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="deque_8h.html">/Users/runner/work/reactor-c/reactor-c/util/deque.h</a>&gt;</code></p>

<p>Initialize the specified deque to an empty deque. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The deque. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac22527818b92ea67851c2fd4a2790cb7" name="gac22527818b92ea67851c2fd4a2790cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac22527818b92ea67851c2fd4a2790cb7">&#9670;&#160;</a></span>deque_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool deque_is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdeque__t.html">deque_t</a> *</td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="deque_8h.html">/Users/runner/work/reactor-c/reactor-c/util/deque.h</a>&gt;</code></p>

<p>Return true if the queue is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The deque. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3530b26ded106a84ef8571fab0e73d9e" name="ga3530b26ded106a84ef8571fab0e73d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3530b26ded106a84ef8571fab0e73d9e">&#9670;&#160;</a></span>deque_peek_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * deque_peek_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdeque__t.html">deque_t</a> *</td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="deque_8h.html">/Users/runner/work/reactor-c/reactor-c/util/deque.h</a>&gt;</code></p>

<p>Peek at the value on the front of the queue, leaving it on the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value on the front of the queue or NULL if the queue is empty. </dd></dl>

</div>
</div>
<a id="ga4b9e8a9de89f124d0cdc1199debb70be" name="ga4b9e8a9de89f124d0cdc1199debb70be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b9e8a9de89f124d0cdc1199debb70be">&#9670;&#160;</a></span>deque_peek_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * deque_peek_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdeque__t.html">deque_t</a> *</td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="deque_8h.html">/Users/runner/work/reactor-c/reactor-c/util/deque.h</a>&gt;</code></p>

<p>Peek at the value on the back of the queue, leaving it on the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value on the back of the queue or NULL if the queue is empty. </dd></dl>

</div>
</div>
<a id="ga841ec80a70a2e63f08aab990e528e1f9" name="ga841ec80a70a2e63f08aab990e528e1f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga841ec80a70a2e63f08aab990e528e1f9">&#9670;&#160;</a></span>deque_pop_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * deque_pop_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdeque__t.html">deque_t</a> *</td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="deque_8h.html">/Users/runner/work/reactor-c/reactor-c/util/deque.h</a>&gt;</code></p>

<p>Pop a value from the back of the queue, removing it from the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value on the back of the queue or NULL if the queue is empty. </dd></dl>

</div>
</div>
<a id="ga4acd616a7c971b1c137010c64801d746" name="ga4acd616a7c971b1c137010c64801d746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4acd616a7c971b1c137010c64801d746">&#9670;&#160;</a></span>deque_pop_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * deque_pop_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdeque__t.html">deque_t</a> *</td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="deque_8h.html">/Users/runner/work/reactor-c/reactor-c/util/deque.h</a>&gt;</code></p>

<p>Pop a value from the front of the queue, removing it from the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value on the front of the queue or NULL if the queue is empty. </dd></dl>

</div>
</div>
<a id="gac1ffd77da7496612086ea430f7d29563" name="gac1ffd77da7496612086ea430f7d29563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1ffd77da7496612086ea430f7d29563">&#9670;&#160;</a></span>deque_push_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deque_push_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdeque__t.html">deque_t</a> *</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="deque_8h.html">/Users/runner/work/reactor-c/reactor-c/util/deque.h</a>&gt;</code></p>

<p>Push a value to the back of the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The queue. </td></tr>
    <tr><td class="paramname">value</td><td>The value to push. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga19a0d218efcb14cc2c3d7b009a5d0f16" name="ga19a0d218efcb14cc2c3d7b009a5d0f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19a0d218efcb14cc2c3d7b009a5d0f16">&#9670;&#160;</a></span>deque_push_front()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void deque_push_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdeque__t.html">deque_t</a> *</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="deque_8h.html">/Users/runner/work/reactor-c/reactor-c/util/deque.h</a>&gt;</code></p>

<p>Push a value to the front of the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The queue. </td></tr>
    <tr><td class="paramname">value</td><td>The value to push. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad7e6969a2e1a7e7529575558103d512d" name="gad7e6969a2e1a7e7529575558103d512d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7e6969a2e1a7e7529575558103d512d">&#9670;&#160;</a></span>deque_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t deque_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdeque__t.html">deque_t</a> *</td>          <td class="paramname"><span class="paramname"><em>d</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="deque_8h.html">/Users/runner/work/reactor-c/reactor-c/util/deque.h</a>&gt;</code></p>

<p>Return the size of the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The deque. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the queue. </dd></dl>

</div>
</div>
<a id="ga562a694d5b2ed8c935aa08d78c488114" name="ga562a694d5b2ed8c935aa08d78c488114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga562a694d5b2ed8c935aa08d78c488114">&#9670;&#160;</a></span>end_sensor_simulator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void end_sensor_simulator </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="sensor__simulator_8h.html">/Users/runner/work/reactor-c/reactor-c/util/sensor_simulator.h</a>&gt;</code></p>

<p>End ncurses control of the terminal. </p>

</div>
</div>
<a id="gafa5597a9582cc604eb0da7aac536ce4c" name="gafa5597a9582cc604eb0da7aac536ce4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa5597a9582cc604eb0da7aac536ce4c">&#9670;&#160;</a></span>hashmap_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashmap_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhashmap__t.html">hashmap_t</a> *</td>          <td class="paramname"><span class="paramname"><em>hashmap</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="hashmap_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/impl/hashmap.h</a>&gt;</code></p>

<p>Free all memory used by the given hashmap. </p>

</div>
</div>
<a id="ga510dfb7539122a20f4f0e299a2d33c88" name="ga510dfb7539122a20f4f0e299a2d33c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga510dfb7539122a20f4f0e299a2d33c88">&#9670;&#160;</a></span>hashmap_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * hashmap_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhashmap__t.html">hashmap_t</a> *</td>          <td class="paramname"><span class="paramname"><em>hashmap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="hashmap_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/impl/hashmap.h</a>&gt;</code></p>

<p>Get the value associated with the given key. </p>
<p>Precondition: The key must be present in the map. </p>

</div>
</div>
<a id="ga67344ac16c34de2b935e8ff5f343cf6c" name="ga67344ac16c34de2b935e8ff5f343cf6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67344ac16c34de2b935e8ff5f343cf6c">&#9670;&#160;</a></span>hashmap_get_actual_address()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhashmap__entry__t.html">hashmap_entry_t</a> * hashmap_get_actual_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhashmap__t.html">hashmap_t</a> *</td>          <td class="paramname"><span class="paramname"><em>hashmap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="hashmap_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/impl/hashmap.h</a>&gt;</code></p>

<p>Return the actual address of the hashmap entry corresponding to <span class="tt">key</span>, or the address of the closest empty entry if no such entry exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hashmap</td><td>The hashmap to search. </td></tr>
    <tr><td class="paramname">key</td><td>The key from which to begin a search. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac0b6f823784483f653698db3371a7036" name="gac0b6f823784483f653698db3371a7036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0b6f823784483f653698db3371a7036">&#9670;&#160;</a></span>hashmap_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhashmap__t.html">hashmap_t</a> * hashmap_new </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>capacity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>nothing</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="hashmap_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/impl/hashmap.h</a>&gt;</code></p>

<p>Construct a new hashmap object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>A number that is much larger than the maximum number of items that this hashmap will contain. Insufficient surplus capacity will cause poor performance. </td></tr>
    <tr><td class="paramname">nothing</td><td>A key that is guaranteed never to be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga47e0b1518c46a6cf0ea799c49490581e" name="ga47e0b1518c46a6cf0ea799c49490581e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47e0b1518c46a6cf0ea799c49490581e">&#9670;&#160;</a></span>hashmap_put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashmap_put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhashmap__t.html">hashmap_t</a> *</td>          <td class="paramname"><span class="paramname"><em>hashmap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="hashmap_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/impl/hashmap.h</a>&gt;</code></p>

<p>Associate a value with the given key. </p>

</div>
</div>
<a id="ga31e95da7ee1f76c30b9fec773d9b380c" name="ga31e95da7ee1f76c30b9fec773d9b380c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31e95da7ee1f76c30b9fec773d9b380c">&#9670;&#160;</a></span>hashset_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hashset_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hashset_8h.html#ad69fd91d4c662d832841b95188dd47f4">hashset_t</a></td>          <td class="paramname"><span class="paramname"><em>set</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>item</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="hashset_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/hashset/hashset.h</a>&gt;</code></p>

<p>Add a pointer to the hashset. </p>
<p>Note that 0 and 1 are special values, meaning nil and deleted items. This function will return -1 indicating error if you try to add 0 or 1. This function may resize the hashset if it is approaching capacity. Returns zero if the item is already in the set and non-zero otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The hashset. </td></tr>
    <tr><td class="paramname">item</td><td>The item to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the item is already in the set and non-zero otherwise. </dd></dl>

</div>
</div>
<a id="ga2c94a06d31c15e8da48b04b3de1a9113" name="ga2c94a06d31c15e8da48b04b3de1a9113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c94a06d31c15e8da48b04b3de1a9113">&#9670;&#160;</a></span>hashset_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hashset_8h.html#ad69fd91d4c662d832841b95188dd47f4">hashset_t</a> hashset_create </td>
          <td>(</td>
          <td class="paramtype">unsigned short</td>          <td class="paramname"><span class="paramname"><em>nbits</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="hashset_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/hashset/hashset.h</a>&gt;</code></p>

<p>Create a hashset instance. </p>
<p>The returned value is a pointer. The caller must call <a class="el" href="#ga6e280b06a1572145d3211e36e47eea6e" title="Destroy the hashset instance, freeing allocated memory.">hashset_destroy()</a> to free allocated memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nbits</td><td>The log base 2 of the initial capacity of the hashset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the hashset. </dd></dl>

</div>
</div>
<a id="ga6e280b06a1572145d3211e36e47eea6e" name="ga6e280b06a1572145d3211e36e47eea6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e280b06a1572145d3211e36e47eea6e">&#9670;&#160;</a></span>hashset_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hashset_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hashset_8h.html#ad69fd91d4c662d832841b95188dd47f4">hashset_t</a></td>          <td class="paramname"><span class="paramname"><em>set</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="hashset_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/hashset/hashset.h</a>&gt;</code></p>

<p>Destroy the hashset instance, freeing allocated memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The hashset to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga55de036dbc978294c262a7751f4caa81" name="ga55de036dbc978294c262a7751f4caa81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55de036dbc978294c262a7751f4caa81">&#9670;&#160;</a></span>hashset_is_member()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hashset_is_member </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hashset_8h.html#ad69fd91d4c662d832841b95188dd47f4">hashset_t</a></td>          <td class="paramname"><span class="paramname"><em>set</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>item</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="hashset_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/hashset/hashset.h</a>&gt;</code></p>

<p>Returns non-zero if the item is in the hashset and zero otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The hashset. </td></tr>
    <tr><td class="paramname">item</td><td>The item to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the item is in the hashset and zero otherwise. </dd></dl>

</div>
</div>
<a id="ga5350d2cd6a1be22846c5541816fb857f" name="ga5350d2cd6a1be22846c5541816fb857f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5350d2cd6a1be22846c5541816fb857f">&#9670;&#160;</a></span>hashset_iterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="hashset__itr_8h.html#aabacd1abe5de3d3d03fb2b649a1f2ba5">hashset_itr_t</a> hashset_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hashset_8h.html#ad69fd91d4c662d832841b95188dd47f4">hashset_t</a></td>          <td class="paramname"><span class="paramname"><em>set</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="hashset__itr_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/hashset/hashset_itr.h</a>&gt;</code></p>

<p>Create a hashset iterator. </p>
<p>The caller should then iterate over the hashset as follows:</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="hashset__itr_8h.html#aabacd1abe5de3d3d03fb2b649a1f2ba5">hashset_itr_t</a> iterator = <a class="code hl_function" href="#ga5350d2cd6a1be22846c5541816fb857f">hashset_iterator</a>(my_hashset);</div>
<div class="line"><span class="keywordflow">while</span> (<a class="code hl_function" href="#ga1f8e715379e1c95db280451114056bd8">hashset_iterator_next</a>(iterator) &gt;= 0) {</div>
<div class="line">  <span class="keywordtype">void</span>* my_value = <a class="code hl_function" href="#ga08d3680504ca63e10abbf03b115acb1b">hashset_iterator_value</a>(iterator);</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="line">free(iterator);</div>
<div class="ttc" id="agroup__Utilities_html_ga08d3680504ca63e10abbf03b115acb1b"><div class="ttname"><a href="#ga08d3680504ca63e10abbf03b115acb1b">hashset_iterator_value</a></div><div class="ttdeci">void * hashset_iterator_value(hashset_itr_t itr)</div><div class="ttdoc">Return the value at the current index.</div></div>
<div class="ttc" id="agroup__Utilities_html_ga1f8e715379e1c95db280451114056bd8"><div class="ttname"><a href="#ga1f8e715379e1c95db280451114056bd8">hashset_iterator_next</a></div><div class="ttdeci">int hashset_iterator_next(hashset_itr_t itr)</div><div class="ttdoc">Advance to the next value in the hashset.</div></div>
<div class="ttc" id="agroup__Utilities_html_ga5350d2cd6a1be22846c5541816fb857f"><div class="ttname"><a href="#ga5350d2cd6a1be22846c5541816fb857f">hashset_iterator</a></div><div class="ttdeci">hashset_itr_t hashset_iterator(hashset_t set)</div><div class="ttdoc">Create a hashset iterator.</div></div>
<div class="ttc" id="ahashset__itr_8h_html_aabacd1abe5de3d3d03fb2b649a1f2ba5"><div class="ttname"><a href="hashset__itr_8h.html#aabacd1abe5de3d3d03fb2b649a1f2ba5">hashset_itr_t</a></div><div class="ttdeci">struct hashset_itr_st * hashset_itr_t</div><div class="ttdef"><b>Definition</b> hashset_itr.h:46</div></div>
</div><!-- fragment --><p> The caller must call <span class="tt">free()</span> on this iterator after using it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The hashset to iterate over. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A hashset iterator. </dd></dl>

</div>
</div>
<a id="ga50a2126c05927f7d11b0859af5a38f02" name="ga50a2126c05927f7d11b0859af5a38f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50a2126c05927f7d11b0859af5a38f02">&#9670;&#160;</a></span>hashset_iterator_has_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hashset_iterator_has_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hashset__itr_8h.html#aabacd1abe5de3d3d03fb2b649a1f2ba5">hashset_itr_t</a></td>          <td class="paramname"><span class="paramname"><em>itr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="hashset__itr_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/hashset/hashset_itr.h</a>&gt;</code></p>

<p>Return 1 if there is a next value in the hashset and 0 otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itr</td><td>The hashset iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if there is a next value in the hashset and 0 otherwise. </dd></dl>

</div>
</div>
<a id="ga1f8e715379e1c95db280451114056bd8" name="ga1f8e715379e1c95db280451114056bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f8e715379e1c95db280451114056bd8">&#9670;&#160;</a></span>hashset_iterator_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hashset_iterator_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hashset__itr_8h.html#aabacd1abe5de3d3d03fb2b649a1f2ba5">hashset_itr_t</a></td>          <td class="paramname"><span class="paramname"><em>itr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="hashset__itr_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/hashset/hashset_itr.h</a>&gt;</code></p>

<p>Advance to the next value in the hashset. </p>
<p>This returns a non-negative number (the current index) if there is a next item and -1 otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itr</td><td>The hashset iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current index. </dd></dl>

</div>
</div>
<a id="ga08d3680504ca63e10abbf03b115acb1b" name="ga08d3680504ca63e10abbf03b115acb1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08d3680504ca63e10abbf03b115acb1b">&#9670;&#160;</a></span>hashset_iterator_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * hashset_iterator_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hashset__itr_8h.html#aabacd1abe5de3d3d03fb2b649a1f2ba5">hashset_itr_t</a></td>          <td class="paramname"><span class="paramname"><em>itr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="hashset__itr_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/hashset/hashset_itr.h</a>&gt;</code></p>

<p>Return the value at the current index. </p>
<p>The called should check <a class="el" href="#ga50a2126c05927f7d11b0859af5a38f02">hashset_iterator_has_next</a> before calling this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">itr</td><td>The hashset iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value at the current index. </dd></dl>

</div>
</div>
<a id="ga8d4800d73d1a58ad953501d9035de5ec" name="ga8d4800d73d1a58ad953501d9035de5ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d4800d73d1a58ad953501d9035de5ec">&#9670;&#160;</a></span>hashset_num_items()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t hashset_num_items </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hashset_8h.html#ad69fd91d4c662d832841b95188dd47f4">hashset_t</a></td>          <td class="paramname"><span class="paramname"><em>set</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="hashset_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/hashset/hashset.h</a>&gt;</code></p>

<p>Return the number of items in the hashset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The hashset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of items in the hashset. </dd></dl>

</div>
</div>
<a id="ga5b0ad513d6e64cd754213b0103a094e0" name="ga5b0ad513d6e64cd754213b0103a094e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b0ad513d6e64cd754213b0103a094e0">&#9670;&#160;</a></span>hashset_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int hashset_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="hashset_8h.html#ad69fd91d4c662d832841b95188dd47f4">hashset_t</a></td>          <td class="paramname"><span class="paramname"><em>set</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>item</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="hashset_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/hashset/hashset.h</a>&gt;</code></p>

<p>Remove an item from the hashset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The hashset. </td></tr>
    <tr><td class="paramname">item</td><td>The item to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if the item was removed and zero if the item is not on the hashset. </dd></dl>

</div>
</div>
<a id="ga20d5fc7b37764eb8c3a4e917e93ad7d7" name="ga20d5fc7b37764eb8c3a4e917e93ad7d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20d5fc7b37764eb8c3a4e917e93ad7d7">&#9670;&#160;</a></span>lf_play_audio_waveform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lf_play_audio_waveform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlf__waveform__t.html">lf_waveform_t</a> *</td>          <td class="paramname"><span class="paramname"><em>waveform</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>emphasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a></td>          <td class="paramname"><span class="paramname"><em>start_time</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="audio__loop_8h.html">/Users/runner/work/reactor-c/reactor-c/util/audio_loop.h</a>&gt;</code></p>

<p>Play the specified waveform with the specified emphasis at the specified time. </p>
<p>If the waveform is null, play a simple tick (an impulse). If the waveform has length zero or volume 0, play nothing.</p>
<p>If the time is too far in the future (beyond the window of the current audio write buffer), then block until the audio output catches up. If the audio playback has already passed the specified point, then play the waveform as soon as possible and return 1. Otherwise, return 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waveform</td><td>The waveform to play or NULL to just play a tick. </td></tr>
    <tr><td class="paramname">emphasis</td><td>The emphasis (0.0 for silence, 1.0 for waveform volume). </td></tr>
    <tr><td class="paramname">start_time</td><td>The time to start playing the waveform. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7e03b277fd2f2b3ae6aa029e5256da3e" name="ga7e03b277fd2f2b3ae6aa029e5256da3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e03b277fd2f2b3ae6aa029e5256da3e">&#9670;&#160;</a></span>lf_start_audio_loop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_start_audio_loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a></td>          <td class="paramname"><span class="paramname"><em>start_time</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="audio__loop_8h.html">/Users/runner/work/reactor-c/reactor-c/util/audio_loop.h</a>&gt;</code></p>

<p>Start an audio loop thread that becomes ready to receive audio amplitude samples via <a class="el" href="#gae0d2efe97b2aac751245705e32d2c927">add_to_sound()</a>. </p>
<p>If there is already an audio loop running, then do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start_time</td><td>The logical time that aligns with the first audio buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga65266402bd1ede8be91b6a0a5a34f767" name="ga65266402bd1ede8be91b6a0a5a34f767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65266402bd1ede8be91b6a0a5a34f767">&#9670;&#160;</a></span>lf_stop_audio_loop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_stop_audio_loop </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="audio__loop_8h.html">/Users/runner/work/reactor-c/reactor-c/util/audio_loop.h</a>&gt;</code></p>

<p>Stop the audio loop thread. </p>

</div>
</div>
<a id="ga149d009d65a3c20d73bcf2ae7c9d6814" name="ga149d009d65a3c20d73bcf2ae7c9d6814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga149d009d65a3c20d73bcf2ae7c9d6814">&#9670;&#160;</a></span>read_wave_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlf__waveform__t.html">lf_waveform_t</a> * read_wave_file </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>path</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="wave__file__reader_8h.html">/Users/runner/work/reactor-c/reactor-c/util/wave_file_reader.h</a>&gt;</code></p>

<p>Open a wave file, check that the format is supported, allocate memory for the sample data, and fill the memory with the sample data. </p>
<p>It is up to the caller to free the memory when done with it. That code should first free the waveform element of the returned struct, then the struct itself. This implementation supports only 16-bit linear PCM files. On a Mac, you can convert audio files into this format using the afconvert utility.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of sample data or NULL if the file can't be opened or has an usupported format. </dd></dl>

</div>
</div>
<a id="ga196614841046dea5b94b2a60108fff40" name="ga196614841046dea5b94b2a60108fff40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga196614841046dea5b94b2a60108fff40">&#9670;&#160;</a></span>register_sensor_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int register_sensor_key </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>action</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="sensor__simulator_8h.html">/Users/runner/work/reactor-c/reactor-c/util/sensor_simulator.h</a>&gt;</code></p>

<p>Register a keyboard key to trigger the specified action. </p>
<p>Printable ASCII characters (codes 32 to 127) are supported plus '<br  />
' and '\0', where the latter registers a trigger to invoked when any key is pressed. If a specific key is registered and any key ('\0') is also registered, the registered and any key ('\0') is also registered, the any key trigger will be scheduled after the specific key is scheduled. If these triggers belong to different reactors, they could be invoked in parallel. This will fail if the specified key has already been registered (error code 1), or the key is not a supported key or a newline <br  />
 or any key '\0' (error code 2) or if the trigger is NULL (error code 3). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to register. </td></tr>
    <tr><td class="paramname">action</td><td>The action to trigger when the key is pressed (a pointer to an lf_action_based_t struct). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, error code for failure. </dd></dl>

</div>
</div>
<a id="ga3c9ec0901afe8264c0e75d40c940bd5a" name="ga3c9ec0901afe8264c0e75d40c940bd5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c9ec0901afe8264c0e75d40c940bd5a">&#9670;&#160;</a></span>show_tick()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void show_tick </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>character</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="sensor__simulator_8h.html">/Users/runner/work/reactor-c/reactor-c/util/sensor_simulator.h</a>&gt;</code></p>

<p>Place a tick (usually a single character) in the tick window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">character</td><td>The tick character. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga491b52110965df05da5f18cb820ae99f" name="ga491b52110965df05da5f18cb820ae99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga491b52110965df05da5f18cb820ae99f">&#9670;&#160;</a></span>start_sensor_simulator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int start_sensor_simulator </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>message_lines</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>number_of_lines</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>tick_window_width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>log_file</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>log_level</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="sensor__simulator_8h.html">/Users/runner/work/reactor-c/reactor-c/util/sensor_simulator.h</a>&gt;</code></p>

<p>Start the sensor simulator if it has not been already started. </p>
<p>This must be called at least once before any call to register_sensor_key. The specified message is an initial message to display at the upper left, typically a set of instructions, that remains displayed throughout the lifetime of the window. Please ensure that the message_lines array and its contained strings are not on the stack because they will be used later in a separate thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_lines</td><td>The message lines. </td></tr>
    <tr><td class="paramname">number_of_lines</td><td>The number of lines. </td></tr>
    <tr><td class="paramname">tick_window_width</td><td>The width of the tick window or 0 for none. </td></tr>
    <tr><td class="paramname">log_file</td><td>If non-NULL, the name of a file to which to write logging messages. </td></tr>
    <tr><td class="paramname">log_level</td><td>The level of log messages to redirect to the file. The level should be one of LOG_LEVEL_ERROR, LOG_LEVEL_WARNING, LOG_LEVEL_INFO, LOG_LEVEL_LOG, LOG_LEVEL_DEBUG, or LOG_LEVEL_ALL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, error code for failure. </dd></dl>

</div>
</div>
<a id="ga201cb1fd5299e01b6fdfb499d3008952" name="ga201cb1fd5299e01b6fdfb499d3008952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga201cb1fd5299e01b6fdfb499d3008952">&#9670;&#160;</a></span>vector_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ** vector_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> *</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="vector_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/vector.h</a>&gt;</code></p>

<p>Return a pointer to where the vector element at 'idx' is stored. </p>
<p>This can be used to set the value of the element or to read it. If the index is past the end of the vector, then the vector is automatically expanded and filled with NULL pointers as needed. If no element at <span class="tt">idx</span> has been previously set, then the value pointed to by the returned pointer will be NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The vector. </td></tr>
    <tr><td class="paramname">idx</td><td>The index into the vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the element at 'idx', which is itself a pointer. </dd></dl>

</div>
</div>
<a id="gab6ea681ea89fa128392d61ec7a516e31" name="gab6ea681ea89fa128392d61ec7a516e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6ea681ea89fa128392d61ec7a516e31">&#9670;&#160;</a></span>vector_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vector_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> *</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="vector_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/vector.h</a>&gt;</code></p>

<p>Free the memory held by the given vector, invalidating it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Any vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga640489760dfb72c2001de6ec560fb75f" name="ga640489760dfb72c2001de6ec560fb75f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga640489760dfb72c2001de6ec560fb75f">&#9670;&#160;</a></span>vector_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvector__t.html">vector_t</a> vector_new </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>initial_capacity</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="vector_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/vector.h</a>&gt;</code></p>

<p>Allocate and initialize a new vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initial_capacity</td><td>The desired initial capacity to allocate. Must be more than 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new vector with the given initial capacity. </dd></dl>

</div>
</div>
<a id="ga85cdea38a35554168aa2277d83f5a957" name="ga85cdea38a35554168aa2277d83f5a957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85cdea38a35554168aa2277d83f5a957">&#9670;&#160;</a></span>vector_pop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * vector_pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> *</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="vector_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/vector.h</a>&gt;</code></p>

<p>Remove and return some pointer that is contained in the given vector, or return NULL if the given vector is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Any vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga85a9501c4a715501dc0adeb04bd84dcb" name="ga85a9501c4a715501dc0adeb04bd84dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85a9501c4a715501dc0adeb04bd84dcb">&#9670;&#160;</a></span>vector_push()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vector_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> *</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>element</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="vector_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/vector.h</a>&gt;</code></p>

<p>Add the given element to the vector. </p>
<p>The given element should be non-null. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A vector that is to grow. </td></tr>
    <tr><td class="paramname">element</td><td>An element that the vector should contain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab5ad2a2c71548435b6072b31ac21a9c2" name="gab5ad2a2c71548435b6072b31ac21a9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5ad2a2c71548435b6072b31ac21a9c2">&#9670;&#160;</a></span>vector_pushall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vector_pushall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> *</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="vector_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/vector.h</a>&gt;</code></p>

<p>Add all elements of the given array to the vector. </p>
<p>Elements should be non-null. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A vector that is to grow. </td></tr>
    <tr><td class="paramname">array</td><td>An array of items to be added to the vector. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the given array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaa8f4318bf03a7886169e85c151b6903" name="gaaa8f4318bf03a7886169e85c151b6903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa8f4318bf03a7886169e85c151b6903">&#9670;&#160;</a></span>vector_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vector_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> *</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="vector_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/vector.h</a>&gt;</code></p>

<p>Return the size of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Any vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The size of the vector. </dd></dl>

</div>
</div>
<a id="ga41e7b0b4a43deefd94df37fd128de0bb" name="ga41e7b0b4a43deefd94df37fd128de0bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41e7b0b4a43deefd94df37fd128de0bb">&#9670;&#160;</a></span>vector_vote()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vector_vote </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> *</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="vector_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/vector.h</a>&gt;</code></p>

<p>Vote on whether this vector should be given less memory. </p>
<p>If <span class="tt">v</span> contains few elements, it becomes more likely to shrink. It is suggested that this function be called when the number of elements in <span class="tt">v</span> reaches a local maximum. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Any vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on <span class="timestamp"></span> for reactor-c by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
