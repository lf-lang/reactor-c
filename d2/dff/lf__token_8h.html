<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>reactor-c: include/core/lf_token.h File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">reactor-c
   </div>
   <div id="projectbrief">C Runtime for Lingua Franca</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d2/dff/lf__token_8h.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">lf_token.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Definitions for token objects, reference-counted wrappers around dynamically-allocated messages.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br />
</div>
<p><a href="../../d2/dff/lf__token_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d12/structtoken__type__t.html">token_type_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type information for tokens. Specifically, this struct contains the fields needed to support token types, which carry dynamically allocated data.  <a href="../../db/d12/structtoken__type__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d9c/structlf__sparse__io__record__t.html">lf_sparse_io_record_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d6b/structtoken__template__t.html">token_template_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for ports (<a class="el" href="../../da/de8/structlf__port__base__t.html" title="Base type for ports. Port structs are customized types because their payloads are type specific....">lf_port_base_t</a>) and actions (<a class="el" href="../../d6/d13/structtrigger__t.html">trigger_t</a>), which can carry tokens. The structs <a class="el" href="../../da/de8/structlf__port__base__t.html" title="Base type for ports. Port structs are customized types because their payloads are type specific....">lf_port_base_t</a> and <a class="el" href="../../d6/d13/structtrigger__t.html">trigger_t</a> should start with an instance of this struct so that they can be cast to this struct to access these fields in a uniform way.  <a href="../../de/d6b/structtoken__template__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/de8/structlf__port__base__t.html">lf_port_base_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for ports. Port structs are customized types because their payloads are type specific. This struct represents their common features. Given any pointer to a port struct, it can be cast to <a class="el" href="../../da/de8/structlf__port__base__t.html" title="Base type for ports. Port structs are customized types because their payloads are type specific....">lf_port_base_t</a> and then these common fields can be accessed. IMPORTANT: If this is changed, it must also be changed in CPortGenerator.java <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">generateAuxiliaryStruct()</a>.  <a href="../../da/de8/structlf__port__base__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0cb4f0fedba2f1e1fd3893440ab53647" id="r_a0cb4f0fedba2f1e1fd3893440ab53647"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">typedef</a> <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">enum</a> <a class="el" href="#abe23a36a87d2f0c076da417eb0114c7e">token_freed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0cb4f0fedba2f1e1fd3893440ab53647">token_freed</a></td></tr>
<tr class="separator:a0cb4f0fedba2f1e1fd3893440ab53647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58dc2f4a624d2f3030b7e5f3596e58d6" id="r_a58dc2f4a624d2f3030b7e5f3596e58d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">typedef</a> <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">struct</a> token_type_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58dc2f4a624d2f3030b7e5f3596e58d6">token_type_t</a></td></tr>
<tr class="memdesc:a58dc2f4a624d2f3030b7e5f3596e58d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type information for tokens. Specifically, this struct contains the fields needed to support token types, which carry dynamically allocated data.  <br /></td></tr>
<tr class="separator:a58dc2f4a624d2f3030b7e5f3596e58d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973e404c4c1bd798a54501d0e1d640f9" id="r_a973e404c4c1bd798a54501d0e1d640f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">typedef</a> <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">struct</a> lf_token_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a973e404c4c1bd798a54501d0e1d640f9">lf_token_t</a></td></tr>
<tr class="separator:a973e404c4c1bd798a54501d0e1d640f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6696d69bef6bb4bdd52ef9ab9d2c614" id="r_aa6696d69bef6bb4bdd52ef9ab9d2c614"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">typedef</a> <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">struct</a> lf_sparse_io_record_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6696d69bef6bb4bdd52ef9ab9d2c614">lf_sparse_io_record_t</a></td></tr>
<tr class="separator:aa6696d69bef6bb4bdd52ef9ab9d2c614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0befcbc6fe23c8dd0b6f483d4067e45" id="r_ad0befcbc6fe23c8dd0b6f483d4067e45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">typedef</a> <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">struct</a> token_template_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0befcbc6fe23c8dd0b6f483d4067e45">token_template_t</a></td></tr>
<tr class="memdesc:ad0befcbc6fe23c8dd0b6f483d4067e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for ports (<a class="el" href="../../da/de8/structlf__port__base__t.html" title="Base type for ports. Port structs are customized types because their payloads are type specific....">lf_port_base_t</a>) and actions (<a class="el" href="../../d6/d13/structtrigger__t.html">trigger_t</a>), which can carry tokens. The structs <a class="el" href="../../da/de8/structlf__port__base__t.html" title="Base type for ports. Port structs are customized types because their payloads are type specific....">lf_port_base_t</a> and <a class="el" href="../../d6/d13/structtrigger__t.html">trigger_t</a> should start with an instance of this struct so that they can be cast to this struct to access these fields in a uniform way.  <br /></td></tr>
<tr class="separator:ad0befcbc6fe23c8dd0b6f483d4067e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6202eb05c29c30bfd6a8fc203de6422f" id="r_a6202eb05c29c30bfd6a8fc203de6422f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">typedef</a> <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">struct</a> self_base_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6202eb05c29c30bfd6a8fc203de6422f">self_base_t</a></td></tr>
<tr class="separator:a6202eb05c29c30bfd6a8fc203de6422f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b17c088cd50ce69df73f1470a18799" id="r_a91b17c088cd50ce69df73f1470a18799"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">typedef</a> <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">struct</a> lf_port_base_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91b17c088cd50ce69df73f1470a18799">lf_port_base_t</a></td></tr>
<tr class="memdesc:a91b17c088cd50ce69df73f1470a18799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for ports. Port structs are customized types because their payloads are type specific. This struct represents their common features. Given any pointer to a port struct, it can be cast to <a class="el" href="../../da/de8/structlf__port__base__t.html" title="Base type for ports. Port structs are customized types because their payloads are type specific....">lf_port_base_t</a> and then these common fields can be accessed. IMPORTANT: If this is changed, it must also be changed in CPortGenerator.java <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">generateAuxiliaryStruct()</a>.  <br /></td></tr>
<tr class="separator:a91b17c088cd50ce69df73f1470a18799"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:abe23a36a87d2f0c076da417eb0114c7e" id="r_abe23a36a87d2f0c076da417eb0114c7e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe23a36a87d2f0c076da417eb0114c7e">token_freed</a> { <a class="el" href="#abe23a36a87d2f0c076da417eb0114c7ea3d7522b54086645e077eb70e78731c5c">NOT_FREED</a> = 0
, <a class="el" href="#abe23a36a87d2f0c076da417eb0114c7ea417a0268666423fd955fea6f38cde238">VALUE_FREED</a>
, <a class="el" href="#abe23a36a87d2f0c076da417eb0114c7ea0a6094445d7a54e61aa3a43f6d017e2b">TOKEN_FREED</a>
, <a class="el" href="#abe23a36a87d2f0c076da417eb0114c7ea02ef194d373714ee3ac62226729e0cb0">TOKEN_AND_VALUE_FREED</a>
 }</td></tr>
<tr class="separator:abe23a36a87d2f0c076da417eb0114c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa47b51a11727eec252ff7e786794bd88" id="r_aa47b51a11727eec252ff7e786794bd88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa47b51a11727eec252ff7e786794bd88">lf_new_token</a> (<a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">void</a> *<a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">port_or_action</a>, <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">void</a> *<a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">val</a>, <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">size_t</a> <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">len</a>)</td></tr>
<tr class="memdesc:aa47b51a11727eec252ff7e786794bd88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new disassociated token with type matching the specified port or action and containing the specified value and length. The value is assumed to point to dynamically allocated memory that will be automatically freed. The length is 1 unless the type of the port is an array, in which case the value points to an array of the specified length. The token must then be sent to the port using <code>lf_set_token</code> or scheduled with the action using <code>lf_schedule_token</code>. The token can also be safely sent to any other port or scheduled with any other action that has the same type. If it is not scheduled or sent, then it is up to the user to free the memory allocated for the token and its value.  <br /></td></tr>
<tr class="separator:aa47b51a11727eec252ff7e786794bd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8e6f18b021d0b8ece7e1b64280432f" id="r_aaf8e6f18b021d0b8ece7e1b64280432f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf8e6f18b021d0b8ece7e1b64280432f">lf_writable_copy</a> (<a class="el" href="../../da/de8/structlf__port__base__t.html">lf_port_base_t</a> *port)</td></tr>
<tr class="separator:aaf8e6f18b021d0b8ece7e1b64280432f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2798a92c59a1d46b602298cdbd187ab1" id="r_a2798a92c59a1d46b602298cdbd187ab1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#abe23a36a87d2f0c076da417eb0114c7e">token_freed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2798a92c59a1d46b602298cdbd187ab1">_lf_free_token</a> (<a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> *token)</td></tr>
<tr class="memdesc:a2798a92c59a1d46b602298cdbd187ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the specified token, if appropriate. If the reference count is greater than 0, then do not free anything. Otherwise, the token value (payload) will be freed, if there is one. Then the token itself will be freed. The freed token will be put on the recycling bin unless that bin has reached the designated capacity, in which case <a class="el" href="../../d6/df3/hashmap_8h.html#a3efbc6cc1cee65d1129402b3476becd9" title="Free all memory used by the given hashmap.">free()</a> will be used.  <br /></td></tr>
<tr class="separator:a2798a92c59a1d46b602298cdbd187ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4616dad8eeb4cbe04a4f9697d3de9b16" id="r_a4616dad8eeb4cbe04a4f9697d3de9b16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4616dad8eeb4cbe04a4f9697d3de9b16">_lf_new_token</a> (<a class="el" href="../../db/d12/structtoken__type__t.html">token_type_t</a> *type, <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">void</a> *value, <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">size_t</a> length)</td></tr>
<tr class="memdesc:a4616dad8eeb4cbe04a4f9697d3de9b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new token with the specified type, value, and length. This will attempt to get one from the recyling bin, and, if the recycling bin is empty, will allocate a new token using calloc and set its type to point to the specified type. The returned token will indicate that it is not a template token, and its reference count will be 0.  <br /></td></tr>
<tr class="separator:a4616dad8eeb4cbe04a4f9697d3de9b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2f9c98968a10bf4d37077fd363ac48" id="r_a8f2f9c98968a10bf4d37077fd363ac48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f2f9c98968a10bf4d37077fd363ac48">_lf_get_token</a> (<a class="el" href="../../de/d6b/structtoken__template__t.html">token_template_t</a> *tmplt)</td></tr>
<tr class="separator:a8f2f9c98968a10bf4d37077fd363ac48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1a2996844350bc1e29de47e3b56644" id="r_a5d1a2996844350bc1e29de47e3b56644"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d1a2996844350bc1e29de47e3b56644">_lf_initialize_template</a> (<a class="el" href="../../de/d6b/structtoken__template__t.html">token_template_t</a> *tmplt, <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">size_t</a> element_size)</td></tr>
<tr class="separator:a5d1a2996844350bc1e29de47e3b56644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac171b72d59f37653f012d30cad72a2d2" id="r_ac171b72d59f37653f012d30cad72a2d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac171b72d59f37653f012d30cad72a2d2">_lf_initialize_token_with_value</a> (<a class="el" href="../../de/d6b/structtoken__template__t.html">token_template_t</a> *tmplt, <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">void</a> *value, <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">size_t</a> length)</td></tr>
<tr class="separator:ac171b72d59f37653f012d30cad72a2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2c7940f2e59f5ff57807df6b41f5fe" id="r_a6e2c7940f2e59f5ff57807df6b41f5fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e2c7940f2e59f5ff57807df6b41f5fe">_lf_initialize_token</a> (<a class="el" href="../../de/d6b/structtoken__template__t.html">token_template_t</a> *tmplt, <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">size_t</a> length)</td></tr>
<tr class="separator:a6e2c7940f2e59f5ff57807df6b41f5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd97c46ee623b1ae34a70088ee9b5020" id="r_afd97c46ee623b1ae34a70088ee9b5020"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd97c46ee623b1ae34a70088ee9b5020">_lf_free_all_tokens</a> ()</td></tr>
<tr class="memdesc:afd97c46ee623b1ae34a70088ee9b5020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all tokens. Free tokens on the _lf_token_recycling_bin hashset and all template tokens.  <br /></td></tr>
<tr class="separator:afd97c46ee623b1ae34a70088ee9b5020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeff98dcfb6b5715aac8e1438c5a6e77" id="r_abeff98dcfb6b5715aac8e1438c5a6e77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abeff98dcfb6b5715aac8e1438c5a6e77">_lf_replace_template_token</a> (<a class="el" href="../../de/d6b/structtoken__template__t.html">token_template_t</a> *tmplt, <a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> *<a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">newtoken</a>)</td></tr>
<tr class="memdesc:abeff98dcfb6b5715aac8e1438c5a6e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the token in the specified template, if there is one, with a new one. If the new token is the same as the token in the template, then this does nothing. Otherwise, it frees the previous template token.  <br /></td></tr>
<tr class="separator:abeff98dcfb6b5715aac8e1438c5a6e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c890be1f8d45461a6985cbfe6faa99" id="r_a88c890be1f8d45461a6985cbfe6faa99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#abe23a36a87d2f0c076da417eb0114c7e">token_freed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88c890be1f8d45461a6985cbfe6faa99">_lf_done_using</a> (<a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> *token)</td></tr>
<tr class="separator:a88c890be1f8d45461a6985cbfe6faa99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2135b542c27f1bf1aa22fdc243098b6b" id="r_a2135b542c27f1bf1aa22fdc243098b6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2135b542c27f1bf1aa22fdc243098b6b">_lf_free_token_copies</a> (<a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">struct</a> <a class="el" href="../../d2/d01/structenvironment__t.html">environment_t</a> *env)</td></tr>
<tr class="memdesc:a2135b542c27f1bf1aa22fdc243098b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free token copies made for mutable inputs. This function should be called at the beginning of each time step to avoid memory leaks.  <br /></td></tr>
<tr class="separator:a2135b542c27f1bf1aa22fdc243098b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac77b531bdbb49e0c716ba513a66538cb" id="r_ac77b531bdbb49e0c716ba513a66538cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac77b531bdbb49e0c716ba513a66538cb">_lf_tokens_allocated_in_reactions</a></td></tr>
<tr class="memdesc:ac77b531bdbb49e0c716ba513a66538cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of tokens created within reactions that must be freed. Tokens created by lf_writable_copy, which is automatically invoked when an input is mutable, must have their reference count decremented at the end of a tag (or the beginning of the next tag). Otherwise, their memory could leak. If they are passed on to an output or to a call to lf_schedule during the reaction, then those will also result in incremented reference counts, enabling the token to live on until used. For example, a new token created by lf_writable_copy could become the new template token for an output via a call to lf_set.  <br /></td></tr>
<tr class="separator:ac77b531bdbb49e0c716ba513a66538cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4657205de7da8f0bf7b346985a983fc" id="r_af4657205de7da8f0bf7b346985a983fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4657205de7da8f0bf7b346985a983fc">_lf_count_token_allocations</a></td></tr>
<tr class="separator:af4657205de7da8f0bf7b346985a983fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Definitions for token objects, reference-counted wrappers around dynamically-allocated messages. </p>
<dl class="section author"><dt>Author</dt><dd>Edward A. Lee (<a href="#" onclick="location.href='mai'+'lto:'+'eal'+'@b'+'erk'+'el'+'ey.'+'ed'+'u'; return false;">eal@b<span class="obfuscator">.nosp@m.</span>erke<span class="obfuscator">.nosp@m.</span>ley.e<span class="obfuscator">.nosp@m.</span>du</a>) </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>(c) 2020-2024, The University of California at Berkeley. License: <a href="https://github.com/lf-lang/reactor-c/blob/main/LICENSE.md">BSD 2-clause</a> </dd></dl>
<p>This header file supports token objects, which are reference-counted wrappers around values that are carried by events scheduled on the event queue and held in ports and actions when the type is not a primitive type.</p>
<p>A token has type <a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a>. It points to a value, a dynamically allocated chunk of memory on the heap. It has a length field, which enables its value to be interpreted as an array of the given length. It has a pointer to type (<a class="el" href="../../db/d12/structtoken__type__t.html" title="Type information for tokens. Specifically, this struct contains the fields needed to support token ty...">token_type_t</a>), which has an element_size field specifying the size of each array element (or the size of the whole value if it is not an array and has length 1). The type also optionally has function pointers to a destructor and copy constructor. These must be specified if the payload (value) is a complex struct that cannot be freed by a simple call to <a class="el" href="../../d6/df3/hashmap_8h.html#a3efbc6cc1cee65d1129402b3476becd9" title="Free all memory used by the given hashmap.">free()</a> or copied by a call to <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">memcpy()</a>.</p>
<p>An instance of a port struct and <a class="el" href="../../d6/d13/structtrigger__t.html">trigger_t</a> struct (an action or an input port) can be cast to <a class="el" href="../../de/d6b/structtoken__template__t.html" title="Base type for ports (lf_port_base_t) and actions (trigger_t), which can carry tokens....">token_template_t</a>, which has a <a class="el" href="../../db/d12/structtoken__type__t.html" title="Type information for tokens. Specifically, this struct contains the fields needed to support token ty...">token_type_t</a> field called type and a pointer to a token (which may be NULL). The same instance can also be cast to <a class="el" href="../../db/d12/structtoken__type__t.html" title="Type information for tokens. Specifically, this struct contains the fields needed to support token ty...">token_type_t</a>, which has an element_size field and (possibly) function pointers to a destructor and a copy constructor.</p>
<p>A "template token" is one pointed to by a <a class="el" href="../../de/d6b/structtoken__template__t.html" title="Base type for ports (lf_port_base_t) and actions (trigger_t), which can carry tokens....">token_template_t</a> (an action or a port). This template token ensures that port an action values persist until they are overwritten, and hence they can be read at a tag even if not present. Such a token will persist in the template until it is overwritten by another token. Every <a class="el" href="../../de/d6b/structtoken__template__t.html" title="Base type for ports (lf_port_base_t) and actions (trigger_t), which can carry tokens....">token_template_t</a> gets initialized with such a token. Before that token is used the first time, its reference count will be 0. Once it has been assigned a value, its reference count will be 1. When the <a class="el" href="../../de/d6b/structtoken__template__t.html" title="Base type for ports (lf_port_base_t) and actions (trigger_t), which can carry tokens....">token_template_t</a> (port or action) is assigned a new value, if the reference count is 1, then the same token will be reused, and any previous value (payload) will be freed. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a91b17c088cd50ce69df73f1470a18799" name="a91b17c088cd50ce69df73f1470a18799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b17c088cd50ce69df73f1470a18799">&#9670;&#160;</a></span>lf_port_base_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">typedef</a> <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">struct</a> lf_port_base_t lf_port_base_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base type for ports. Port structs are customized types because their payloads are type specific. This struct represents their common features. Given any pointer to a port struct, it can be cast to <a class="el" href="../../da/de8/structlf__port__base__t.html" title="Base type for ports. Port structs are customized types because their payloads are type specific....">lf_port_base_t</a> and then these common fields can be accessed. IMPORTANT: If this is changed, it must also be changed in CPortGenerator.java <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">generateAuxiliaryStruct()</a>. </p>

</div>
</div>
<a id="aa6696d69bef6bb4bdd52ef9ab9d2c614" name="aa6696d69bef6bb4bdd52ef9ab9d2c614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6696d69bef6bb4bdd52ef9ab9d2c614">&#9670;&#160;</a></span>lf_sparse_io_record_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">typedef</a> <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">struct</a> lf_sparse_io_record_t lf_sparse_io_record_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A record of the subset of channels of a multiport that have present inputs. </p>

</div>
</div>
<a id="a973e404c4c1bd798a54501d0e1d640f9" name="a973e404c4c1bd798a54501d0e1d640f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a973e404c4c1bd798a54501d0e1d640f9">&#9670;&#160;</a></span>lf_token_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">typedef</a> <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">struct</a> lf_token_t lf_token_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Token type for dynamically allocated arrays and structs sent as messages.</p>
<p>This struct is the wrapper around the dynamically allocated memory that carries the message. The message can be an array of values, where the size of each value is element_size (in bytes). If it is not an array, or is not to be treated as an array, the length == 1.</p>
<p>In the C LF target, a type for an output that ends in '*' or '[]' is treated specially. The value carried by the output is assumed to be in dynamically allocated memory, and, using reference counting, after the last downstream reader of the value has finished, the memory will be freed. To prevent this freeing from occurring, the output type can be specified using the syntax {= type* =}; this will not be treated as dynamically allocated memory. Alternatively, the programmer can give a typedef in the preamble that masks the trailing *. </p>

</div>
</div>
<a id="a6202eb05c29c30bfd6a8fc203de6422f" name="a6202eb05c29c30bfd6a8fc203de6422f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6202eb05c29c30bfd6a8fc203de6422f">&#9670;&#160;</a></span>self_base_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">typedef</a> <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">struct</a> self_base_t self_base_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0cb4f0fedba2f1e1fd3893440ab53647" name="a0cb4f0fedba2f1e1fd3893440ab53647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cb4f0fedba2f1e1fd3893440ab53647">&#9670;&#160;</a></span>token_freed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">typedef</a> <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">enum</a> <a class="el" href="#abe23a36a87d2f0c076da417eb0114c7e">token_freed</a> <a class="el" href="#abe23a36a87d2f0c076da417eb0114c7e">token_freed</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Possible return values for _lf_done_using and _lf_free_token. </p>

</div>
</div>
<a id="ad0befcbc6fe23c8dd0b6f483d4067e45" name="ad0befcbc6fe23c8dd0b6f483d4067e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0befcbc6fe23c8dd0b6f483d4067e45">&#9670;&#160;</a></span>token_template_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">typedef</a> <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">struct</a> token_template_t token_template_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base type for ports (<a class="el" href="../../da/de8/structlf__port__base__t.html" title="Base type for ports. Port structs are customized types because their payloads are type specific....">lf_port_base_t</a>) and actions (<a class="el" href="../../d6/d13/structtrigger__t.html">trigger_t</a>), which can carry tokens. The structs <a class="el" href="../../da/de8/structlf__port__base__t.html" title="Base type for ports. Port structs are customized types because their payloads are type specific....">lf_port_base_t</a> and <a class="el" href="../../d6/d13/structtrigger__t.html">trigger_t</a> should start with an instance of this struct so that they can be cast to this struct to access these fields in a uniform way. </p>

</div>
</div>
<a id="a58dc2f4a624d2f3030b7e5f3596e58d6" name="a58dc2f4a624d2f3030b7e5f3596e58d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58dc2f4a624d2f3030b7e5f3596e58d6">&#9670;&#160;</a></span>token_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">typedef</a> <a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">struct</a> token_type_t token_type_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type information for tokens. Specifically, this struct contains the fields needed to support token types, which carry dynamically allocated data. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="abe23a36a87d2f0c076da417eb0114c7e" name="abe23a36a87d2f0c076da417eb0114c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe23a36a87d2f0c076da417eb0114c7e">&#9670;&#160;</a></span>token_freed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">enum</a> <a class="el" href="#abe23a36a87d2f0c076da417eb0114c7e">token_freed</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Possible return values for _lf_done_using and _lf_free_token. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abe23a36a87d2f0c076da417eb0114c7ea3d7522b54086645e077eb70e78731c5c" name="abe23a36a87d2f0c076da417eb0114c7ea3d7522b54086645e077eb70e78731c5c"></a>NOT_FREED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abe23a36a87d2f0c076da417eb0114c7ea417a0268666423fd955fea6f38cde238" name="abe23a36a87d2f0c076da417eb0114c7ea417a0268666423fd955fea6f38cde238"></a>VALUE_FREED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abe23a36a87d2f0c076da417eb0114c7ea0a6094445d7a54e61aa3a43f6d017e2b" name="abe23a36a87d2f0c076da417eb0114c7ea0a6094445d7a54e61aa3a43f6d017e2b"></a>TOKEN_FREED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="abe23a36a87d2f0c076da417eb0114c7ea02ef194d373714ee3ac62226729e0cb0" name="abe23a36a87d2f0c076da417eb0114c7ea02ef194d373714ee3ac62226729e0cb0"></a>TOKEN_AND_VALUE_FREED&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a88c890be1f8d45461a6985cbfe6faa99" name="a88c890be1f8d45461a6985cbfe6faa99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c890be1f8d45461a6985cbfe6faa99">&#9670;&#160;</a></span>_lf_done_using()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#abe23a36a87d2f0c076da417eb0114c7e">token_freed</a> _lf_done_using </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> *</td>          <td class="paramname"><span class="paramname"><em>token</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decrement the reference count of the specified token. If the reference count hits 0, free the memory for the value carried by the token, and, if the token is not also the template token of its trigger, free the token. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>Pointer to a token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOT_FREED if nothing was freed, VALUE_FREED if the value was freed, TOKEN_FREED if only the token was freed, and TOKEN_AND_VALUE_FREED if both the value and the token were freed. </dd></dl>

</div>
</div>
<a id="afd97c46ee623b1ae34a70088ee9b5020" name="afd97c46ee623b1ae34a70088ee9b5020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd97c46ee623b1ae34a70088ee9b5020">&#9670;&#160;</a></span>_lf_free_all_tokens()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">void</a> _lf_free_all_tokens </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free all tokens. Free tokens on the _lf_token_recycling_bin hashset and all template tokens. </p>

</div>
</div>
<a id="a2798a92c59a1d46b602298cdbd187ab1" name="a2798a92c59a1d46b602298cdbd187ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2798a92c59a1d46b602298cdbd187ab1">&#9670;&#160;</a></span>_lf_free_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#abe23a36a87d2f0c076da417eb0114c7e">token_freed</a> _lf_free_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> *</td>          <td class="paramname"><span class="paramname"><em>token</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the specified token, if appropriate. If the reference count is greater than 0, then do not free anything. Otherwise, the token value (payload) will be freed, if there is one. Then the token itself will be freed. The freed token will be put on the recycling bin unless that bin has reached the designated capacity, in which case <a class="el" href="../../d6/df3/hashmap_8h.html#a3efbc6cc1cee65d1129402b3476becd9" title="Free all memory used by the given hashmap.">free()</a> will be used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>Pointer to a token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOT_FREED if nothing was freed, VALUE_FREED if the value was freed, TOKEN_FREED if only the token was freed, and TOKEN_AND_VALUE_FREED if both the value and the token were freed. </dd></dl>

</div>
</div>
<a id="a2135b542c27f1bf1aa22fdc243098b6b" name="a2135b542c27f1bf1aa22fdc243098b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2135b542c27f1bf1aa22fdc243098b6b">&#9670;&#160;</a></span>_lf_free_token_copies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">void</a> _lf_free_token_copies </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">struct</a> <a class="el" href="../../d2/d01/structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free token copies made for mutable inputs. This function should be called at the beginning of each time step to avoid memory leaks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>Environment in which we are executing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f2f9c98968a10bf4d37077fd363ac48" name="a8f2f9c98968a10bf4d37077fd363ac48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2f9c98968a10bf4d37077fd363ac48">&#9670;&#160;</a></span>_lf_get_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> * _lf_get_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d6b/structtoken__template__t.html">token_template_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tmplt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a token for the specified template. If the template already has a token and the reference count is 1, then return that token. Otherwise, create a new token, make it the new template, and dissociate or free the previous template token. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmplt</td><td>The template. // template is a C++ keyword. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new or recycled <a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> struct. </dd></dl>

</div>
</div>
<a id="a5d1a2996844350bc1e29de47e3b56644" name="a5d1a2996844350bc1e29de47e3b56644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1a2996844350bc1e29de47e3b56644">&#9670;&#160;</a></span>_lf_initialize_template()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">void</a> _lf_initialize_template </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d6b/structtoken__template__t.html">token_template_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tmplt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">size_t</a></td>          <td class="paramname"><span class="paramname"><em>element_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the specified template to contain a token that is an array with the specified element size. If the template already has a token with a reference count greater than 1 or a non-matching type, it will be replaced and that token will be freed. The length of the returned token will be 0, its value will be NULL, and its reference count will be 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmplt</td><td>The template. // template is a C++ keyword. </td></tr>
    <tr><td class="paramname">element_size</td><td>The element size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e2c7940f2e59f5ff57807df6b41f5fe" name="a6e2c7940f2e59f5ff57807df6b41f5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2c7940f2e59f5ff57807df6b41f5fe">&#9670;&#160;</a></span>_lf_initialize_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> * _lf_initialize_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d6b/structtoken__template__t.html">token_template_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tmplt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">size_t</a></td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a token for storing an array of the specified length with new memory allocated (using calloc, so initialize to zero) for storing that array. If the template's token is available (it is non-null and its reference count is 1), then reuse it. Otherwise, create a new token and replace the template token with the new one, freeing the previous token from its template association. The element_size for elements of the array is specified by the specified template. The caller should populate the value and ref_count field of the returned token after this returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmplt</td><td>The token template (must not be NULL). // template is a C++ keyword. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the array, or 1 if it is not an array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either the template's token or a new one, in each case with a value field pointing to newly allocated memory. </dd></dl>

</div>
</div>
<a id="ac171b72d59f37653f012d30cad72a2d2" name="ac171b72d59f37653f012d30cad72a2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac171b72d59f37653f012d30cad72a2d2">&#9670;&#160;</a></span>_lf_initialize_token_with_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> * _lf_initialize_token_with_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d6b/structtoken__template__t.html">token_template_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tmplt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">void</a> *</td>          <td class="paramname"><span class="paramname"><em>value</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">size_t</a></td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a token storing the specified value, which is assumed to be either a scalar (if length is 1) or an array of the specified length. If the token in the specified template is available (it non-null and its reference count is 1), then return it. Otherwise, create a new token and replace the template token with the new one, freeing the previous token from its template association. The element_size for elements of the array is specified by the specified template.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmplt</td><td>A template for the token. // template is a C++ keyword. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the array. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the array, or 1 if it is not an array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either the specified token or a new one, in each case with a value field pointing to newly allocated memory. </dd></dl>

</div>
</div>
<a id="a4616dad8eeb4cbe04a4f9697d3de9b16" name="a4616dad8eeb4cbe04a4f9697d3de9b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4616dad8eeb4cbe04a4f9697d3de9b16">&#9670;&#160;</a></span>_lf_new_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> * _lf_new_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d12/structtoken__type__t.html">token_type_t</a> *</td>          <td class="paramname"><span class="paramname"><em>type</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">void</a> *</td>          <td class="paramname"><span class="paramname"><em>value</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">size_t</a></td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new token with the specified type, value, and length. This will attempt to get one from the recyling bin, and, if the recycling bin is empty, will allocate a new token using calloc and set its type to point to the specified type. The returned token will indicate that it is not a template token, and its reference count will be 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the token. </td></tr>
    <tr><td class="paramname">value</td><td>The value, or NULL to have no value. </td></tr>
    <tr><td class="paramname">length</td><td>The array length of the value, 1 to not be an array, or 0 to have no value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lf_token_t* </dd></dl>

</div>
</div>
<a id="abeff98dcfb6b5715aac8e1438c5a6e77" name="abeff98dcfb6b5715aac8e1438c5a6e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeff98dcfb6b5715aac8e1438c5a6e77">&#9670;&#160;</a></span>_lf_replace_template_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">void</a> _lf_replace_template_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d6b/structtoken__template__t.html">token_template_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tmplt</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> *</td>          <td class="paramname"><span class="paramname"><em>newtoken</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the token in the specified template, if there is one, with a new one. If the new token is the same as the token in the template, then this does nothing. Otherwise, it frees the previous template token. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmplt</td><td>Pointer to a template. // template is a C++ keyword. </td></tr>
    <tr><td class="paramname">newtoken</td><td>The replacement token. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa47b51a11727eec252ff7e786794bd88" name="aa47b51a11727eec252ff7e786794bd88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47b51a11727eec252ff7e786794bd88">&#9670;&#160;</a></span>lf_new_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> * lf_new_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">void</a> *</td>          <td class="paramname"><span class="paramname"><em>port_or_action</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">void</a> *</td>          <td class="paramname"><span class="paramname"><em>val</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">size_t</a></td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new disassociated token with type matching the specified port or action and containing the specified value and length. The value is assumed to point to dynamically allocated memory that will be automatically freed. The length is 1 unless the type of the port is an array, in which case the value points to an array of the specified length. The token must then be sent to the port using <code>lf_set_token</code> or scheduled with the action using <code>lf_schedule_token</code>. The token can also be safely sent to any other port or scheduled with any other action that has the same type. If it is not scheduled or sent, then it is up to the user to free the memory allocated for the token and its value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_or_action</td><td>A port or action. </td></tr>
    <tr><td class="paramname">val</td><td>The value. </td></tr>
    <tr><td class="paramname">len</td><td>The length, or 1 if it not an array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> struct. </dd></dl>

</div>
</div>
<a id="aaf8e6f18b021d0b8ece7e1b64280432f" name="aaf8e6f18b021d0b8ece7e1b64280432f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8e6f18b021d0b8ece7e1b64280432f">&#9670;&#160;</a></span>lf_writable_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> * lf_writable_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/de8/structlf__port__base__t.html">lf_port_base_t</a> *</td>          <td class="paramname"><span class="paramname"><em>port</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a writable copy of the token in the specified template. If the reference count is 1, this returns the template's token rather than a copy. The reference count will be 1. Otherwise, if the size of the token payload is zero, this also returns the original token, again with reference count of 1. Otherwise, this returns a new token with a reference count of 1. The new token is added to a list of tokens whose reference counts will be decremented at the start of the next tag. If the template has no token (it has a primitive type), then there is no need for a writable copy. Return NULL. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>An input port, cast to (lf_port_base_t*). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a writable copy of the token, or NULL if the type is primitive. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="af4657205de7da8f0bf7b346985a983fc" name="af4657205de7da8f0bf7b346985a983fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4657205de7da8f0bf7b346985a983fc">&#9670;&#160;</a></span>_lf_count_token_allocations</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/df3/hashmap_8h.html#ad2c17ed7e0d4d65a63bf9002aba2016f">int</a> _lf_count_token_allocations</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Counter used to issue a warning if memory is allocated for tokens and never freed. Note that every trigger will have one token allocated for it. That token is not counted because it is not expected to be freed. </p>

</div>
</div>
<a id="ac77b531bdbb49e0c716ba513a66538cb" name="ac77b531bdbb49e0c716ba513a66538cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77b531bdbb49e0c716ba513a66538cb">&#9670;&#160;</a></span>_lf_tokens_allocated_in_reactions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a>* _lf_tokens_allocated_in_reactions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of tokens created within reactions that must be freed. Tokens created by lf_writable_copy, which is automatically invoked when an input is mutable, must have their reference count decremented at the end of a tag (or the beginning of the next tag). Otherwise, their memory could leak. If they are passed on to an output or to a call to lf_schedule during the reaction, then those will also result in incremented reference counts, enabling the token to live on until used. For example, a new token created by lf_writable_copy could become the new template token for an output via a call to lf_set. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="../../dir_3d69f64eaf81436fe2b22361382717e5.html">core</a></li><li class="navelem"><a class="el" href="../../d2/dff/lf__token_8h.html">lf_token.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
