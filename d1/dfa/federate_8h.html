<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>reactor-c: include/core/federated/federate.h File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">reactor-c
   </div>
   <div id="projectbrief">C Runtime for Lingua Franca</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d1/dfa/federate_8h.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">federate.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Data structures and functions used and defined in <a class="el" href="../../d8/def/federate_8c.html" title="Utility functions for a federate in a federated execution.">federate.c</a>.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &quot;<a class="el" href="../../d2/dcd/tag_8h_source.html">tag.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d6/d1d/lf__types_8h_source.html">lf_types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../de/d26/environment_8h_source.html">environment.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../da/dfb/low__level__platform_8h_source.html">low_level_platform.h</a>&quot;</code><br />
</div>
<p><a href="../../d1/dfa/federate_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d7a/structfederate__instance__t.html">federate_instance_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d4f/structfederation__metadata__t.html">federation_metadata_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a2312893474cb0415e16af40b1de063ca" id="r_a2312893474cb0415e16af40b1de063ca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2312893474cb0415e16af40b1de063ca">ADVANCE_MESSAGE_INTERVAL</a>&#160;&#160;&#160;<a class="el" href="../../d2/dcd/tag_8h.html#a673a8ebab8ec621a1cf731871dd170c8">MSEC</a>(10)</td></tr>
<tr class="separator:a2312893474cb0415e16af40b1de063ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a675c841ec6a29e45cacc71b61ef8d270" id="r_a675c841ec6a29e45cacc71b61ef8d270"><td class="memItemLeft" align="right" valign="top">typedef struct federate_instance_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a675c841ec6a29e45cacc71b61ef8d270">federate_instance_t</a></td></tr>
<tr class="separator:a675c841ec6a29e45cacc71b61ef8d270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae335f4cb4e7d5e88ed712be8cf9592ac" id="r_ae335f4cb4e7d5e88ed712be8cf9592ac"><td class="memItemLeft" align="right" valign="top">typedef struct federation_metadata_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae335f4cb4e7d5e88ed712be8cf9592ac">federation_metadata_t</a></td></tr>
<tr class="separator:ae335f4cb4e7d5e88ed712be8cf9592ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d812b2acffbba5c8b1b72913513d19" id="r_a98d812b2acffbba5c8b1b72913513d19"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="#a9acb70e6b48452bd9d146e35bafc535c">parse_rti_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98d812b2acffbba5c8b1b72913513d19">parse_rti_code_t</a></td></tr>
<tr class="separator:a98d812b2acffbba5c8b1b72913513d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9acb70e6b48452bd9d146e35bafc535c" id="r_a9acb70e6b48452bd9d146e35bafc535c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9acb70e6b48452bd9d146e35bafc535c">parse_rti_code_t</a> { <br />
&#160;&#160;<a class="el" href="#a9acb70e6b48452bd9d146e35bafc535cac7f69f7c9e5aea9b8f54cf02870e2bf8">SUCCESS</a>
, <a class="el" href="#a9acb70e6b48452bd9d146e35bafc535cad65c958d0ccb000b69ef0ef4e3a5bfdf">INVALID_PORT</a>
, <a class="el" href="#a9acb70e6b48452bd9d146e35bafc535caea85d37354b294f21e7ab9c5c142a237">INVALID_HOST</a>
, <a class="el" href="#a9acb70e6b48452bd9d146e35bafc535ca1dbf923bd60da7209a684ed484935973">INVALID_USER</a>
, <br />
&#160;&#160;<a class="el" href="#a9acb70e6b48452bd9d146e35bafc535ca3ad4ab464aba04397206e8b89aa1955a">FAILED_TO_PARSE</a>
<br />
 }</td></tr>
<tr class="separator:a9acb70e6b48452bd9d146e35bafc535c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a904322a77f1741ad25860d573d3ef96e" id="r_a904322a77f1741ad25860d573d3ef96e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a904322a77f1741ad25860d573d3ef96e">lf_connect_to_federate</a> (uint16_t)</td></tr>
<tr class="memdesc:a904322a77f1741ad25860d573d3ef96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to the federate with the specified id.  <br /></td></tr>
<tr class="separator:a904322a77f1741ad25860d573d3ef96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e8c30255091911a80601bf341cf0a2" id="r_a92e8c30255091911a80601bf341cf0a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92e8c30255091911a80601bf341cf0a2">lf_connect_to_rti</a> (const char *hostname, int port_number)</td></tr>
<tr class="memdesc:a92e8c30255091911a80601bf341cf0a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to the RTI at the specified host and port.  <br /></td></tr>
<tr class="separator:a92e8c30255091911a80601bf341cf0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926a4fb7f9b045acb13fee6c2b7192dd" id="r_a926a4fb7f9b045acb13fee6c2b7192dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a926a4fb7f9b045acb13fee6c2b7192dd">lf_create_server</a> (int specified_port)</td></tr>
<tr class="memdesc:a926a4fb7f9b045acb13fee6c2b7192dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a server to listen to incoming P2P connections.  <br /></td></tr>
<tr class="separator:a926a4fb7f9b045acb13fee6c2b7192dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae427b4c0340dbe19d46c93708fb6151a" id="r_ae427b4c0340dbe19d46c93708fb6151a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae427b4c0340dbe19d46c93708fb6151a">lf_enqueue_port_absent_reactions</a> (<a class="el" href="../../d2/d01/structenvironment__t.html">environment_t</a> *env)</td></tr>
<tr class="memdesc:ae427b4c0340dbe19d46c93708fb6151a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue port absent reactions.  <br /></td></tr>
<tr class="separator:ae427b4c0340dbe19d46c93708fb6151a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf0f2e328634d13f36aeb2587bd7947" id="r_a5bf0f2e328634d13f36aeb2587bd7947"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bf0f2e328634d13f36aeb2587bd7947">lf_handle_p2p_connections_from_federates</a> (void *)</td></tr>
<tr class="memdesc:a5bf0f2e328634d13f36aeb2587bd7947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread to accept connections from other federates.  <br /></td></tr>
<tr class="separator:a5bf0f2e328634d13f36aeb2587bd7947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c93fd97eedb98f863773b15bb4d1be1" id="r_a7c93fd97eedb98f863773b15bb4d1be1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c93fd97eedb98f863773b15bb4d1be1">lf_latest_tag_confirmed</a> (<a class="el" href="../../db/df7/structtag__t.html">tag_t</a>)</td></tr>
<tr class="memdesc:a7c93fd97eedb98f863773b15bb4d1be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a latest tag confirmed (LTC) signal to the RTI.  <br /></td></tr>
<tr class="separator:a7c93fd97eedb98f863773b15bb4d1be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae612f180643d0436d4496738b957af68" id="r_ae612f180643d0436d4496738b957af68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a9acb70e6b48452bd9d146e35bafc535c">parse_rti_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae612f180643d0436d4496738b957af68">lf_parse_rti_addr</a> (const char *rti_addr)</td></tr>
<tr class="memdesc:ae612f180643d0436d4496738b957af68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the address of the RTI and store them into the global federation_metadata struct.  <br /></td></tr>
<tr class="separator:ae612f180643d0436d4496738b957af68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c68a6af36bc24d04d8637c3d4adc1d1" id="r_a3c68a6af36bc24d04d8637c3d4adc1d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c68a6af36bc24d04d8637c3d4adc1d1">lf_reset_status_fields_on_input_port_triggers</a> ()</td></tr>
<tr class="memdesc:a3c68a6af36bc24d04d8637c3d4adc1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the status fields on network input ports to unknown or absent.  <br /></td></tr>
<tr class="separator:a3c68a6af36bc24d04d8637c3d4adc1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f330bfe2fdb03cbf49596bcc012bc58" id="r_a2f330bfe2fdb03cbf49596bcc012bc58"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f330bfe2fdb03cbf49596bcc012bc58">lf_send_message</a> (int message_type, unsigned short port, unsigned short federate, const char *next_destination_str, size_t length, unsigned char *message)</td></tr>
<tr class="memdesc:a2f330bfe2fdb03cbf49596bcc012bc58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to another federate.  <br /></td></tr>
<tr class="separator:a2f330bfe2fdb03cbf49596bcc012bc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66bab08dc7c613a34e26ba054837e07" id="r_ac66bab08dc7c613a34e26ba054837e07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac66bab08dc7c613a34e26ba054837e07">lf_send_neighbor_structure_to_RTI</a> (int)</td></tr>
<tr class="memdesc:ac66bab08dc7c613a34e26ba054837e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send information about connections to the RTI.  <br /></td></tr>
<tr class="separator:ac66bab08dc7c613a34e26ba054837e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d69f68b22b5143c029f463d6efba4f" id="r_a33d69f68b22b5143c029f463d6efba4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/df7/structtag__t.html">tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33d69f68b22b5143c029f463d6efba4f">lf_send_next_event_tag</a> (<a class="el" href="../../d2/d01/structenvironment__t.html">environment_t</a> *env, <a class="el" href="../../db/df7/structtag__t.html">tag_t</a> tag, bool wait_for_reply)</td></tr>
<tr class="memdesc:a33d69f68b22b5143c029f463d6efba4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a next event tag (NET) signal.  <br /></td></tr>
<tr class="separator:a33d69f68b22b5143c029f463d6efba4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527e8cd401ba68b503403706815ed1a0" id="r_a527e8cd401ba68b503403706815ed1a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a527e8cd401ba68b503403706815ed1a0">lf_send_port_absent_to_federate</a> (<a class="el" href="../../d2/d01/structenvironment__t.html">environment_t</a> *env, <a class="el" href="../../d2/dcd/tag_8h.html#af5b4e62d03782997d813be6145316f4b">interval_t</a> additional_delay, unsigned short port_ID, unsigned short fed_ID)</td></tr>
<tr class="memdesc:a527e8cd401ba68b503403706815ed1a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a port absent message.  <br /></td></tr>
<tr class="separator:a527e8cd401ba68b503403706815ed1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d7e691d4b52f2c0dac90e772d86dd5" id="r_ab4d7e691d4b52f2c0dac90e772d86dd5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4d7e691d4b52f2c0dac90e772d86dd5">lf_send_stop_request_to_rti</a> (<a class="el" href="../../db/df7/structtag__t.html">tag_t</a> stop_tag)</td></tr>
<tr class="memdesc:ab4d7e691d4b52f2c0dac90e772d86dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a MSG_TYPE_STOP_REQUEST message to the RTI.  <br /></td></tr>
<tr class="separator:ab4d7e691d4b52f2c0dac90e772d86dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0931fe1bb9eac2a9beebe0c0ed03408e" id="r_a0931fe1bb9eac2a9beebe0c0ed03408e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0931fe1bb9eac2a9beebe0c0ed03408e">lf_send_tagged_message</a> (<a class="el" href="../../d2/d01/structenvironment__t.html">environment_t</a> *env, <a class="el" href="../../d2/dcd/tag_8h.html#af5b4e62d03782997d813be6145316f4b">interval_t</a> additional_delay, int message_type, unsigned short port, unsigned short federate, const char *next_destination_str, size_t length, unsigned char *message)</td></tr>
<tr class="memdesc:a0931fe1bb9eac2a9beebe0c0ed03408e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a tagged message to the specified port of the specified federate.  <br /></td></tr>
<tr class="separator:a0931fe1bb9eac2a9beebe0c0ed03408e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032d945ee3fd6995a5f7bb15b57f2ddf" id="r_a032d945ee3fd6995a5f7bb15b57f2ddf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a032d945ee3fd6995a5f7bb15b57f2ddf">lf_set_federation_id</a> (const char *fid)</td></tr>
<tr class="memdesc:a032d945ee3fd6995a5f7bb15b57f2ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the federation_id of this federate.  <br /></td></tr>
<tr class="separator:a032d945ee3fd6995a5f7bb15b57f2ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971322f63f26490a27bdd9006c05b8fe" id="r_a971322f63f26490a27bdd9006c05b8fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a971322f63f26490a27bdd9006c05b8fe">lf_stall_advance_level_federation</a> (<a class="el" href="../../d2/d01/structenvironment__t.html">environment_t</a> *env, size_t level)</td></tr>
<tr class="memdesc:a971322f63f26490a27bdd9006c05b8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until inputs statuses are known up to and including the specified level.  <br /></td></tr>
<tr class="separator:a971322f63f26490a27bdd9006c05b8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f2188d27dfffa9fbbd417bed9305ea" id="r_ab0f2188d27dfffa9fbbd417bed9305ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0f2188d27dfffa9fbbd417bed9305ea">lf_stall_advance_level_federation_locked</a> (size_t level)</td></tr>
<tr class="memdesc:ab0f2188d27dfffa9fbbd417bed9305ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <a class="el" href="#a971322f63f26490a27bdd9006c05b8fe" title="Wait until inputs statuses are known up to and including the specified level.">lf_stall_advance_level_federation()</a> that assumes the caller holds the mutex lock.  <br /></td></tr>
<tr class="separator:ab0f2188d27dfffa9fbbd417bed9305ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965db733286db780c46aef446cd5b040" id="r_a965db733286db780c46aef446cd5b040"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a965db733286db780c46aef446cd5b040">lf_synchronize_with_other_federates</a> ()</td></tr>
<tr class="memdesc:a965db733286db780c46aef446cd5b040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize the start with other federates via the RTI.  <br /></td></tr>
<tr class="separator:a965db733286db780c46aef446cd5b040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e5177d12e705274be1e6652b5d7c01" id="r_a84e5177d12e705274be1e6652b5d7c01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84e5177d12e705274be1e6652b5d7c01">lf_update_max_level</a> (<a class="el" href="../../db/df7/structtag__t.html">tag_t</a> tag, bool is_provisional)</td></tr>
<tr class="memdesc:a84e5177d12e705274be1e6652b5d7c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the max level allowed to advance (MLAA).  <br /></td></tr>
<tr class="separator:a84e5177d12e705274be1e6652b5d7c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a1881fdaaffead81a8d2993121d9cd78f" id="r_a1881fdaaffead81a8d2993121d9cd78f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/d79/lf__arduino__support_8h.html#a7f67574f8818b6b888aa06156db05a7f">lf_mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1881fdaaffead81a8d2993121d9cd78f">lf_outbound_socket_mutex</a></td></tr>
<tr class="separator:a1881fdaaffead81a8d2993121d9cd78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea10c9ed824595585d91f37dbfd4364" id="r_a4ea10c9ed824595585d91f37dbfd4364"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dd/d67/structlf__cond__t.html">lf_cond_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ea10c9ed824595585d91f37dbfd4364">lf_port_status_changed</a></td></tr>
<tr class="separator:a4ea10c9ed824595585d91f37dbfd4364"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Data structures and functions used and defined in <a class="el" href="../../d8/def/federate_8c.html" title="Utility functions for a federate in a federated execution.">federate.c</a>. </p>
<dl class="section author"><dt>Author</dt><dd>Soroush Bateni </dd>
<dd>
Peter Donovan </dd>
<dd>
Edward A. Lee </dd>
<dd>
Anirudh Rengarajsm </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>(c) 2020-2023, The University of California at Berkeley. License: <a href="https://github.com/lf-lang/reactor-c/blob/main/LICENSE.md">BSD 2-clause</a> </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a2312893474cb0415e16af40b1de063ca" name="a2312893474cb0415e16af40b1de063ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2312893474cb0415e16af40b1de063ca">&#9670;&#160;</a></span>ADVANCE_MESSAGE_INTERVAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADVANCE_MESSAGE_INTERVAL&#160;&#160;&#160;<a class="el" href="../../d2/dcd/tag_8h.html#a673a8ebab8ec621a1cf731871dd170c8">MSEC</a>(10)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a675c841ec6a29e45cacc71b61ef8d270" name="a675c841ec6a29e45cacc71b61ef8d270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675c841ec6a29e45cacc71b61ef8d270">&#9670;&#160;</a></span>federate_instance_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct federate_instance_t federate_instance_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Structure that a federate instance uses to keep track of its own state. </p>

</div>
</div>
<a id="ae335f4cb4e7d5e88ed712be8cf9592ac" name="ae335f4cb4e7d5e88ed712be8cf9592ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae335f4cb4e7d5e88ed712be8cf9592ac">&#9670;&#160;</a></span>federation_metadata_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct federation_metadata_t federation_metadata_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98d812b2acffbba5c8b1b72913513d19" name="a98d812b2acffbba5c8b1b72913513d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d812b2acffbba5c8b1b72913513d19">&#9670;&#160;</a></span>parse_rti_code_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="#a9acb70e6b48452bd9d146e35bafc535c">parse_rti_code_t</a> <a class="el" href="#a9acb70e6b48452bd9d146e35bafc535c">parse_rti_code_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a9acb70e6b48452bd9d146e35bafc535c" name="a9acb70e6b48452bd9d146e35bafc535c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9acb70e6b48452bd9d146e35bafc535c">&#9670;&#160;</a></span>parse_rti_code_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a9acb70e6b48452bd9d146e35bafc535c">parse_rti_code_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9acb70e6b48452bd9d146e35bafc535cac7f69f7c9e5aea9b8f54cf02870e2bf8" name="a9acb70e6b48452bd9d146e35bafc535cac7f69f7c9e5aea9b8f54cf02870e2bf8"></a>SUCCESS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9acb70e6b48452bd9d146e35bafc535cad65c958d0ccb000b69ef0ef4e3a5bfdf" name="a9acb70e6b48452bd9d146e35bafc535cad65c958d0ccb000b69ef0ef4e3a5bfdf"></a>INVALID_PORT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9acb70e6b48452bd9d146e35bafc535caea85d37354b294f21e7ab9c5c142a237" name="a9acb70e6b48452bd9d146e35bafc535caea85d37354b294f21e7ab9c5c142a237"></a>INVALID_HOST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9acb70e6b48452bd9d146e35bafc535ca1dbf923bd60da7209a684ed484935973" name="a9acb70e6b48452bd9d146e35bafc535ca1dbf923bd60da7209a684ed484935973"></a>INVALID_USER&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9acb70e6b48452bd9d146e35bafc535ca3ad4ab464aba04397206e8b89aa1955a" name="a9acb70e6b48452bd9d146e35bafc535ca3ad4ab464aba04397206e8b89aa1955a"></a>FAILED_TO_PARSE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a904322a77f1741ad25860d573d3ef96e" name="a904322a77f1741ad25860d573d3ef96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904322a77f1741ad25860d573d3ef96e">&#9670;&#160;</a></span>lf_connect_to_federate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_connect_to_federate </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to the federate with the specified id. </p>
<p>The established connection will then be used in functions such as <a class="el" href="#a0931fe1bb9eac2a9beebe0c0ed03408e" title="Send a tagged message to the specified port of the specified federate.">lf_send_tagged_message()</a> to send messages directly to the specified federate. This function first sends an MSG_TYPE_ADDRESS_QUERY message to the RTI to obtain the IP address and port number of the specified federate. It then attempts to establish a socket connection to the specified federate. If this fails, the program exits. If it succeeds, it sets element [id] of the _fed.sockets_for_outbound_p2p_connections global array to refer to the socket for communicating directly with the federate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remote_federate_id</td><td>The ID of the remote federate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92e8c30255091911a80601bf341cf0a2" name="a92e8c30255091911a80601bf341cf0a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e8c30255091911a80601bf341cf0a2">&#9670;&#160;</a></span>lf_connect_to_rti()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_connect_to_rti </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>hostname</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>port_number</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to the RTI at the specified host and port. </p>
<p>This will return the socket descriptor for the connection. If port_number is 0, then start at DEFAULT_PORT and increment the port number on each attempt. If an attempt fails, wait CONNECT_RETRY_INTERVAL and try again. If it fails after CONNECT_TIMEOUT, the program exits. If it succeeds, it sets the _fed.socket_TCP_RTI global variable to refer to the socket for communicating with the RTI. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>A hostname, such as "localhost". </td></tr>
    <tr><td class="paramname">port_number</td><td>A port number or 0 to start with the default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a926a4fb7f9b045acb13fee6c2b7192dd" name="a926a4fb7f9b045acb13fee6c2b7192dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926a4fb7f9b045acb13fee6c2b7192dd">&#9670;&#160;</a></span>lf_create_server()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_create_server </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>specified_port</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a server to listen to incoming P2P connections. </p>
<p>Such connections are used for physical connections or any connection if using decentralized coordination. This function only handles the creation of the server socket. The bound port for the server socket is then sent to the RTI by sending an MSG_TYPE_ADDRESS_ADVERTISEMENT message (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/da6/net__common_8h.html">net_common.h</a>). This function expects no response from the RTI.</dd></dl>
<p>If a port is specified by the user, that will be used. Otherwise, a random port will be assigned. If the bind fails, it will retry after PORT_BIND_RETRY_INTERVAL until it has tried PORT_BIND_RETRY_LIMIT times. Then it will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">specified_port</td><td>The port specified by the user or 0 to use a random port. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae427b4c0340dbe19d46c93708fb6151a" name="ae427b4c0340dbe19d46c93708fb6151a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae427b4c0340dbe19d46c93708fb6151a">&#9670;&#160;</a></span>lf_enqueue_port_absent_reactions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_enqueue_port_absent_reactions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/d01/structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enqueue port absent reactions. </p>
<p>These reactions will send a MSG_TYPE_PORT_ABSENT message to downstream federates if a given network output port is not present. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment of the federate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bf0f2e328634d13f36aeb2587bd7947" name="a5bf0f2e328634d13f36aeb2587bd7947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf0f2e328634d13f36aeb2587bd7947">&#9670;&#160;</a></span>lf_handle_p2p_connections_from_federates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * lf_handle_p2p_connections_from_federates </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread to accept connections from other federates. </p>
<p>This thread accepts connections from federates that send messages directly to this one (not through the RTI). This thread starts a thread for each accepted socket connection to read messages and, once it has opened all expected sockets, exits. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ignored</td><td>No argument needed for this thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c93fd97eedb98f863773b15bb4d1be1" name="a7c93fd97eedb98f863773b15bb4d1be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c93fd97eedb98f863773b15bb4d1be1">&#9670;&#160;</a></span>lf_latest_tag_confirmed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_latest_tag_confirmed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/df7/structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a latest tag confirmed (LTC) signal to the RTI. </p>
<p>This avoids the send if an equal or later LTC has previously been sent.</p>
<p>This function assumes the caller holds the mutex lock on the top-level environment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag_to_send</td><td>The tag to send. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae612f180643d0436d4496738b957af68" name="ae612f180643d0436d4496738b957af68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae612f180643d0436d4496738b957af68">&#9670;&#160;</a></span>lf_parse_rti_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9acb70e6b48452bd9d146e35bafc535c">parse_rti_code_t</a> lf_parse_rti_addr </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>rti_addr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse the address of the RTI and store them into the global federation_metadata struct. </p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="#a9acb70e6b48452bd9d146e35bafc535c">parse_rti_code_t</a> indicating the result of the parse. </dd></dl>

</div>
</div>
<a id="a3c68a6af36bc24d04d8637c3d4adc1d1" name="a3c68a6af36bc24d04d8637c3d4adc1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c68a6af36bc24d04d8637c3d4adc1d1">&#9670;&#160;</a></span>lf_reset_status_fields_on_input_port_triggers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_reset_status_fields_on_input_port_triggers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the status fields on network input ports to unknown or absent. </p>
<p>This will reset to absent if the last_known_status_tag field of the port is greater than or equal to the current tag of the top-level environment. This should be overriden to present if an event gets scheduled. Otherwise, set the status to unknown. </p><dl class="section note"><dt>Note</dt><dd>This function must be called at the beginning of each logical time. </dd></dl>

</div>
</div>
<a id="a2f330bfe2fdb03cbf49596bcc012bc58" name="a2f330bfe2fdb03cbf49596bcc012bc58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f330bfe2fdb03cbf49596bcc012bc58">&#9670;&#160;</a></span>lf_send_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lf_send_message </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>message_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short</td>          <td class="paramname"><span class="paramname"><em>port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short</td>          <td class="paramname"><span class="paramname"><em>federate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>next_destination_str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>message</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message to another federate. </p>
<p>This function is used for physical connections between federates. If the socket connection to the remote federate or the RTI has been broken, then this returns -1 without sending. Otherwise, it returns 0.</p>
<p>This method assumes that the caller does not hold the lf_outbound_socket_mutex lock, which it acquires to perform the send.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_type</td><td>The type of the message being sent (currently only MSG_TYPE_P2P_MESSAGE). </td></tr>
    <tr><td class="paramname">port</td><td>The ID of the destination port. </td></tr>
    <tr><td class="paramname">federate</td><td>The ID of the destination federate. </td></tr>
    <tr><td class="paramname">next_destination_str</td><td>The name of the next destination in string format (for reporting). </td></tr>
    <tr><td class="paramname">length</td><td>The message length. </td></tr>
    <tr><td class="paramname">message</td><td>The message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the message has been sent, -1 otherwise. </dd></dl>

</div>
</div>
<a id="ac66bab08dc7c613a34e26ba054837e07" name="ac66bab08dc7c613a34e26ba054837e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac66bab08dc7c613a34e26ba054837e07">&#9670;&#160;</a></span>lf_send_neighbor_structure_to_RTI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_send_neighbor_structure_to_RTI </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send information about connections to the RTI. </p>
<p>This is a generated function that sends information about connections between this federate and other federates where messages are routed through the RTI. Currently, this only includes logical connections when the coordination is centralized. This information is needed for the RTI to perform the centralized coordination. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/da6/net__common_8h.html#a48ec489cb1543b161c262f4bee6c9598">MSG_TYPE_NEIGHBOR_STRUCTURE</a> in <a class="el" href="../../d9/da6/net__common_8h.html">net_common.h</a> </dd></dl>

</div>
</div>
<a id="a33d69f68b22b5143c029f463d6efba4f" name="a33d69f68b22b5143c029f463d6efba4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d69f68b22b5143c029f463d6efba4f">&#9670;&#160;</a></span>lf_send_next_event_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/df7/structtag__t.html">tag_t</a> lf_send_next_event_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/d01/structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/df7/structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>wait_for_reply</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a next event tag (NET) signal. </p>
<p>If this federate depends on upstream federates or sends data to downstream federates, then send to the RTI a NET, which will give the tag of the earliest event on the event queue, or, if the queue is empty, the timeout time, or, if there is no timeout, FOREVER.</p>
<p>If there are network outputs that depend on physical actions, then insert a dummy event to ensure this federate advances its tag so that downstream federates can make progress.</p>
<p>A NET is a promise saying that, absent network inputs, this federate will not produce an output message with tag earlier than the NET value.</p>
<p>If there are upstream federates, then after sending a NET, this will block until either the RTI grants the advance to the requested time or the wait for the response from the RTI is interrupted by a change in the event queue (e.g., a physical action triggered or a network message arrived). If there are no upstream federates, then it will not wait for a TAG (which won't be forthcoming anyway) and returns the earliest tag on the event queue.</p>
<p>If the federate has neither upstream nor downstream federates, then this returns the specified tag immediately without sending anything to the RTI.</p>
<p>If there is at least one physical action somewhere in the federate that can trigger an output to a downstream federate, then the NET is required to be less than the current physical time. If physical time is less than the earliest event in the event queue (or the event queue is empty), then this function will insert a dummy event with a tag equal to the current physical time (and a microstep of 0). This will enforce advancement of tag for this federate and causes a NET message to be sent repeatedly as physical time advances with the time interval between messages controlled by the target parameter coordination-options: {advance-message-interval timevalue}. It will stop creating dummy events if and when its event queue has an event with a timestamp less than physical time.</p>
<p>If wait_for_reply is false, then this function will simply send the specified tag and return that tag immediately. This is useful when a federate is shutting down and will not be sending any more messages at all.</p>
<p>In all cases, this returns either the specified tag or another tag when it is safe to advance logical time to the returned tag. The returned tag may be less than the specified tag if there are upstream federates and either the RTI responds with a lesser tag or the wait for a response from the RTI is interrupted by a change in the event queue.</p>
<p>This function is used in centralized coordination only.</p>
<p>This function assumes the caller holds the mutex lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment of the federate </td></tr>
    <tr><td class="paramname">tag</td><td>The tag. </td></tr>
    <tr><td class="paramname">wait_for_reply</td><td>If true, wait for a reply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a527e8cd401ba68b503403706815ed1a0" name="a527e8cd401ba68b503403706815ed1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527e8cd401ba68b503403706815ed1a0">&#9670;&#160;</a></span>lf_send_port_absent_to_federate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_send_port_absent_to_federate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/d01/structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/dcd/tag_8h.html#af5b4e62d03782997d813be6145316f4b">interval_t</a></td>          <td class="paramname"><span class="paramname"><em>additional_delay</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short</td>          <td class="paramname"><span class="paramname"><em>port_ID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short</td>          <td class="paramname"><span class="paramname"><em>fed_ID</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a port absent message. </p>
<p>This informs the remote federate that it will not receive a message with tag less than the current tag of the specified environment delayed by the additional_delay.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment from which to get the current tag. </td></tr>
    <tr><td class="paramname">additional_delay</td><td>The after delay of the connection or NEVER if none. </td></tr>
    <tr><td class="paramname">port_ID</td><td>The ID of the receiving port. </td></tr>
    <tr><td class="paramname">fed_ID</td><td>The fed ID of the receiving federate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4d7e691d4b52f2c0dac90e772d86dd5" name="ab4d7e691d4b52f2c0dac90e772d86dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4d7e691d4b52f2c0dac90e772d86dd5">&#9670;&#160;</a></span>lf_send_stop_request_to_rti()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lf_send_stop_request_to_rti </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/df7/structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>stop_tag</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a MSG_TYPE_STOP_REQUEST message to the RTI. </p>
<p>The payload is the specified tag plus one microstep. If this federate has previously received a stop request from the RTI, then do not send the message and return 1. Return -1 if the socket is disconnected. Otherwise, return 0. </p><dl class="section return"><dt>Returns</dt><dd>0 if the message is sent. </dd></dl>

</div>
</div>
<a id="a0931fe1bb9eac2a9beebe0c0ed03408e" name="a0931fe1bb9eac2a9beebe0c0ed03408e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0931fe1bb9eac2a9beebe0c0ed03408e">&#9670;&#160;</a></span>lf_send_tagged_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lf_send_tagged_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/d01/structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/dcd/tag_8h.html#af5b4e62d03782997d813be6145316f4b">interval_t</a></td>          <td class="paramname"><span class="paramname"><em>additional_delay</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>message_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short</td>          <td class="paramname"><span class="paramname"><em>port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short</td>          <td class="paramname"><span class="paramname"><em>federate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>next_destination_str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>message</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a tagged message to the specified port of the specified federate. </p>
<p>The tag will be the current tag of the specified environment delayed by the specified additional_delay. If the delayed tag falls after the timeout time, then the message is not sent and -1 is returned. The caller can reuse or free the memory storing the message after this returns.</p>
<p>If the message fails to send (e.g. the socket connection is broken), then the response depends on the message_type. For MSG_TYPE_TAGGED_MESSAGE, the message is supposed to go via the RTI, and failure to communicate with the RTI is a critical failure. In this case, the program will exit with an error message. If the message type is MSG_TYPE_P2P_TAGGED_MESSAGE, then the failure is not critical. It may be due to the remote federate having exited, for example, because its safe-to-process offset led it to believe that there were no messages forthcoming. In this case, on failure to send the message, this function returns -11.</p>
<p>This method assumes that the caller does not hold the lf_outbound_socket_mutex lock, which it acquires to perform the send.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment from which to get the current tag. </td></tr>
    <tr><td class="paramname">additional_delay</td><td>The after delay on the connection or NEVER is there is none. </td></tr>
    <tr><td class="paramname">message_type</td><td>The type of the message being sent. Currently can be MSG_TYPE_TAGGED_MESSAGE for messages sent via the RTI or MSG_TYPE_P2P_TAGGED_MESSAGE for messages sent directly between federates. </td></tr>
    <tr><td class="paramname">port</td><td>The ID of the destination port. </td></tr>
    <tr><td class="paramname">federate</td><td>The ID of the destination federate. </td></tr>
    <tr><td class="paramname">next_destination_str</td><td>The next destination in string format (RTI or federate) (used for reporting errors). </td></tr>
    <tr><td class="paramname">length</td><td>The message length. </td></tr>
    <tr><td class="paramname">message</td><td>The message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the message has been sent, 1 otherwise. </dd></dl>

</div>
</div>
<a id="a032d945ee3fd6995a5f7bb15b57f2ddf" name="a032d945ee3fd6995a5f7bb15b57f2ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032d945ee3fd6995a5f7bb15b57f2ddf">&#9670;&#160;</a></span>lf_set_federation_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_set_federation_id </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fid</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the federation_id of this federate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fid</td><td>The federation ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a971322f63f26490a27bdd9006c05b8fe" name="a971322f63f26490a27bdd9006c05b8fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a971322f63f26490a27bdd9006c05b8fe">&#9670;&#160;</a></span>lf_stall_advance_level_federation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_stall_advance_level_federation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/d01/structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>level</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait until inputs statuses are known up to and including the specified level. </p>
<p>Specifically, wait until the specified level is less that the max level allowed to advance (MLAA). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment (which should always be the top-level environment). </td></tr>
    <tr><td class="paramname">level</td><td>The level to which we would like to advance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0f2188d27dfffa9fbbd417bed9305ea" name="ab0f2188d27dfffa9fbbd417bed9305ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f2188d27dfffa9fbbd417bed9305ea">&#9670;&#160;</a></span>lf_stall_advance_level_federation_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_stall_advance_level_federation_locked </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>level</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Version of <a class="el" href="#a971322f63f26490a27bdd9006c05b8fe" title="Wait until inputs statuses are known up to and including the specified level.">lf_stall_advance_level_federation()</a> that assumes the caller holds the mutex lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The level to which we would like to advance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a965db733286db780c46aef446cd5b040" name="a965db733286db780c46aef446cd5b040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a965db733286db780c46aef446cd5b040">&#9670;&#160;</a></span>lf_synchronize_with_other_federates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_synchronize_with_other_federates </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize the start with other federates via the RTI. </p>
<p>This assumes that a connection to the RTI is already made and _lf_rti_socket_TCP is valid. It then sends the current logical time to the RTI and waits for the RTI to respond with a specified time. It starts a thread to listen for messages from the RTI. </p>

</div>
</div>
<a id="a84e5177d12e705274be1e6652b5d7c01" name="a84e5177d12e705274be1e6652b5d7c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e5177d12e705274be1e6652b5d7c01">&#9670;&#160;</a></span>lf_update_max_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lf_update_max_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/df7/structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_provisional</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the max level allowed to advance (MLAA). </p>
<p>If the specified tag is greater than the current_tag of the top-level environment (or equal and is_provisional is false), then set the MLAA to INT_MAX and return. This removes any barriers on execution at the current tag due to network inputs. Otherwise, set the MLAA to the minimum level over all (non-physical) network input ports where the status of the input port is not known at that current_tag.</p>
<p>This function assumes that the caller holds the mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>The latest TAG or PTAG received by this federate. </td></tr>
    <tr><td class="paramname">is_provisional</td><td>Whether the tag was provisional. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the MLAA changed. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a1881fdaaffead81a8d2993121d9cd78f" name="a1881fdaaffead81a8d2993121d9cd78f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1881fdaaffead81a8d2993121d9cd78f">&#9670;&#160;</a></span>lf_outbound_socket_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d3/d79/lf__arduino__support_8h.html#a7f67574f8818b6b888aa06156db05a7f">lf_mutex_t</a> lf_outbound_socket_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mutex lock held while performing outbound socket write and close operations. </p>

</div>
</div>
<a id="a4ea10c9ed824595585d91f37dbfd4364" name="a4ea10c9ed824595585d91f37dbfd4364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea10c9ed824595585d91f37dbfd4364">&#9670;&#160;</a></span>lf_port_status_changed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d67/structlf__cond__t.html">lf_cond_t</a> lf_port_status_changed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Condition variable for blocking on unkonwn federate input ports. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="../../dir_3d69f64eaf81436fe2b22361382717e5.html">core</a></li><li class="navelem"><a class="el" href="../../dir_fdacdff5c3e9d6e52f439c05e95a860d.html">federated</a></li><li class="navelem"><a class="el" href="../../d1/dfa/federate_8h.html">federate.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
