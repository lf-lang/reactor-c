<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>reactor-c: core/lf_token.c File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">reactor-c
   </div>
   <div id="projectbrief">C Runtime for Lingua Franca</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d4/d37/lf__token_8c.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">lf_token.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Functions supporting token types. See <a class="el" href="../../d2/dff/lf__token_8h.html" title="Definitions for token objects, reference-counted wrappers around dynamically-allocated messages.">lf_token.h</a> for docs.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &quot;<a class="el" href="../../d2/dff/lf__token_8h_source.html">lf_token.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../de/d26/environment_8h_source.html">environment.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d6/d1d/lf__types_8h_source.html">lf_types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d0/d15/hashset__itr_8h_source.html">hashset/hashset_itr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../d8/d3c/util_8h_source.html">util.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../de/d03/platform_8h_source.html">platform.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="../../da/d00/port_8h_source.html">port.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad6be436dfb95ab914336870d340b207d" id="r_ad6be436dfb95ab914336870d340b207d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6be436dfb95ab914336870d340b207d">_LF_TOKEN_RECYCLING_BIN_SIZE_LIMIT</a>&#160;&#160;&#160;512</td></tr>
<tr class="separator:ad6be436dfb95ab914336870d340b207d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa47b51a11727eec252ff7e786794bd88" id="r_aa47b51a11727eec252ff7e786794bd88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa47b51a11727eec252ff7e786794bd88">lf_new_token</a> (void *port_or_action, void *val, size_t len)</td></tr>
<tr class="memdesc:aa47b51a11727eec252ff7e786794bd88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new disassociated token with type matching the specified port or action and containing the specified value and length. The value is assumed to point to dynamically allocated memory that will be automatically freed. The length is 1 unless the type of the port is an array, in which case the value points to an array of the specified length. The token must then be sent to the port using <code>lf_set_token</code> or scheduled with the action using <code>lf_schedule_token</code>. The token can also be safely sent to any other port or scheduled with any other action that has the same type. If it is not scheduled or sent, then it is up to the user to free the memory allocated for the token and its value.  <br /></td></tr>
<tr class="separator:aa47b51a11727eec252ff7e786794bd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8e6f18b021d0b8ece7e1b64280432f" id="r_aaf8e6f18b021d0b8ece7e1b64280432f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf8e6f18b021d0b8ece7e1b64280432f">lf_writable_copy</a> (<a class="el" href="../../da/de8/structlf__port__base__t.html">lf_port_base_t</a> *port)</td></tr>
<tr class="separator:aaf8e6f18b021d0b8ece7e1b64280432f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2798a92c59a1d46b602298cdbd187ab1" id="r_a2798a92c59a1d46b602298cdbd187ab1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/dff/lf__token_8h.html#abe23a36a87d2f0c076da417eb0114c7e">token_freed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2798a92c59a1d46b602298cdbd187ab1">_lf_free_token</a> (<a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> *token)</td></tr>
<tr class="memdesc:a2798a92c59a1d46b602298cdbd187ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the specified token, if appropriate. If the reference count is greater than 0, then do not free anything. Otherwise, the token value (payload) will be freed, if there is one. Then the token itself will be freed. The freed token will be put on the recycling bin unless that bin has reached the designated capacity, in which case <a class="el" href="../../d6/df3/hashmap_8h.html#a3efbc6cc1cee65d1129402b3476becd9" title="Free all memory used by the given hashmap.">free()</a> will be used.  <br /></td></tr>
<tr class="separator:a2798a92c59a1d46b602298cdbd187ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4616dad8eeb4cbe04a4f9697d3de9b16" id="r_a4616dad8eeb4cbe04a4f9697d3de9b16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4616dad8eeb4cbe04a4f9697d3de9b16">_lf_new_token</a> (<a class="el" href="../../db/d12/structtoken__type__t.html">token_type_t</a> *type, void *value, size_t length)</td></tr>
<tr class="memdesc:a4616dad8eeb4cbe04a4f9697d3de9b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new token with the specified type, value, and length. This will attempt to get one from the recyling bin, and, if the recycling bin is empty, will allocate a new token using calloc and set its type to point to the specified type. The returned token will indicate that it is not a template token, and its reference count will be 0.  <br /></td></tr>
<tr class="separator:a4616dad8eeb4cbe04a4f9697d3de9b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2f9c98968a10bf4d37077fd363ac48" id="r_a8f2f9c98968a10bf4d37077fd363ac48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f2f9c98968a10bf4d37077fd363ac48">_lf_get_token</a> (<a class="el" href="../../de/d6b/structtoken__template__t.html">token_template_t</a> *tmplt)</td></tr>
<tr class="separator:a8f2f9c98968a10bf4d37077fd363ac48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1a2996844350bc1e29de47e3b56644" id="r_a5d1a2996844350bc1e29de47e3b56644"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d1a2996844350bc1e29de47e3b56644">_lf_initialize_template</a> (<a class="el" href="../../de/d6b/structtoken__template__t.html">token_template_t</a> *tmplt, size_t element_size)</td></tr>
<tr class="separator:a5d1a2996844350bc1e29de47e3b56644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac171b72d59f37653f012d30cad72a2d2" id="r_ac171b72d59f37653f012d30cad72a2d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac171b72d59f37653f012d30cad72a2d2">_lf_initialize_token_with_value</a> (<a class="el" href="../../de/d6b/structtoken__template__t.html">token_template_t</a> *tmplt, void *value, size_t length)</td></tr>
<tr class="separator:ac171b72d59f37653f012d30cad72a2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2c7940f2e59f5ff57807df6b41f5fe" id="r_a6e2c7940f2e59f5ff57807df6b41f5fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e2c7940f2e59f5ff57807df6b41f5fe">_lf_initialize_token</a> (<a class="el" href="../../de/d6b/structtoken__template__t.html">token_template_t</a> *tmplt, size_t length)</td></tr>
<tr class="separator:a6e2c7940f2e59f5ff57807df6b41f5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd97c46ee623b1ae34a70088ee9b5020" id="r_afd97c46ee623b1ae34a70088ee9b5020"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd97c46ee623b1ae34a70088ee9b5020">_lf_free_all_tokens</a> ()</td></tr>
<tr class="memdesc:afd97c46ee623b1ae34a70088ee9b5020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all tokens. Free tokens on the _lf_token_recycling_bin hashset and all template tokens.  <br /></td></tr>
<tr class="separator:afd97c46ee623b1ae34a70088ee9b5020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeff98dcfb6b5715aac8e1438c5a6e77" id="r_abeff98dcfb6b5715aac8e1438c5a6e77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abeff98dcfb6b5715aac8e1438c5a6e77">_lf_replace_template_token</a> (<a class="el" href="../../de/d6b/structtoken__template__t.html">token_template_t</a> *tmplt, <a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> *newtoken)</td></tr>
<tr class="memdesc:abeff98dcfb6b5715aac8e1438c5a6e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the token in the specified template, if there is one, with a new one. If the new token is the same as the token in the template, then this does nothing. Otherwise, it frees the previous template token.  <br /></td></tr>
<tr class="separator:abeff98dcfb6b5715aac8e1438c5a6e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c890be1f8d45461a6985cbfe6faa99" id="r_a88c890be1f8d45461a6985cbfe6faa99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/dff/lf__token_8h.html#abe23a36a87d2f0c076da417eb0114c7e">token_freed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88c890be1f8d45461a6985cbfe6faa99">_lf_done_using</a> (<a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> *token)</td></tr>
<tr class="separator:a88c890be1f8d45461a6985cbfe6faa99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25677ab083c7ad55454bb901c8832e79" id="r_a25677ab083c7ad55454bb901c8832e79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25677ab083c7ad55454bb901c8832e79">_lf_free_token_copies</a> ()</td></tr>
<tr class="memdesc:a25677ab083c7ad55454bb901c8832e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free token copies made for mutable inputs. This function should be called at the beginning of each time step to avoid memory leaks.  <br /></td></tr>
<tr class="separator:a25677ab083c7ad55454bb901c8832e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6be7b923487565688714ab43ff747633" id="r_a6be7b923487565688714ab43ff747633"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6be7b923487565688714ab43ff747633">_lf_count_payload_allocations</a></td></tr>
<tr class="separator:a6be7b923487565688714ab43ff747633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4657205de7da8f0bf7b346985a983fc" id="r_af4657205de7da8f0bf7b346985a983fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4657205de7da8f0bf7b346985a983fc">_lf_count_token_allocations</a></td></tr>
<tr class="separator:af4657205de7da8f0bf7b346985a983fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functions supporting token types. See <a class="el" href="../../d2/dff/lf__token_8h.html" title="Definitions for token objects, reference-counted wrappers around dynamically-allocated messages.">lf_token.h</a> for docs. </p>
<dl class="section author"><dt>Author</dt><dd>Edward A. Lee (<a href="#" onclick="location.href='mai'+'lto:'+'eal'+'@b'+'erk'+'el'+'ey.'+'ed'+'u'; return false;">eal@b<span class="obfuscator">.nosp@m.</span>erke<span class="obfuscator">.nosp@m.</span>ley.e<span class="obfuscator">.nosp@m.</span>du</a>)<ul>
<li></li>
</ul>
</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>(c) 2020-2024, The University of California at Berkeley. License: <a href="https://github.com/lf-lang/reactor-c/blob/main/LICENSE.md">BSD 2-clause</a> </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad6be436dfb95ab914336870d340b207d" name="ad6be436dfb95ab914336870d340b207d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6be436dfb95ab914336870d340b207d">&#9670;&#160;</a></span>_LF_TOKEN_RECYCLING_BIN_SIZE_LIMIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _LF_TOKEN_RECYCLING_BIN_SIZE_LIMIT&#160;&#160;&#160;512</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>To allow a system to recover from burst of activity, the token recycling bin has a limited size. When it becomes full, token are freed using <a class="el" href="../../d6/df3/hashmap_8h.html#a3efbc6cc1cee65d1129402b3476becd9" title="Free all memory used by the given hashmap.">free()</a>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a88c890be1f8d45461a6985cbfe6faa99" name="a88c890be1f8d45461a6985cbfe6faa99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88c890be1f8d45461a6985cbfe6faa99">&#9670;&#160;</a></span>_lf_done_using()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/dff/lf__token_8h.html#abe23a36a87d2f0c076da417eb0114c7e">token_freed</a> _lf_done_using </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> *</td>          <td class="paramname"><span class="paramname"><em>token</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decrement the reference count of the specified token. If the reference count hits 0, free the memory for the value carried by the token, and, if the token is not also the template token of its trigger, free the token. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>Pointer to a token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOT_FREED if nothing was freed, VALUE_FREED if the value was freed, TOKEN_FREED if only the token was freed, and TOKEN_AND_VALUE_FREED if both the value and the token were freed. </dd></dl>

</div>
</div>
<a id="afd97c46ee623b1ae34a70088ee9b5020" name="afd97c46ee623b1ae34a70088ee9b5020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd97c46ee623b1ae34a70088ee9b5020">&#9670;&#160;</a></span>_lf_free_all_tokens()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_free_all_tokens </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free all tokens. Free tokens on the _lf_token_recycling_bin hashset and all template tokens. </p>

</div>
</div>
<a id="a2798a92c59a1d46b602298cdbd187ab1" name="a2798a92c59a1d46b602298cdbd187ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2798a92c59a1d46b602298cdbd187ab1">&#9670;&#160;</a></span>_lf_free_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/dff/lf__token_8h.html#abe23a36a87d2f0c076da417eb0114c7e">token_freed</a> _lf_free_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> *</td>          <td class="paramname"><span class="paramname"><em>token</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the specified token, if appropriate. If the reference count is greater than 0, then do not free anything. Otherwise, the token value (payload) will be freed, if there is one. Then the token itself will be freed. The freed token will be put on the recycling bin unless that bin has reached the designated capacity, in which case <a class="el" href="../../d6/df3/hashmap_8h.html#a3efbc6cc1cee65d1129402b3476becd9" title="Free all memory used by the given hashmap.">free()</a> will be used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>Pointer to a token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOT_FREED if nothing was freed, VALUE_FREED if the value was freed, TOKEN_FREED if only the token was freed, and TOKEN_AND_VALUE_FREED if both the value and the token were freed. </dd></dl>

</div>
</div>
<a id="a25677ab083c7ad55454bb901c8832e79" name="a25677ab083c7ad55454bb901c8832e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25677ab083c7ad55454bb901c8832e79">&#9670;&#160;</a></span>_lf_free_token_copies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_free_token_copies </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free token copies made for mutable inputs. This function should be called at the beginning of each time step to avoid memory leaks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>Environment in which we are executing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f2f9c98968a10bf4d37077fd363ac48" name="a8f2f9c98968a10bf4d37077fd363ac48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2f9c98968a10bf4d37077fd363ac48">&#9670;&#160;</a></span>_lf_get_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> * _lf_get_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d6b/structtoken__template__t.html">token_template_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tmplt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a token for the specified template. If the template already has a token and the reference count is 1, then return that token. Otherwise, create a new token, make it the new template, and dissociate or free the previous template token. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmplt</td><td>The template. // template is a C++ keyword. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new or recycled <a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> struct. </dd></dl>

</div>
</div>
<a id="a5d1a2996844350bc1e29de47e3b56644" name="a5d1a2996844350bc1e29de47e3b56644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1a2996844350bc1e29de47e3b56644">&#9670;&#160;</a></span>_lf_initialize_template()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_initialize_template </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d6b/structtoken__template__t.html">token_template_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tmplt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>element_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the specified template to contain a token that is an array with the specified element size. If the template already has a token with a reference count greater than 1 or a non-matching type, it will be replaced and that token will be freed. The length of the returned token will be 0, its value will be NULL, and its reference count will be 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmplt</td><td>The template. // template is a C++ keyword. </td></tr>
    <tr><td class="paramname">element_size</td><td>The element size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e2c7940f2e59f5ff57807df6b41f5fe" name="a6e2c7940f2e59f5ff57807df6b41f5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2c7940f2e59f5ff57807df6b41f5fe">&#9670;&#160;</a></span>_lf_initialize_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> * _lf_initialize_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d6b/structtoken__template__t.html">token_template_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tmplt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a token for storing an array of the specified length with new memory allocated (using calloc, so initialize to zero) for storing that array. If the template's token is available (it is non-null and its reference count is 1), then reuse it. Otherwise, create a new token and replace the template token with the new one, freeing the previous token from its template association. The element_size for elements of the array is specified by the specified template. The caller should populate the value and ref_count field of the returned token after this returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmplt</td><td>The token template (must not be NULL). // template is a C++ keyword. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the array, or 1 if it is not an array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either the template's token or a new one, in each case with a value field pointing to newly allocated memory. </dd></dl>

</div>
</div>
<a id="ac171b72d59f37653f012d30cad72a2d2" name="ac171b72d59f37653f012d30cad72a2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac171b72d59f37653f012d30cad72a2d2">&#9670;&#160;</a></span>_lf_initialize_token_with_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> * _lf_initialize_token_with_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d6b/structtoken__template__t.html">token_template_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tmplt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a token storing the specified value, which is assumed to be either a scalar (if length is 1) or an array of the specified length. If the token in the specified template is available (it non-null and its reference count is 1), then return it. Otherwise, create a new token and replace the template token with the new one, freeing the previous token from its template association. The element_size for elements of the array is specified by the specified template.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmplt</td><td>A template for the token. // template is a C++ keyword. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the array. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the array, or 1 if it is not an array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either the specified token or a new one, in each case with a value field pointing to newly allocated memory. </dd></dl>

</div>
</div>
<a id="a4616dad8eeb4cbe04a4f9697d3de9b16" name="a4616dad8eeb4cbe04a4f9697d3de9b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4616dad8eeb4cbe04a4f9697d3de9b16">&#9670;&#160;</a></span>_lf_new_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> * _lf_new_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../db/d12/structtoken__type__t.html">token_type_t</a> *</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new token with the specified type, value, and length. This will attempt to get one from the recyling bin, and, if the recycling bin is empty, will allocate a new token using calloc and set its type to point to the specified type. The returned token will indicate that it is not a template token, and its reference count will be 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the token. </td></tr>
    <tr><td class="paramname">value</td><td>The value, or NULL to have no value. </td></tr>
    <tr><td class="paramname">length</td><td>The array length of the value, 1 to not be an array, or 0 to have no value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lf_token_t* </dd></dl>

</div>
</div>
<a id="abeff98dcfb6b5715aac8e1438c5a6e77" name="abeff98dcfb6b5715aac8e1438c5a6e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeff98dcfb6b5715aac8e1438c5a6e77">&#9670;&#160;</a></span>_lf_replace_template_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_replace_template_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/d6b/structtoken__template__t.html">token_template_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tmplt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> *</td>          <td class="paramname"><span class="paramname"><em>newtoken</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the token in the specified template, if there is one, with a new one. If the new token is the same as the token in the template, then this does nothing. Otherwise, it frees the previous template token. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmplt</td><td>Pointer to a template. // template is a C++ keyword. </td></tr>
    <tr><td class="paramname">newtoken</td><td>The replacement token. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa47b51a11727eec252ff7e786794bd88" name="aa47b51a11727eec252ff7e786794bd88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47b51a11727eec252ff7e786794bd88">&#9670;&#160;</a></span>lf_new_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> * lf_new_token </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>port_or_action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a new disassociated token with type matching the specified port or action and containing the specified value and length. The value is assumed to point to dynamically allocated memory that will be automatically freed. The length is 1 unless the type of the port is an array, in which case the value points to an array of the specified length. The token must then be sent to the port using <code>lf_set_token</code> or scheduled with the action using <code>lf_schedule_token</code>. The token can also be safely sent to any other port or scheduled with any other action that has the same type. If it is not scheduled or sent, then it is up to the user to free the memory allocated for the token and its value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_or_action</td><td>A port or action. </td></tr>
    <tr><td class="paramname">val</td><td>The value. </td></tr>
    <tr><td class="paramname">len</td><td>The length, or 1 if it not an array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> struct. </dd></dl>

</div>
</div>
<a id="aaf8e6f18b021d0b8ece7e1b64280432f" name="aaf8e6f18b021d0b8ece7e1b64280432f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8e6f18b021d0b8ece7e1b64280432f">&#9670;&#160;</a></span>lf_writable_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/d80/structlf__token__t.html">lf_token_t</a> * lf_writable_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/de8/structlf__port__base__t.html">lf_port_base_t</a> *</td>          <td class="paramname"><span class="paramname"><em>port</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a writable copy of the token in the specified template. If the reference count is 1, this returns the template's token rather than a copy. The reference count will be 1. Otherwise, if the size of the token payload is zero, this also returns the original token, again with reference count of 1. Otherwise, this returns a new token with a reference count of 1. The new token is added to a list of tokens whose reference counts will be decremented at the start of the next tag. If the template has no token (it has a primitive type), then there is no need for a writable copy. Return NULL. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>An input port, cast to (lf_port_base_t*). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a writable copy of the token, or NULL if the type is primitive. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a6be7b923487565688714ab43ff747633" name="a6be7b923487565688714ab43ff747633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6be7b923487565688714ab43ff747633">&#9670;&#160;</a></span>_lf_count_payload_allocations</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _lf_count_payload_allocations</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Counter used to issue a warning if memory is allocated for message payloads and never freed. </p>

</div>
</div>
<a id="af4657205de7da8f0bf7b346985a983fc" name="af4657205de7da8f0bf7b346985a983fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4657205de7da8f0bf7b346985a983fc">&#9670;&#160;</a></span>_lf_count_token_allocations</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _lf_count_token_allocations</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Counter used to issue a warning if memory is allocated for tokens and never freed. Note that every trigger will have one token allocated for it. That token is not counted because it is not expected to be freed. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../dir_4270bfced15e0e73154b13468c7c9ad9.html">core</a></li><li class="navelem"><a class="el" href="../../d4/d37/lf__token_8c.html">lf_token.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
