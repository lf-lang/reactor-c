<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>reactor-c: API for Reactions</title>
<link rel="icon" href="favicon.ico" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">reactor-c<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">C Runtime for Lingua Franca</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__API.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">API for Reactions </div></div>
</div><!--header-->
<div class="contents">

<p>API for use in inline reaction bodies.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-files" class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:logging_2Eh" id="r_logging_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="logging_8h.html">logging.h</a></td></tr>
<tr class="memdesc:logging_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logging API for the C target of Lingua Franca. <br /></td></tr>
<tr class="memitem:port_2Eh" id="r_port_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="port_8h.html">port.h</a></td></tr>
<tr class="memdesc:port_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support for optimizing sparse input through multiports. <br /></td></tr>
<tr class="memitem:reaction_5Fmacros_2Eh" id="r_reaction_5Fmacros_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reaction__macros_8h.html">reaction_macros.h</a></td></tr>
<tr class="memdesc:reaction__macros_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macros providing an API for use in inline reaction bodies. <br /></td></tr>
<tr class="memitem:reactor_2Eh" id="r_reactor_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor_8h.html">reactor.h</a></td></tr>
<tr class="memdesc:reactor_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for the C target of Lingua Franca shared by threaded and unthreaded versions. <br /></td></tr>
<tr class="memitem:schedule_2Eh" id="r_schedule_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="schedule_8h.html">schedule.h</a></td></tr>
<tr class="memdesc:schedule_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">API functions for scheduling actions. <br /></td></tr>
<tr class="memitem:tag_2Eh" id="r_tag_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tag_8h.html">tag.h</a></td></tr>
<tr class="memdesc:tag_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time and tag definitions and functions for Lingua Franca. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:lf_5Fmultiport_5Fiterator_5Ft" id="r_lf_5Fmultiport_5Fiterator_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlf__multiport__iterator__t.html">lf_multiport_iterator_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator over a record of the subset of channels of a multiport that have present inputs.  <a href="structlf__multiport__iterator__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:lf_5Ftoken_5Ft" id="r_lf_5Ftoken_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlf__token__t.html">lf_token_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Token type for dynamically allocated arrays and structs sent as messages.  <a href="structlf__token__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:tag_5Ft" id="r_tag_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtag__t.html">tag_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tag is a time, microstep pair.  <a href="structtag__t.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaabb3bc387f7a50f8cc57319f82c17c31" id="r_gaabb3bc387f7a50f8cc57319f82c17c31"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaabb3bc387f7a50f8cc57319f82c17c31">CHECK_TIMEOUT</a>(start,  <a class="el" href="reactor__common_8h.html#a8079fdfadf07cba8a660c9c25cb9dc77">duration</a>)</td></tr>
<tr class="memdesc:gaabb3bc387f7a50f8cc57319f82c17c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression that is true if physical time since start exceeds the duration.  <br /></td></tr>
<tr class="memitem:ga26ab6a0fd21cdcff11a5557406536bf1" id="r_ga26ab6a0fd21cdcff11a5557406536bf1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga26ab6a0fd21cdcff11a5557406536bf1">LF_ASSERT</a>(condition,  format, ...)</td></tr>
<tr class="memdesc:ga26ab6a0fd21cdcff11a5557406536bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert that a condition is true.  <br /></td></tr>
<tr class="memitem:ga832d0deaa853b7777e1f54283e7bcc20" id="r_ga832d0deaa853b7777e1f54283e7bcc20"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga832d0deaa853b7777e1f54283e7bcc20">LF_ASSERT_NON_NULL</a>(pointer)</td></tr>
<tr class="memdesc:ga832d0deaa853b7777e1f54283e7bcc20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert that a pointer is not NULL.  <br /></td></tr>
<tr class="memitem:ga1c464cee8cabb65eebf454fc016d47b1" id="r_ga1c464cee8cabb65eebf454fc016d47b1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1c464cee8cabb65eebf454fc016d47b1">LF_ASSERTN</a>(condition,  format, ...)</td></tr>
<tr class="memdesc:ga1c464cee8cabb65eebf454fc016d47b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assert that a condition is false.  <br /></td></tr>
<tr class="memitem:ga5759266c62b989a6b305584cb72f8840" id="r_ga5759266c62b989a6b305584cb72f8840"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5759266c62b989a6b305584cb72f8840">lf_multiport_iterator</a>(in)</td></tr>
<tr class="memdesc:ga5759266c62b989a6b305584cb72f8840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for creating an iterator over an input multiport.  <br /></td></tr>
<tr class="memitem:gab5a65df50027549a8245f6b3eaff97e4" id="r_gab5a65df50027549a8245f6b3eaff97e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab5a65df50027549a8245f6b3eaff97e4">LF_PRINT_DEBUG</a>(format, ...)</td></tr>
<tr class="memdesc:gab5a65df50027549a8245f6b3eaff97e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A macro used to print useful debug information.  <br /></td></tr>
<tr class="memitem:ga2a7110df48e8f74b05fd4a8f7581b1da" id="r_ga2a7110df48e8f74b05fd4a8f7581b1da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2a7110df48e8f74b05fd4a8f7581b1da">LF_PRINT_LOG</a>(format, ...)</td></tr>
<tr class="memdesc:ga2a7110df48e8f74b05fd4a8f7581b1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">A macro used to print useful logging information.  <br /></td></tr>
<tr class="memitem:ga78918b87982fba15b59f35a8f926b021" id="r_ga78918b87982fba15b59f35a8f926b021"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga78918b87982fba15b59f35a8f926b021">lf_reactor_full_name</a>(reactor)</td></tr>
<tr class="memdesc:ga78918b87982fba15b59f35a8f926b021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the fully qualified name of the reactor.  <br /></td></tr>
<tr class="memitem:ga42c6f935901d6fc56d6e82be619a8bd3" id="r_ga42c6f935901d6fc56d6e82be619a8bd3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga42c6f935901d6fc56d6e82be619a8bd3">lf_reactor_name</a>(reactor)</td></tr>
<tr class="memdesc:ga42c6f935901d6fc56d6e82be619a8bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the instance name of the reactor.  <br /></td></tr>
<tr class="memitem:gaef602f51d34bbd214643161e425d909d" id="r_gaef602f51d34bbd214643161e425d909d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaef602f51d34bbd214643161e425d909d">lf_set</a>(out,  val)</td></tr>
<tr class="memdesc:gaef602f51d34bbd214643161e425d909d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the specified output (or input of a contained reactor) to the specified value.  <br /></td></tr>
<tr class="memitem:ga8a3a63e70ec63e35d46573293ecec905" id="r_ga8a3a63e70ec63e35d46573293ecec905"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8a3a63e70ec63e35d46573293ecec905">lf_set_array</a>(out,  val,  len)</td></tr>
<tr class="memdesc:ga8a3a63e70ec63e35d46573293ecec905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the specified output (or input of a contained reactor) to the specified array with the given length.  <br /></td></tr>
<tr class="memitem:gaa515ab9df816c6ac8a450def4dc02f40" id="r_gaa515ab9df816c6ac8a450def4dc02f40"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa515ab9df816c6ac8a450def4dc02f40">lf_set_copy_constructor</a>(out,  cpy_ctor)</td></tr>
<tr class="memdesc:gaa515ab9df816c6ac8a450def4dc02f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the copy constructor associated with the specified port.  <br /></td></tr>
<tr class="memitem:gaf4b2874af3da2bb85edfb3f0a57028a1" id="r_gaf4b2874af3da2bb85edfb3f0a57028a1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf4b2874af3da2bb85edfb3f0a57028a1">lf_set_destructor</a>(out,  dtor)</td></tr>
<tr class="memdesc:gaf4b2874af3da2bb85edfb3f0a57028a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the destructor associated with the specified port.  <br /></td></tr>
<tr class="memitem:ga0120cc579143c138482e89186e180ebc" id="r_ga0120cc579143c138482e89186e180ebc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0120cc579143c138482e89186e180ebc">lf_set_mode</a>(mode)</td></tr>
<tr class="memdesc:ga0120cc579143c138482e89186e180ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the next mode of a modal reactor.  <br /></td></tr>
<tr class="memitem:ga5c1e2963a361057f0b249b95f40a8f8d" id="r_ga5c1e2963a361057f0b249b95f40a8f8d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5c1e2963a361057f0b249b95f40a8f8d">lf_set_present</a>(out)</td></tr>
<tr class="memdesc:ga5c1e2963a361057f0b249b95f40a8f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a port present.  <br /></td></tr>
<tr class="memitem:ga1aa76760517d7100306d59b92fd41a26" id="r_ga1aa76760517d7100306d59b92fd41a26"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1aa76760517d7100306d59b92fd41a26">lf_set_token</a>(out,  newtoken)</td></tr>
<tr class="memdesc:ga1aa76760517d7100306d59b92fd41a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the specified output (or input of a contained reactor) to the specified token value.  <br /></td></tr>
<tr class="memitem:ga3e66ec583172bbad678982af8c57001b" id="r_ga3e66ec583172bbad678982af8c57001b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3e66ec583172bbad678982af8c57001b">LF_SPARSE_CAPACITY_DIVIDER</a>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:ga3e66ec583172bbad678982af8c57001b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide LF_SPARSE_WIDTH_THRESHOLD by this number to get the capacity of a sparse input record for a multiport.  <br /></td></tr>
<tr class="memitem:gaafcc3f0b909a44166db182035ca759c6" id="r_gaafcc3f0b909a44166db182035ca759c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaafcc3f0b909a44166db182035ca759c6">LF_SPARSE_WIDTH_THRESHOLD</a>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:gaafcc3f0b909a44166db182035ca759c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threshold for width of multiport s.t.  <br /></td></tr>
<tr class="memitem:ga2d81456725407157f9dc521a5e14a679" id="r_ga2d81456725407157f9dc521a5e14a679"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2d81456725407157f9dc521a5e14a679">lf_tag</a>()</td></tr>
<tr class="memdesc:ga2d81456725407157f9dc521a5e14a679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current tag of the environment invoking this reaction.  <br /></td></tr>
<tr class="memitem:gacc2b8ac5ac3020137e71dfcdbaedf335" id="r_gacc2b8ac5ac3020137e71dfcdbaedf335"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacc2b8ac5ac3020137e71dfcdbaedf335">LF_TIME_BUFFER_LENGTH</a>&#160;&#160;&#160;64</td></tr>
<tr class="memdesc:gacc2b8ac5ac3020137e71dfcdbaedf335"><td class="mdescLeft">&#160;</td><td class="mdescRight">For user-friendly reporting of time values, the buffer length required.  <br /></td></tr>
<tr class="memitem:ga4fe4453dda4223671dc90fa1ecbcac85" id="r_ga4fe4453dda4223671dc90fa1ecbcac85"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4fe4453dda4223671dc90fa1ecbcac85">lf_time_logical</a>()</td></tr>
<tr class="memdesc:ga4fe4453dda4223671dc90fa1ecbcac85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current logical time in nanoseconds of the environment invoking this reaction.  <br /></td></tr>
<tr class="memitem:ga7aaaed76bc1ae823bb13d6603807f874" id="r_ga7aaaed76bc1ae823bb13d6603807f874"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7aaaed76bc1ae823bb13d6603807f874">lf_time_logical_elapsed</a>()</td></tr>
<tr class="memdesc:ga7aaaed76bc1ae823bb13d6603807f874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current logical time of the environment invoking this reaction relative to the start time in nanoseconds.  <br /></td></tr>
<tr class="memitem:ga18226173309d6c2ae828080dad0859cf" id="r_ga18226173309d6c2ae828080dad0859cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga18226173309d6c2ae828080dad0859cf">LOG_LEVEL_ALL</a>&#160;&#160;&#160;255</td></tr>
<tr class="memdesc:ga18226173309d6c2ae828080dad0859cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">All log levels.  <br /></td></tr>
<tr class="memitem:ga130224df8c6bf22a688e3cb74a45689a" id="r_ga130224df8c6bf22a688e3cb74a45689a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga130224df8c6bf22a688e3cb74a45689a">LOG_LEVEL_DEBUG</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:ga130224df8c6bf22a688e3cb74a45689a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug log level.  <br /></td></tr>
<tr class="memitem:ga742fc70e331d7e568bd893c514756a29" id="r_ga742fc70e331d7e568bd893c514756a29"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga742fc70e331d7e568bd893c514756a29">LOG_LEVEL_ERROR</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga742fc70e331d7e568bd893c514756a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error log level, which is the lowest log level.  <br /></td></tr>
<tr class="memitem:ga2e25fe130cf710da4ad800747fdd51f3" id="r_ga2e25fe130cf710da4ad800747fdd51f3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2e25fe130cf710da4ad800747fdd51f3">LOG_LEVEL_INFO</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ga2e25fe130cf710da4ad800747fdd51f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Warning log level.  <br /></td></tr>
<tr class="memitem:ga8b58cabecd61bfd1b706be9cb992e0bd" id="r_ga8b58cabecd61bfd1b706be9cb992e0bd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8b58cabecd61bfd1b706be9cb992e0bd">LOG_LEVEL_LOG</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:ga8b58cabecd61bfd1b706be9cb992e0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log log level.  <br /></td></tr>
<tr class="memitem:gaf539a66abed2a7a15e3443d70a3cf1e1" id="r_gaf539a66abed2a7a15e3443d70a3cf1e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf539a66abed2a7a15e3443d70a3cf1e1">LOG_LEVEL_WARNING</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gaf539a66abed2a7a15e3443d70a3cf1e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Warning log level.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga827080fd3c574bad5a32db9f7c367587" id="r_ga827080fd3c574bad5a32db9f7c367587"><td class="memItemLeft" align="right" valign="top">typedef int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga827080fd3c574bad5a32db9f7c367587">instant_t</a></td></tr>
<tr class="memdesc:ga827080fd3c574bad5a32db9f7c367587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time instant.  <br /></td></tr>
<tr class="memitem:gaf5b4e62d03782997d813be6145316f4b" id="r_gaf5b4e62d03782997d813be6145316f4b"><td class="memItemLeft" align="right" valign="top">typedef int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf5b4e62d03782997d813be6145316f4b">interval_t</a></td></tr>
<tr class="memdesc:gaf5b4e62d03782997d813be6145316f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interval of time.  <br /></td></tr>
<tr class="memitem:gaf8a81a7373f3d5f77fd865e437964ef3" id="r_gaf8a81a7373f3d5f77fd865e437964ef3"><td class="memItemLeft" align="right" valign="top">typedef struct lf_multiport_iterator_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf8a81a7373f3d5f77fd865e437964ef3">lf_multiport_iterator_t</a></td></tr>
<tr class="memdesc:gaf8a81a7373f3d5f77fd865e437964ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator over a record of the subset of channels of a multiport that have present inputs.  <br /></td></tr>
<tr class="memitem:ga973e404c4c1bd798a54501d0e1d640f9" id="r_ga973e404c4c1bd798a54501d0e1d640f9"><td class="memItemLeft" align="right" valign="top">typedef struct lf_token_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga973e404c4c1bd798a54501d0e1d640f9">lf_token_t</a></td></tr>
<tr class="memdesc:ga973e404c4c1bd798a54501d0e1d640f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Token type for dynamically allocated arrays and structs sent as messages.  <br /></td></tr>
<tr class="memitem:gad88f1caa8b9c216404eb196cb1850213" id="r_gad88f1caa8b9c216404eb196cb1850213"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad88f1caa8b9c216404eb196cb1850213">microstep_t</a></td></tr>
<tr class="memdesc:gad88f1caa8b9c216404eb196cb1850213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Microstep.  <br /></td></tr>
<tr class="memitem:gadc4e09bf2433b9e06b632880ce81b897" id="r_gadc4e09bf2433b9e06b632880ce81b897"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadc4e09bf2433b9e06b632880ce81b897">print_message_function_t</a>(const char *, va_list)</td></tr>
<tr class="memdesc:gadc4e09bf2433b9e06b632880ce81b897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message print function type.  <br /></td></tr>
<tr class="memitem:ga4505c08c065b48840a30eedd9845cce2" id="r_ga4505c08c065b48840a30eedd9845cce2"><td class="memItemLeft" align="right" valign="top">typedef char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4505c08c065b48840a30eedd9845cce2">string</a></td></tr>
<tr class="memdesc:ga4505c08c065b48840a30eedd9845cce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">String type so that we don't have to use {= char* =}.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab3a04dd0a1581844829b28686b6b3c53" id="r_gab3a04dd0a1581844829b28686b6b3c53"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab3a04dd0a1581844829b28686b6b3c53">lf_check_deadline</a> (void *self, bool invoke_deadline_handler)</td></tr>
<tr class="memdesc:gab3a04dd0a1581844829b28686b6b3c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the deadline of the currently executing reaction against the current physical time.  <br /></td></tr>
<tr class="memitem:gae956f1688a3893b44cf4bced3c13ef9a" id="r_gae956f1688a3893b44cf4bced3c13ef9a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae956f1688a3893b44cf4bced3c13ef9a">lf_comma_separated_time</a> (char *buffer, <a class="el" href="#ga827080fd3c574bad5a32db9f7c367587">instant_t</a> time)</td></tr>
<tr class="memdesc:gae956f1688a3893b44cf4bced3c13ef9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a non-negative time value in nanoseconds with commas separating thousands into the specified buffer.  <br /></td></tr>
<tr class="memitem:gaf7feb89416e60e458d6a86cadadbc41d" id="r_gaf7feb89416e60e458d6a86cadadbc41d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf7feb89416e60e458d6a86cadadbc41d">lf_delay_tag</a> (<a class="el" href="structtag__t.html">tag_t</a> tag, <a class="el" href="#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> interval)</td></tr>
<tr class="memdesc:gaf7feb89416e60e458d6a86cadadbc41d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay a tag by the specified time interval to realize the "after" keyword.  <br /></td></tr>
<tr class="memitem:gaf4bdd144e6cc65dfa3b996d4bd82f83a" id="r_gaf4bdd144e6cc65dfa3b996d4bd82f83a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf4bdd144e6cc65dfa3b996d4bd82f83a">lf_is_tag_after_stop_tag</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env, <a class="el" href="structtag__t.html">tag_t</a> tag)</td></tr>
<tr class="memdesc:gaf4bdd144e6cc65dfa3b996d4bd82f83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the provided tag is after stop tag.  <br /></td></tr>
<tr class="memitem:gac7c743d3c64a839642e54781b8e9127f" id="r_gac7c743d3c64a839642e54781b8e9127f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac7c743d3c64a839642e54781b8e9127f">lf_multiport_next</a> (<a class="el" href="structlf__multiport__iterator__t.html">lf_multiport_iterator_t</a> *iterator)</td></tr>
<tr class="memdesc:gac7c743d3c64a839642e54781b8e9127f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the channel number of the next present input on the multiport or -1 if there are no more present channels.  <br /></td></tr>
<tr class="memitem:gaa47b51a11727eec252ff7e786794bd88" id="r_gaa47b51a11727eec252ff7e786794bd88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa47b51a11727eec252ff7e786794bd88">lf_new_token</a> (void *port_or_action, void *val, size_t len)</td></tr>
<tr class="memdesc:gaa47b51a11727eec252ff7e786794bd88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new disassociated token with type matching the specified port or action and containing the specified value and length.  <br /></td></tr>
<tr class="memitem:ga9d83e586b29a3316dd7dc505e30e6858" id="r_ga9d83e586b29a3316dd7dc505e30e6858"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9d83e586b29a3316dd7dc505e30e6858">lf_print</a> (const char *format,...) ATTRIBUTE_FORMAT_PRINTF(1</td></tr>
<tr class="memdesc:ga9d83e586b29a3316dd7dc505e30e6858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report an informational message on stdout with a newline appended at the end.  <br /></td></tr>
<tr class="memitem:ga22ebee89c962ac34cc1fa7b9762b77d2" id="r_ga22ebee89c962ac34cc1fa7b9762b77d2"><td class="memItemLeft" align="right" valign="top">void void void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga22ebee89c962ac34cc1fa7b9762b77d2">lf_print_debug</a> (const char *format,...) ATTRIBUTE_FORMAT_PRINTF(1</td></tr>
<tr class="memdesc:ga22ebee89c962ac34cc1fa7b9762b77d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report an debug message on stdout with the prefix "DEBUG: " and a newline appended at the end.  <br /></td></tr>
<tr class="memitem:gae0a6bd6b164c5cc3e9928f5375dd1a97" id="r_gae0a6bd6b164c5cc3e9928f5375dd1a97"><td class="memItemLeft" align="right" valign="top">void void void void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae0a6bd6b164c5cc3e9928f5375dd1a97">lf_print_error</a> (const char *format,...) ATTRIBUTE_FORMAT_PRINTF(1</td></tr>
<tr class="memdesc:gae0a6bd6b164c5cc3e9928f5375dd1a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report an error with the prefix "ERROR: " and a newline appended at the end.  <br /></td></tr>
<tr class="memitem:gabf2630e80adfec45b8b4a2782a0767a7" id="r_gabf2630e80adfec45b8b4a2782a0767a7"><td class="memItemLeft" align="right" valign="top">void void void void void void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabf2630e80adfec45b8b4a2782a0767a7">lf_print_error_and_exit</a> (const char *format,...) ATTRIBUTE_FORMAT_PRINTF(1</td></tr>
<tr class="memdesc:gabf2630e80adfec45b8b4a2782a0767a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report an error with the prefix "ERROR: " and a newline appended at the end, then exit with the failure code EXIT_FAILURE.  <br /></td></tr>
<tr class="memitem:gacbc9741875a95bb30e1a8d68cfb7cf06" id="r_gacbc9741875a95bb30e1a8d68cfb7cf06"><td class="memItemLeft" align="right" valign="top">void void void void void void void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacbc9741875a95bb30e1a8d68cfb7cf06">lf_print_error_system_failure</a> (const char *format,...)</td></tr>
<tr class="memdesc:gacbc9741875a95bb30e1a8d68cfb7cf06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report an error and exit just like <a class="el" href="#gabf2630e80adfec45b8b4a2782a0767a7" title="Report an error with the prefix &quot;ERROR: &quot; and a newline appended at the end, then exit with the failu...">lf_print_error_and_exit()</a>, but also print the system error message associated with the error.  <br /></td></tr>
<tr class="memitem:gab202dc9383567eaa8d9ae7240c939c19" id="r_gab202dc9383567eaa8d9ae7240c939c19"><td class="memItemLeft" align="right" valign="top">void void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab202dc9383567eaa8d9ae7240c939c19">lf_print_log</a> (const char *format,...) ATTRIBUTE_FORMAT_PRINTF(1</td></tr>
<tr class="memdesc:gab202dc9383567eaa8d9ae7240c939c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report an log message on stdout with the prefix "LOG: " and a newline appended at the end.  <br /></td></tr>
<tr class="memitem:ga613bc8d331e3fd9a3f78eb1600092e1d" id="r_ga613bc8d331e3fd9a3f78eb1600092e1d"><td class="memItemLeft" align="right" valign="top">void void void void void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga613bc8d331e3fd9a3f78eb1600092e1d">lf_print_warning</a> (const char *format,...) ATTRIBUTE_FORMAT_PRINTF(1</td></tr>
<tr class="memdesc:ga613bc8d331e3fd9a3f78eb1600092e1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report a warning with the prefix "WARNING: " and a newline appended at the end.  <br /></td></tr>
<tr class="memitem:gab5bf112c4237da16d08736ff3e3e36b8" id="r_gab5bf112c4237da16d08736ff3e3e36b8"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab5bf112c4237da16d08736ff3e3e36b8">lf_reactor_full_name</a> (<a class="el" href="structself__base__t.html">self_base_t</a> *self)</td></tr>
<tr class="memdesc:gab5bf112c4237da16d08736ff3e3e36b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the full name of the reactor.  <br /></td></tr>
<tr class="memitem:gae76171d83c29dadd3adb3f9294a92138" id="r_gae76171d83c29dadd3adb3f9294a92138"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae76171d83c29dadd3adb3f9294a92138">lf_reactor_name</a> (<a class="el" href="structself__base__t.html">self_base_t</a> *self)</td></tr>
<tr class="memdesc:gae76171d83c29dadd3adb3f9294a92138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the instance name of the reactor.  <br /></td></tr>
<tr class="memitem:ga43509483b3e9886acd002c7d7b6482c8" id="r_ga43509483b3e9886acd002c7d7b6482c8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga43509483b3e9886acd002c7d7b6482c8">lf_readable_time</a> (char *buffer, <a class="el" href="#ga827080fd3c574bad5a32db9f7c367587">instant_t</a> time)</td></tr>
<tr class="memdesc:ga43509483b3e9886acd002c7d7b6482c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store into the specified buffer a string giving a human-readable rendition of the specified time.  <br /></td></tr>
<tr class="memitem:ga6ad22ca79136cd15dc0d560aec067f76" id="r_ga6ad22ca79136cd15dc0d560aec067f76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6ad22ca79136cd15dc0d560aec067f76">lf_register_print_function</a> (<a class="el" href="#gadc4e09bf2433b9e06b632880ce81b897">print_message_function_t</a> *function, int log_level)</td></tr>
<tr class="memdesc:ga6ad22ca79136cd15dc0d560aec067f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a function to display messages.  <br /></td></tr>
<tr class="memitem:gab49affc958f705d9e33c5e3463848bda" id="r_gab49affc958f705d9e33c5e3463848bda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab49affc958f705d9e33c5e3463848bda">lf_request_stop</a> (void)</td></tr>
<tr class="memdesc:gab49affc958f705d9e33c5e3463848bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a stop to execution as soon as possible.  <br /></td></tr>
<tr class="memitem:ga6778eef97447cf0ba1f0afa8ba3a8dca" id="r_ga6778eef97447cf0ba1f0afa8ba3a8dca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Internal.html#ga3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6778eef97447cf0ba1f0afa8ba3a8dca">lf_schedule</a> (void *action, <a class="el" href="#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> offset)</td></tr>
<tr class="memdesc:ga6778eef97447cf0ba1f0afa8ba3a8dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an action to occur with the specified time offset with no payload (no value conveyed).  <br /></td></tr>
<tr class="memitem:ga747594e2d7264ae8b044a095eb92ba27" id="r_ga747594e2d7264ae8b044a095eb92ba27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Internal.html#ga3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga747594e2d7264ae8b044a095eb92ba27">lf_schedule_copy</a> (void *action, <a class="el" href="#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> offset, void *value, size_t length)</td></tr>
<tr class="memdesc:ga747594e2d7264ae8b044a095eb92ba27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an action to occur with the specified value and time offset with a copy of the specified value.  <br /></td></tr>
<tr class="memitem:ga073ea4406a084a24e71b65936ba39e36" id="r_ga073ea4406a084a24e71b65936ba39e36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Internal.html#ga3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga073ea4406a084a24e71b65936ba39e36">lf_schedule_int</a> (void *action, <a class="el" href="#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> extra_delay, int value)</td></tr>
<tr class="memdesc:ga073ea4406a084a24e71b65936ba39e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule the specified action with an integer value at a later logical time.  <br /></td></tr>
<tr class="memitem:gabe3fd30bf6a2689fdb3ec03b4e2f47d1" id="r_gabe3fd30bf6a2689fdb3ec03b4e2f47d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Internal.html#ga3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabe3fd30bf6a2689fdb3ec03b4e2f47d1">lf_schedule_token</a> (void *action, <a class="el" href="#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> extra_delay, <a class="el" href="structlf__token__t.html">lf_token_t</a> *token)</td></tr>
<tr class="memdesc:gabe3fd30bf6a2689fdb3ec03b4e2f47d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule the specified action at a later tag with the specified token as a payload.  <br /></td></tr>
<tr class="memitem:ga986bb1be3a9e4f71e5b5dde30d9dc6ad" id="r_ga986bb1be3a9e4f71e5b5dde30d9dc6ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__Internal.html#ga3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga986bb1be3a9e4f71e5b5dde30d9dc6ad">lf_schedule_value</a> (void *action, <a class="el" href="#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> extra_delay, void *value, int length)</td></tr>
<tr class="memdesc:ga986bb1be3a9e4f71e5b5dde30d9dc6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of lf_schedule_token that creates a token to carry the specified value.  <br /></td></tr>
<tr class="memitem:gadaa6f5f1a265e7a37aeb3b6a0d101732" id="r_gadaa6f5f1a265e7a37aeb3b6a0d101732"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadaa6f5f1a265e7a37aeb3b6a0d101732">lf_set_present</a> (<a class="el" href="structlf__port__base__t.html">lf_port_base_t</a> *port)</td></tr>
<tr class="memdesc:gadaa6f5f1a265e7a37aeb3b6a0d101732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the given port's is_present field as true.  <br /></td></tr>
<tr class="memitem:gacbe5117469b98e0e6df45b5421f58026" id="r_gacbe5117469b98e0e6df45b5421f58026"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacbe5117469b98e0e6df45b5421f58026">lf_tag</a> (void *env)</td></tr>
<tr class="memdesc:gacbe5117469b98e0e6df45b5421f58026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current tag, a logical time, microstep pair.  <br /></td></tr>
<tr class="memitem:gaa1186f7e330ecbfd20a4dd90b97439e6" id="r_gaa1186f7e330ecbfd20a4dd90b97439e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa1186f7e330ecbfd20a4dd90b97439e6">lf_tag_add</a> (<a class="el" href="structtag__t.html">tag_t</a> a, <a class="el" href="structtag__t.html">tag_t</a> b)</td></tr>
<tr class="memdesc:gaa1186f7e330ecbfd20a4dd90b97439e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two tags.  <br /></td></tr>
<tr class="memitem:ga596d8734432616c9c7847283fde63cfa" id="r_ga596d8734432616c9c7847283fde63cfa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga596d8734432616c9c7847283fde63cfa">lf_tag_compare</a> (<a class="el" href="structtag__t.html">tag_t</a> tag1, <a class="el" href="structtag__t.html">tag_t</a> tag2)</td></tr>
<tr class="memdesc:ga596d8734432616c9c7847283fde63cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two tags.  <br /></td></tr>
<tr class="memitem:ga1789de56286aa33c086b194b544c2d91" id="r_ga1789de56286aa33c086b194b544c2d91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga827080fd3c574bad5a32db9f7c367587">instant_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1789de56286aa33c086b194b544c2d91">lf_time_add</a> (<a class="el" href="#ga827080fd3c574bad5a32db9f7c367587">instant_t</a> a, <a class="el" href="#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> b)</td></tr>
<tr class="memdesc:ga1789de56286aa33c086b194b544c2d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of an interval and an instant, saturating on overflow and underflow.  <br /></td></tr>
<tr class="memitem:ga7538766a655ba2e60ddde55f2e020e58" id="r_ga7538766a655ba2e60ddde55f2e020e58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga827080fd3c574bad5a32db9f7c367587">instant_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7538766a655ba2e60ddde55f2e020e58">lf_time_physical</a> (void)</td></tr>
<tr class="memdesc:ga7538766a655ba2e60ddde55f2e020e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current physical time in nanoseconds.  <br /></td></tr>
<tr class="memitem:ga98468f1c5132e3aa18d77f85d65bb6ec" id="r_ga98468f1c5132e3aa18d77f85d65bb6ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga827080fd3c574bad5a32db9f7c367587">instant_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga98468f1c5132e3aa18d77f85d65bb6ec">lf_time_physical_elapsed</a> (void)</td></tr>
<tr class="memdesc:ga98468f1c5132e3aa18d77f85d65bb6ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elapsed physical time in nanoseconds.  <br /></td></tr>
<tr class="memitem:ga8da2172c41ab13ff4748994a62ae34b5" id="r_ga8da2172c41ab13ff4748994a62ae34b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga827080fd3c574bad5a32db9f7c367587">instant_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8da2172c41ab13ff4748994a62ae34b5">lf_time_start</a> (void)</td></tr>
<tr class="memdesc:ga8da2172c41ab13ff4748994a62ae34b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the physical and logical time of the start of execution in nanoseconds.  <br /></td></tr>
<tr class="memitem:ga9107f7f62874fa972f7a31f9c277b8fc" id="r_ga9107f7f62874fa972f7a31f9c277b8fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga827080fd3c574bad5a32db9f7c367587">instant_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9107f7f62874fa972f7a31f9c277b8fc">lf_time_subtract</a> (<a class="el" href="#ga827080fd3c574bad5a32db9f7c367587">instant_t</a> a, <a class="el" href="#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> b)</td></tr>
<tr class="memdesc:ga9107f7f62874fa972f7a31f9c277b8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an instant minus an interval, saturating on overflow and underflow.  <br /></td></tr>
<tr class="memitem:ga82bf2c7bd91fdf03b357914cf875dbb9" id="r_ga82bf2c7bd91fdf03b357914cf875dbb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga82bf2c7bd91fdf03b357914cf875dbb9">lf_watchdog_start</a> (<a class="el" href="structwatchdog__t.html">watchdog_t</a> *watchdog, <a class="el" href="#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> additional_timeout)</td></tr>
<tr class="memdesc:ga82bf2c7bd91fdf03b357914cf875dbb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start or restart the watchdog timer.  <br /></td></tr>
<tr class="memitem:gaa27ad22f94bbdaa33b99fe6cd81f1bdc" id="r_gaa27ad22f94bbdaa33b99fe6cd81f1bdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa27ad22f94bbdaa33b99fe6cd81f1bdc">lf_watchdog_stop</a> (<a class="el" href="structwatchdog__t.html">watchdog_t</a> *watchdog)</td></tr>
<tr class="memdesc:gaa27ad22f94bbdaa33b99fe6cd81f1bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the specified watchdog without invoking the expiration handler.  <br /></td></tr>
<tr class="memitem:gaaf8e6f18b021d0b8ece7e1b64280432f" id="r_gaaf8e6f18b021d0b8ece7e1b64280432f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaf8e6f18b021d0b8ece7e1b64280432f">lf_writable_copy</a> (<a class="el" href="structlf__port__base__t.html">lf_port_base_t</a> *port)</td></tr>
<tr class="memdesc:gaaf8e6f18b021d0b8ece7e1b64280432f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable copy of the token in the specified template.  <br /></td></tr>
<tr class="memitem:gae6078a659280c57ae1c4dfe939f319e7" id="r_gae6078a659280c57ae1c4dfe939f319e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae6078a659280c57ae1c4dfe939f319e7">register_user_trace_event</a> (void *self, char *description)</td></tr>
<tr class="memdesc:gae6078a659280c57ae1c4dfe939f319e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a user trace event.  <br /></td></tr>
<tr class="memitem:gacd97e049ba442bdd90f020c0b7c1a4fa" id="r_gacd97e049ba442bdd90f020c0b7c1a4fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacd97e049ba442bdd90f020c0b7c1a4fa">tracepoint_user_event</a> (void *self, char *description)</td></tr>
<tr class="memdesc:gacd97e049ba442bdd90f020c0b7c1a4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace a user-defined event.  <br /></td></tr>
<tr class="memitem:ga064170081cf3de9c123b58bdc51b1d4f" id="r_ga064170081cf3de9c123b58bdc51b1d4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga064170081cf3de9c123b58bdc51b1d4f">tracepoint_user_value</a> (void *self, char *description, long long value)</td></tr>
<tr class="memdesc:ga064170081cf3de9c123b58bdc51b1d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace a user-defined event with a value.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<p>API for use in inline reaction bodies. </p>
<p>These macros and functions are automatically available in any reaction body that is inlined inside the <span class="tt">.lf</span> file; there is no need to add any <span class="tt">#include</span>.</p>
<dl class="section note"><dt>Note</dt><dd>For reactions that are defined in ordinary C files instead of inline in the <span class="tt">.lf</span> file, (see <a href="http://lf-lang.org/docs/next/writing-reactors/reaction-declarations">Reaction Declarations</a>), you may need to use a function directly instead of a macro. The corresponding very likely takes an <span class="tt">environment</span> argument. The self struct struct has an <span class="tt">environment</span> field, so you can pass as the argument <span class="tt">self-&gt;environment</span>. </dd></dl>
<a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="gaabb3bc387f7a50f8cc57319f82c17c31" name="gaabb3bc387f7a50f8cc57319f82c17c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabb3bc387f7a50f8cc57319f82c17c31">&#9670;&#160;</a></span>CHECK_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_TIMEOUT</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em><a class="el" href="reactor__common_8h.html#a8079fdfadf07cba8a660c9c25cb9dc77">duration</a></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tag_8h.html">/Users/runner/work/reactor-c/reactor-c/tag/api/tag.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">(<a class="code hl_function" href="#ga7538766a655ba2e60ddde55f2e020e58">lf_time_physical</a>() &gt; ((start) + (<a class="code hl_variable" href="reactor__common_8h.html#a8079fdfadf07cba8a660c9c25cb9dc77">duration</a>)))</div>
<div class="ttc" id="agroup__API_html_ga7538766a655ba2e60ddde55f2e020e58"><div class="ttname"><a href="#ga7538766a655ba2e60ddde55f2e020e58">lf_time_physical</a></div><div class="ttdeci">instant_t lf_time_physical(void)</div><div class="ttdoc">Return the current physical time in nanoseconds.</div></div>
<div class="ttc" id="areactor__common_8h_html_a8079fdfadf07cba8a660c9c25cb9dc77"><div class="ttname"><a href="reactor__common_8h.html#a8079fdfadf07cba8a660c9c25cb9dc77">duration</a></div><div class="ttdeci">instant_t duration</div></div>
</div><!-- fragment -->
<p>Expression that is true if physical time since start exceeds the duration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The start time. </td></tr>
    <tr><td class="paramname">duration</td><td>The duration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga26ab6a0fd21cdcff11a5557406536bf1" name="ga26ab6a0fd21cdcff11a5557406536bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26ab6a0fd21cdcff11a5557406536bf1">&#9670;&#160;</a></span>LF_ASSERT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LF_ASSERT</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em></em></span>...&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="logging__macros_8h.html">/Users/runner/work/reactor-c/reactor-c/logging/api/logging_macros.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                                                                 \</div>
<div class="line">    if (!(condition)) {                                                                                                \</div>
<div class="line">      lf_print_error_and_exit(<span class="stringliteral">&quot;`&quot;</span> format <span class="stringliteral">&quot;`. Failed assertion in %s:%d(%s):(&quot;</span> #condition <span class="stringliteral">&quot;) != true`&quot;</span>, ##__VA_ARGS__,  \</div>
<div class="line">                              __FILE__, __LINE__, __func__);                                                           \</div>
<div class="line">    }                                                                                                                  \</div>
<div class="line">  } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
<p>Assert that a condition is true. </p>
<p>This will verify that the condition is true and call <a class="el" href="#gabf2630e80adfec45b8b4a2782a0767a7">lf_print_error_and_exit</a> if it is not true. The remaining arguments are passed to <a class="el" href="#gabf2630e80adfec45b8b4a2782a0767a7">lf_print_error_and_exit</a> as the format string and arguments.</p>
<p>This is optimized to execute the condition argument but not check the result if the NDEBUG flag is defined. The NDEBUG flag will be defined if the user specifies <span class="tt">build-type: Release</span> in the target properties of the LF program.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">condition</td><td>The condition to verify. </td></tr>
    <tr><td class="paramname">format</td><td>The format string to pass to <a class="el" href="#gabf2630e80adfec45b8b4a2782a0767a7">lf_print_error_and_exit</a>. </td></tr>
    <tr><td class="paramname">...</td><td>The arguments to pass to <a class="el" href="#gabf2630e80adfec45b8b4a2782a0767a7">lf_print_error_and_exit</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga832d0deaa853b7777e1f54283e7bcc20" name="ga832d0deaa853b7777e1f54283e7bcc20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga832d0deaa853b7777e1f54283e7bcc20">&#9670;&#160;</a></span>LF_ASSERT_NON_NULL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LF_ASSERT_NON_NULL</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>pointer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="logging__macros_8h.html">/Users/runner/work/reactor-c/reactor-c/logging/api/logging_macros.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                                                                 \</div>
<div class="line">    if (!(pointer)) {                                                                                                  \</div>
<div class="line">      lf_print_error_and_exit(<span class="stringliteral">&quot;`Out of memory?` Assertion failed in %s:%d(%s):`&quot;</span> #pointer <span class="stringliteral">&quot; == NULL`&quot;</span>, __FILE__,       \</div>
<div class="line">                              __LINE__, __func__);                                                                     \</div>
<div class="line">    }                                                                                                                  \</div>
<div class="line">  } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
<p>Assert that a pointer is not NULL. </p>
<p>This will verify that the pointer is non-NULL and call <a class="el" href="#gabf2630e80adfec45b8b4a2782a0767a7">lf_print_error_and_exit</a> if it is NULL.</p>
<p>This differs from <a class="el" href="#ga26ab6a0fd21cdcff11a5557406536bf1">LF_ASSERT</a> in that it does nothing at all if the NDEBUG flag is defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer</td><td>The pointer to verify. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1c464cee8cabb65eebf454fc016d47b1" name="ga1c464cee8cabb65eebf454fc016d47b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c464cee8cabb65eebf454fc016d47b1">&#9670;&#160;</a></span>LF_ASSERTN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LF_ASSERTN</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>condition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em></em></span>...&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="logging__macros_8h.html">/Users/runner/work/reactor-c/reactor-c/logging/api/logging_macros.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                                                                 \</div>
<div class="line">    if (condition) {                                                                                                   \</div>
<div class="line">      lf_print_error_and_exit(<span class="stringliteral">&quot;`&quot;</span> format <span class="stringliteral">&quot;`. Failed assertion in %s:%d(%s):(&quot;</span> #condition <span class="stringliteral">&quot;) != false`&quot;</span>, ##__VA_ARGS__, \</div>
<div class="line">                              __FILE__, __LINE__, __func__);                                                           \</div>
<div class="line">    }                                                                                                                  \</div>
<div class="line">  } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
<p>Assert that a condition is false. </p>
<p>This will verify that the condition is false and call <a class="el" href="#gabf2630e80adfec45b8b4a2782a0767a7">lf_print_error_and_exit</a> if it is not false. The remaining arguments are passed to <a class="el" href="#gabf2630e80adfec45b8b4a2782a0767a7">lf_print_error_and_exit</a> as the format string and arguments.</p>
<p>This is optimized to execute the condition argument but not check the result if the NDEBUG flag is defined. The NDEBUG flag will be defined if the user specifies <span class="tt">build-type: Release</span> in the target properties of the LF program.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">condition</td><td>The condition to verify. </td></tr>
    <tr><td class="paramname">format</td><td>The format string to pass to <a class="el" href="#gabf2630e80adfec45b8b4a2782a0767a7">lf_print_error_and_exit</a>. </td></tr>
    <tr><td class="paramname">...</td><td>The arguments to pass to <a class="el" href="#gabf2630e80adfec45b8b4a2782a0767a7">lf_print_error_and_exit</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5759266c62b989a6b305584cb72f8840" name="ga5759266c62b989a6b305584cb72f8840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5759266c62b989a6b305584cb72f8840">&#9670;&#160;</a></span>lf_multiport_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lf_multiport_iterator</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>in</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="port_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/port.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">  (<a class="code hl_function" href="group__Internal.html#ga23e88870b9a699d1a067ff5b397e0887">_lf_multiport_iterator_impl</a>((<a class="code hl_struct" href="structlf__port__base__t.html">lf_port_base_t</a>**)self-&gt;_lf_##in, self-&gt;_lf_##in##_width))</div>
<div class="ttc" id="agroup__Internal_html_ga23e88870b9a699d1a067ff5b397e0887"><div class="ttname"><a href="group__Internal.html#ga23e88870b9a699d1a067ff5b397e0887">_lf_multiport_iterator_impl</a></div><div class="ttdeci">lf_multiport_iterator_t _lf_multiport_iterator_impl(lf_port_base_t **port, int width)</div><div class="ttdoc">Given an array of pointers to port structs, return an iterator that can be used to iterate over the p...</div></div>
<div class="ttc" id="astructlf__port__base__t_html"><div class="ttname"><a href="structlf__port__base__t.html">lf_port_base_t</a></div><div class="ttdoc">Base type for ports.</div><div class="ttdef"><b>Definition</b> lf_token.h:202</div></div>
</div><!-- fragment -->
<p>Macro for creating an iterator over an input multiport. </p>
<p>The argument is the port name. This returns an instance of <a class="el" href="structlf__multiport__iterator__t.html">lf_multiport_iterator_t</a> on the stack, a pointer to which should be passed to <a class="el" href="#gac7c743d3c64a839642e54781b8e9127f">lf_multiport_next()</a> to advance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The port name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab5a65df50027549a8245f6b3eaff97e4" name="gab5a65df50027549a8245f6b3eaff97e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5a65df50027549a8245f6b3eaff97e4">&#9670;&#160;</a></span>LF_PRINT_DEBUG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LF_PRINT_DEBUG</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em></em></span>...&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="logging__macros_8h.html">/Users/runner/work/reactor-c/reactor-c/logging/api/logging_macros.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                                                                 \</div>
<div class="line">    if (<a class="code hl_variable" href="logging__macros_8h.html#aa5842514c55365877642c5df9fd3dd70">_lf_log_level_is_debug</a>) {                                                                                      \</div>
<div class="line">      lf_print_debug(format, ##__VA_ARGS__);                                                                           \</div>
<div class="line">    }                                                                                                                  \</div>
<div class="line">  } <span class="keywordflow">while</span> (0)</div>
<div class="ttc" id="alogging__macros_8h_html_aa5842514c55365877642c5df9fd3dd70"><div class="ttname"><a href="logging__macros_8h.html#aa5842514c55365877642c5df9fd3dd70">_lf_log_level_is_debug</a></div><div class="ttdeci">static const bool _lf_log_level_is_debug</div><div class="ttdef"><b>Definition</b> logging_macros.h:24</div></div>
</div><!-- fragment -->
<p>A macro used to print useful debug information. </p>
<p>In contrast to the function <a class="el" href="#ga22ebee89c962ac34cc1fa7b9762b77d2">lf_print_debug</a>, this macro avoids the overhead if logging is disabled.</p>
<p>It can be enabled by setting the target property 'logging' to 'DEBUG' or by defining LOG_LEVEL to LOG_LEVEL_DEBUG in the top-level preamble. The input to this macro is exactly like printf: (format, ...). "DEBUG: " is prepended to the beginning of the message and a newline is appended to the end of the message.</p>
<dl class="section note"><dt>Note</dt><dd>This macro is non-empty even if LOG_LEVEL is not defined in user-code. This is to ensure that the compiler will still parse the predicate inside (...) to prevent LF_PRINT_DEBUG statements to fall out of sync with the rest of the code. This should have a negligible impact on performance if compiler optimization (e.g., -O2 for gcc) is used as long as the arguments passed to it do not themselves incur significant overhead to evaluate. </dd></dl>

</div>
</div>
<a id="ga2a7110df48e8f74b05fd4a8f7581b1da" name="ga2a7110df48e8f74b05fd4a8f7581b1da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a7110df48e8f74b05fd4a8f7581b1da">&#9670;&#160;</a></span>LF_PRINT_LOG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LF_PRINT_LOG</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em></em></span>...&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="logging__macros_8h.html">/Users/runner/work/reactor-c/reactor-c/logging/api/logging_macros.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                                                                 \</div>
<div class="line">    if (<a class="code hl_variable" href="logging__macros_8h.html#abaede48cb5679264413d3cc86ed251bf">_lf_log_level_is_log</a>) {                                                                                        \</div>
<div class="line">      lf_print_log(format, ##__VA_ARGS__);                                                                             \</div>
<div class="line">    }                                                                                                                  \</div>
<div class="line">  } <span class="keywordflow">while</span> (0)</div>
<div class="ttc" id="alogging__macros_8h_html_abaede48cb5679264413d3cc86ed251bf"><div class="ttname"><a href="logging__macros_8h.html#abaede48cb5679264413d3cc86ed251bf">_lf_log_level_is_log</a></div><div class="ttdeci">static const bool _lf_log_level_is_log</div><div class="ttdef"><b>Definition</b> logging_macros.h:23</div></div>
</div><!-- fragment -->
<p>A macro used to print useful logging information. </p>
<p>In contrast to the function <a class="el" href="#gab202dc9383567eaa8d9ae7240c939c19">lf_print_log</a>, this macro avoids the overhead if logging is disabled.</p>
<p>It can be enabled by setting the target property 'logging' to 'LOG' or by defining LOG_LEVEL to LOG_LEVEL_LOG or LOG_LEVEL_DEBUG in the top-level preamble. The input to this macro is exactly like printf: (format, ...). "LOG: " is prepended to the beginning of the message and a newline is appended to the end of the message.</p>
<dl class="section note"><dt>Note</dt><dd>This macro is non-empty even if LOG_LEVEL is not defined in user-code. This is to ensure that the compiler will still parse the predicate inside (...) to prevent LF_PRINT_LOG statements to fall out of sync with the rest of the code. This should have a negligible impact on performance if compiler optimization (e.g., -O2 for gcc) is used as long as the arguments passed to it do not themselves incur significant overhead to evaluate. </dd></dl>

</div>
</div>
<a id="ga78918b87982fba15b59f35a8f926b021" name="ga78918b87982fba15b59f35a8f926b021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78918b87982fba15b59f35a8f926b021">&#9670;&#160;</a></span>lf_reactor_full_name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lf_reactor_full_name</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>reactor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reaction__macros_8h.html">/Users/runner/work/reactor-c/reactor-c/include/api/reaction_macros.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="#ga78918b87982fba15b59f35a8f926b021">lf_reactor_full_name</a>(&amp;reactor-&gt;base)</div>
<div class="ttc" id="agroup__API_html_ga78918b87982fba15b59f35a8f926b021"><div class="ttname"><a href="#ga78918b87982fba15b59f35a8f926b021">lf_reactor_full_name</a></div><div class="ttdeci">#define lf_reactor_full_name(reactor)</div><div class="ttdoc">Return the fully qualified name of the reactor.</div><div class="ttdef"><b>Definition</b> reaction_macros.h:234</div></div>
</div><!-- fragment -->
<p>Return the fully qualified name of the reactor. </p>
<p>The fully qualified name of a reactor is the instance name of the reactor concatenated with the names of all of its parents, separated by dots. If the reactor or any of its parents is a bank, then the name will have a suffix of the form <span class="tt">[bank_index]</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reactor</td><td>The reactor to get the name of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga42c6f935901d6fc56d6e82be619a8bd3" name="ga42c6f935901d6fc56d6e82be619a8bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42c6f935901d6fc56d6e82be619a8bd3">&#9670;&#160;</a></span>lf_reactor_name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lf_reactor_name</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>reactor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reaction__macros_8h.html">/Users/runner/work/reactor-c/reactor-c/include/api/reaction_macros.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="#ga42c6f935901d6fc56d6e82be619a8bd3">lf_reactor_name</a>(&amp;reactor-&gt;base)</div>
<div class="ttc" id="agroup__API_html_ga42c6f935901d6fc56d6e82be619a8bd3"><div class="ttname"><a href="#ga42c6f935901d6fc56d6e82be619a8bd3">lf_reactor_name</a></div><div class="ttdeci">#define lf_reactor_name(reactor)</div><div class="ttdoc">Return the instance name of the reactor.</div><div class="ttdef"><b>Definition</b> reaction_macros.h:222</div></div>
</div><!-- fragment -->
<p>Return the instance name of the reactor. </p>
<p>The instance name is the name of given to the instance created by the <span class="tt">new</span> operator in LF. If the instance is in a bank, then the name will have a suffix of the form <span class="tt">[bank_index]</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reactor</td><td>The reactor to get the name of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaef602f51d34bbd214643161e425d909d" name="gaef602f51d34bbd214643161e425d909d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef602f51d34bbd214643161e425d909d">&#9670;&#160;</a></span>lf_set</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lf_set</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reaction__macros_8h.html">/Users/runner/work/reactor-c/reactor-c/include/api/reaction_macros.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                                                                 \</div>
<div class="line">    out-&gt;value = val;                                                                                                  \</div>
<div class="line">    lf_set_present(out);                                                                                               \</div>
<div class="line">    if (((<a class="code hl_struct" href="structtoken__template__t.html">token_template_t</a>*)out)-&gt;token != NULL) {                                                                     \</div>
<div class="line">      <span class="comment">/* The cast &quot;*((void**) &amp;out-&gt;value)&quot; is a hack to make the code */</span>                                              \</div>
<div class="line">      <span class="comment">/* compile with non-token types where value is not a pointer. */</span>                                                 \</div>
<div class="line">      <a class="code hl_struct" href="structlf__token__t.html">lf_token_t</a>* token = <a class="code hl_function" href="group__Internal.html#gac171b72d59f37653f012d30cad72a2d2">_lf_initialize_token_with_value</a>((<a class="code hl_struct" href="structtoken__template__t.html">token_template_t</a>*)out, *((<span class="keywordtype">void</span>**)&amp;out-&gt;value), 1);          \</div>
<div class="line">      out-&gt;<a class="code hl_variable" href="structtoken__template__t.html#a076f845b64482f5cf083da333bfc60de">token</a> = token;                                                                                              \</div>
<div class="line">    }                                                                                                                  \</div>
<div class="line">  } <span class="keywordflow">while</span> (0)</div>
<div class="ttc" id="agroup__Internal_html_gac171b72d59f37653f012d30cad72a2d2"><div class="ttname"><a href="group__Internal.html#gac171b72d59f37653f012d30cad72a2d2">_lf_initialize_token_with_value</a></div><div class="ttdeci">lf_token_t * _lf_initialize_token_with_value(token_template_t *tmplt, void *value, size_t length)</div><div class="ttdoc">Return a token storing the specified value, which is assumed to be either a scalar (if length is 1) o...</div></div>
<div class="ttc" id="astructlf__token__t_html"><div class="ttname"><a href="structlf__token__t.html">lf_token_t</a></div><div class="ttdoc">Token type for dynamically allocated arrays and structs sent as messages.</div><div class="ttdef"><b>Definition</b> lf_token.h:99</div></div>
<div class="ttc" id="astructtoken__template__t_html"><div class="ttname"><a href="structtoken__template__t.html">token_template_t</a></div><div class="ttdoc">Base type for ports (lf_port_base_t) and actions (trigger_t), which can carry tokens.</div><div class="ttdef"><b>Definition</b> lf_token.h:156</div></div>
<div class="ttc" id="astructtoken__template__t_html_a076f845b64482f5cf083da333bfc60de"><div class="ttname"><a href="structtoken__template__t.html#a076f845b64482f5cf083da333bfc60de">token_template_t::token</a></div><div class="ttdeci">lf_token_t * token</div><div class="ttdoc">Pointer to the current token.</div><div class="ttdef"><b>Definition</b> lf_token.h:174</div></div>
</div><!-- fragment -->
<p>Set the specified output (or input of a contained reactor) to the specified value. </p>
<p>If the value argument is a primitive type such as int, double, etc. as well as the built-in types bool and string, the value is copied and therefore the variable carrying the value can be subsequently modified without changing the output. This also applies to structs with a type defined by a typedef so that the type designating string does not end in '*'.</p>
<p>If the value argument is a pointer to memory that the calling reaction has dynamically allocated, the memory will be automatically freed once all downstream reactions no longer need the value. If 'lf_set_destructor' is called on 'out', then that destructor will be used to free 'value'. Otherwise, the default void free(void*) function is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output port (by name) or input of a contained reactor in form input_name.port_name. </td></tr>
    <tr><td class="paramname">val</td><td>The value to insert into the self struct. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8a3a63e70ec63e35d46573293ecec905" name="ga8a3a63e70ec63e35d46573293ecec905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a3a63e70ec63e35d46573293ecec905">&#9670;&#160;</a></span>lf_set_array</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lf_set_array</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reaction__macros_8h.html">/Users/runner/work/reactor-c/reactor-c/include/api/reaction_macros.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                                                                 \</div>
<div class="line">    lf_set_present(out);                                                                                               \</div>
<div class="line">    <a class="code hl_struct" href="structlf__token__t.html">lf_token_t</a>* token = <a class="code hl_function" href="group__Internal.html#gac171b72d59f37653f012d30cad72a2d2">_lf_initialize_token_with_value</a>((<a class="code hl_struct" href="structtoken__template__t.html">token_template_t</a>*)out, val, len);                             \</div>
<div class="line">    out-&gt;token = token;                                                                                                \</div>
<div class="line">    out-&gt;<a class="code hl_variable" href="structlf__token__t.html#a96f790f8f8dcc01474dbc255e05ceaa8">value</a> = token-&gt;<a class="code hl_variable" href="structlf__token__t.html#a96f790f8f8dcc01474dbc255e05ceaa8">value</a>;                                                                                         \</div>
<div class="line">    out-&gt;length = len;                                                                                                 \</div>
<div class="line">  } <span class="keywordflow">while</span> (0)</div>
<div class="ttc" id="astructlf__token__t_html_a96f790f8f8dcc01474dbc255e05ceaa8"><div class="ttname"><a href="structlf__token__t.html#a96f790f8f8dcc01474dbc255e05ceaa8">lf_token_t::value</a></div><div class="ttdeci">void * value</div><div class="ttdoc">Pointer to dynamically allocated memory containing a message.</div><div class="ttdef"><b>Definition</b> lf_token.h:101</div></div>
</div><!-- fragment -->
<p>Set the specified output (or input of a contained reactor) to the specified array with the given length. </p>
<p>The array is assumed to be in dynamically allocated memory. The deallocation is delegated to downstream reactors, which automatically deallocate when the reference count drops to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output port (by name). </td></tr>
    <tr><td class="paramname">val</td><td>The array to send (a pointer to the first element). </td></tr>
    <tr><td class="paramname">len</td><td>The length of the array to send. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa515ab9df816c6ac8a450def4dc02f40" name="gaa515ab9df816c6ac8a450def4dc02f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa515ab9df816c6ac8a450def4dc02f40">&#9670;&#160;</a></span>lf_set_copy_constructor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lf_set_copy_constructor</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>cpy_ctor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reaction__macros_8h.html">/Users/runner/work/reactor-c/reactor-c/include/api/reaction_macros.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">((<a class="code hl_struct" href="structtoken__type__t.html">token_type_t</a>*)out)-&gt;copy_constructor = cpy_ctor</div>
<div class="ttc" id="astructtoken__type__t_html"><div class="ttname"><a href="structtoken__type__t.html">token_type_t</a></div><div class="ttdoc">Type information for tokens.</div><div class="ttdef"><b>Definition</b> lf_token.h:71</div></div>
</div><!-- fragment -->
<p>Set the copy constructor associated with the specified port. </p>
<p>The copy constructor will be used to copy any value sent through the specified port whenever a downstream user of the value declares a mutable input port or calls <span class="tt"><a class="el" href="#gaaf8e6f18b021d0b8ece7e1b64280432f" title="Return a writable copy of the token in the specified template.">lf_writable_copy()</a></span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output port (by name) or input of a contained reactor in form reactor.port_name. </td></tr>
    <tr><td class="paramname">cpy_ctor</td><td>A pointer to a void function that takes a pointer argument (or NULL to use the default void <span class="tt">memcpy()</span> function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf4b2874af3da2bb85edfb3f0a57028a1" name="gaf4b2874af3da2bb85edfb3f0a57028a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4b2874af3da2bb85edfb3f0a57028a1">&#9670;&#160;</a></span>lf_set_destructor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lf_set_destructor</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>dtor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reaction__macros_8h.html">/Users/runner/work/reactor-c/reactor-c/include/api/reaction_macros.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">((<a class="code hl_struct" href="structtoken__type__t.html">token_type_t</a>*)out)-&gt;destructor = dtor</div>
</div><!-- fragment -->
<p>Set the destructor associated with the specified port. </p>
<p>The destructor will be used to free any value sent through the specified port when all downstream users of the value are finished with it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output port (by name) or input of a contained reactor in form reactor.port_name. </td></tr>
    <tr><td class="paramname">dtor</td><td>A pointer to a void function that takes a pointer argument (or NULL to use the default void free(void*) function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0120cc579143c138482e89186e180ebc" name="ga0120cc579143c138482e89186e180ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0120cc579143c138482e89186e180ebc">&#9670;&#160;</a></span>lf_set_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lf_set_mode</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reaction__macros_8h.html">/Users/runner/work/reactor-c/reactor-c/include/api/reaction_macros.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="group__Modal.html#gaa83c858bb273af532a903ba430b6b87e">_LF_SET_MODE_WITH_TYPE</a>(mode, _lf_##mode##_change_type)</div>
<div class="ttc" id="agroup__Modal_html_gaa83c858bb273af532a903ba430b6b87e"><div class="ttname"><a href="group__Modal.html#gaa83c858bb273af532a903ba430b6b87e">_LF_SET_MODE_WITH_TYPE</a></div><div class="ttdeci">#define _LF_SET_MODE_WITH_TYPE(mode, change_type)</div><div class="ttdoc">Set the next mode of a modal reactor with an explicit change type (reset or history,...</div><div class="ttdef"><b>Definition</b> modes.h:50</div></div>
</div><!-- fragment -->
<p>Set the next mode of a modal reactor. </p>
<p>As with <span class="tt">lf_set</span> for outputs, only the last value will have effect if invoked multiple times at any given tag. This works only in reactions with the target mode declared as effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The target mode to set for activation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5c1e2963a361057f0b249b95f40a8f8d" name="ga5c1e2963a361057f0b249b95f40a8f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c1e2963a361057f0b249b95f40a8f8d">&#9670;&#160;</a></span>lf_set_present</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lf_set_present</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reaction__macros_8h.html">/Users/runner/work/reactor-c/reactor-c/include/api/reaction_macros.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="#ga5c1e2963a361057f0b249b95f40a8f8d">lf_set_present</a>((<a class="code hl_struct" href="structlf__port__base__t.html">lf_port_base_t</a>*)out)</div>
<div class="ttc" id="agroup__API_html_ga5c1e2963a361057f0b249b95f40a8f8d"><div class="ttname"><a href="#ga5c1e2963a361057f0b249b95f40a8f8d">lf_set_present</a></div><div class="ttdeci">#define lf_set_present(out)</div><div class="ttdoc">Mark a port present.</div><div class="ttdef"><b>Definition</b> reaction_macros.h:48</div></div>
</div><!-- fragment -->
<p>Mark a port present. </p>
<p>This sets the is_present field of the specified output to true.</p>
<p>This macro is a thin wrapper around the <a class="el" href="#ga5c1e2963a361057f0b249b95f40a8f8d" title="Mark a port present.">lf_set_present()</a> function. It simply casts the argument to <span class="tt">lf_port_base_t*</span> to suppress warnings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output port (by name). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1aa76760517d7100306d59b92fd41a26" name="ga1aa76760517d7100306d59b92fd41a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1aa76760517d7100306d59b92fd41a26">&#9670;&#160;</a></span>lf_set_token</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lf_set_token</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>newtoken</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reaction__macros_8h.html">/Users/runner/work/reactor-c/reactor-c/include/api/reaction_macros.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                                                                 \</div>
<div class="line">    lf_set_present(out);                                                                                               \</div>
<div class="line">    _lf_replace_template_token((<a class="code hl_struct" href="structtoken__template__t.html">token_template_t</a>*)out, newtoken);                                                      \</div>
<div class="line">    out-&gt;value = newtoken-&gt;value;                                                                                      \</div>
<div class="line">    out-&gt;length = newtoken-&gt;length;                                                                                    \</div>
<div class="line">  } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
<p>Set the specified output (or input of a contained reactor) to the specified token value. </p>
<p>Tokens in the C runtime wrap messages that are in dynamically allocated memory and perform reference counting to ensure that memory is not freed prematurely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The output port (by name). </td></tr>
    <tr><td class="paramname">newtoken</td><td>A pointer to token obtained from an input, an action, or from <span class="tt"><a class="el" href="#gaa47b51a11727eec252ff7e786794bd88" title="Return a new disassociated token with type matching the specified port or action and containing the s...">lf_new_token()</a></span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3e66ec583172bbad678982af8c57001b" name="ga3e66ec583172bbad678982af8c57001b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e66ec583172bbad678982af8c57001b">&#9670;&#160;</a></span>LF_SPARSE_CAPACITY_DIVIDER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LF_SPARSE_CAPACITY_DIVIDER&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="port_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/port.h</a>&gt;</code></p>

<p>Divide LF_SPARSE_WIDTH_THRESHOLD by this number to get the capacity of a sparse input record for a multiport. </p>

</div>
</div>
<a id="gaafcc3f0b909a44166db182035ca759c6" name="gaafcc3f0b909a44166db182035ca759c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafcc3f0b909a44166db182035ca759c6">&#9670;&#160;</a></span>LF_SPARSE_WIDTH_THRESHOLD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LF_SPARSE_WIDTH_THRESHOLD&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="port_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/port.h</a>&gt;</code></p>

<p>Threshold for width of multiport s.t. </p>
<p>sparse reading is supported. </p>

</div>
</div>
<a id="ga2d81456725407157f9dc521a5e14a679" name="ga2d81456725407157f9dc521a5e14a679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d81456725407157f9dc521a5e14a679">&#9670;&#160;</a></span>lf_tag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lf_tag</td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reaction__macros_8h.html">/Users/runner/work/reactor-c/reactor-c/include/api/reaction_macros.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="#ga2d81456725407157f9dc521a5e14a679">lf_tag</a>(self-&gt;base.environment)</div>
<div class="ttc" id="agroup__API_html_ga2d81456725407157f9dc521a5e14a679"><div class="ttname"><a href="#ga2d81456725407157f9dc521a5e14a679">lf_tag</a></div><div class="ttdeci">#define lf_tag()</div><div class="ttdoc">Return the current tag of the environment invoking this reaction.</div><div class="ttdef"><b>Definition</b> reaction_macros.h:198</div></div>
</div><!-- fragment -->
<p>Return the current tag of the environment invoking this reaction. </p>

</div>
</div>
<a id="gacc2b8ac5ac3020137e71dfcdbaedf335" name="gacc2b8ac5ac3020137e71dfcdbaedf335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc2b8ac5ac3020137e71dfcdbaedf335">&#9670;&#160;</a></span>LF_TIME_BUFFER_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LF_TIME_BUFFER_LENGTH&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tag_8h.html">/Users/runner/work/reactor-c/reactor-c/tag/api/tag.h</a>&gt;</code></p>

<p>For user-friendly reporting of time values, the buffer length required. </p>
<p>This is calculated as follows, based on 64-bit time in nanoseconds: Maximum number of weeks is 15,250 Maximum number of days is 6 Maximum number of hours is 23 Maximum number of minutes is 59 Maximum number of seconds is 59 Maximum number of nanoseconds is 999,999,999 Maximum number of microsteps is 4,294,967,295 Total number of characters for the above is 24. Text descriptions and spaces add an additional 30, for a total of 54. One more allows for a null terminator. Round up to a power of two. </p>

</div>
</div>
<a id="ga4fe4453dda4223671dc90fa1ecbcac85" name="ga4fe4453dda4223671dc90fa1ecbcac85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fe4453dda4223671dc90fa1ecbcac85">&#9670;&#160;</a></span>lf_time_logical</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lf_time_logical</td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reaction__macros_8h.html">/Users/runner/work/reactor-c/reactor-c/include/api/reaction_macros.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="#ga4fe4453dda4223671dc90fa1ecbcac85">lf_time_logical</a>(self-&gt;base.environment)</div>
<div class="ttc" id="agroup__API_html_ga4fe4453dda4223671dc90fa1ecbcac85"><div class="ttname"><a href="#ga4fe4453dda4223671dc90fa1ecbcac85">lf_time_logical</a></div><div class="ttdeci">#define lf_time_logical()</div><div class="ttdoc">Return the current logical time in nanoseconds of the environment invoking this reaction.</div><div class="ttdef"><b>Definition</b> reaction_macros.h:204</div></div>
</div><!-- fragment -->
<p>Return the current logical time in nanoseconds of the environment invoking this reaction. </p>

</div>
</div>
<a id="ga7aaaed76bc1ae823bb13d6603807f874" name="ga7aaaed76bc1ae823bb13d6603807f874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7aaaed76bc1ae823bb13d6603807f874">&#9670;&#160;</a></span>lf_time_logical_elapsed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define lf_time_logical_elapsed</td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reaction__macros_8h.html">/Users/runner/work/reactor-c/reactor-c/include/api/reaction_macros.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="#ga7aaaed76bc1ae823bb13d6603807f874">lf_time_logical_elapsed</a>(self-&gt;base.environment)</div>
<div class="ttc" id="agroup__API_html_ga7aaaed76bc1ae823bb13d6603807f874"><div class="ttname"><a href="#ga7aaaed76bc1ae823bb13d6603807f874">lf_time_logical_elapsed</a></div><div class="ttdeci">#define lf_time_logical_elapsed()</div><div class="ttdoc">Return the current logical time of the environment invoking this reaction relative to the start time ...</div><div class="ttdef"><b>Definition</b> reaction_macros.h:211</div></div>
</div><!-- fragment -->
<p>Return the current logical time of the environment invoking this reaction relative to the start time in nanoseconds. </p>

</div>
</div>
<a id="ga18226173309d6c2ae828080dad0859cf" name="ga18226173309d6c2ae828080dad0859cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18226173309d6c2ae828080dad0859cf">&#9670;&#160;</a></span>LOG_LEVEL_ALL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_LEVEL_ALL&#160;&#160;&#160;255</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="logging_8h.html">/Users/runner/work/reactor-c/reactor-c/logging/api/logging.h</a>&gt;</code></p>

<p>All log levels. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga742fc70e331d7e568bd893c514756a29" title="Error log level, which is the lowest log level.">LOG_LEVEL_ERROR</a> </dd></dl>

</div>
</div>
<a id="ga130224df8c6bf22a688e3cb74a45689a" name="ga130224df8c6bf22a688e3cb74a45689a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga130224df8c6bf22a688e3cb74a45689a">&#9670;&#160;</a></span>LOG_LEVEL_DEBUG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_LEVEL_DEBUG&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="logging_8h.html">/Users/runner/work/reactor-c/reactor-c/logging/api/logging.h</a>&gt;</code></p>

<p>Debug log level. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga742fc70e331d7e568bd893c514756a29" title="Error log level, which is the lowest log level.">LOG_LEVEL_ERROR</a> </dd></dl>

</div>
</div>
<a id="ga742fc70e331d7e568bd893c514756a29" name="ga742fc70e331d7e568bd893c514756a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga742fc70e331d7e568bd893c514756a29">&#9670;&#160;</a></span>LOG_LEVEL_ERROR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_LEVEL_ERROR&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="logging_8h.html">/Users/runner/work/reactor-c/reactor-c/logging/api/logging.h</a>&gt;</code></p>

<p>Error log level, which is the lowest log level. </p>
<p>This is the lowest log level.</p>
<dl class="section note"><dt>Note</dt><dd>LOG_LEVEL is set in generated code to 0 through 4 if the target logging property is error, warning, info, log, or debug. The default level is info (2). Currently, 0, 1, and 2 are treated identically and lf_print_error, lf_print_warning, and lf_print LOG_LEVEL is set in generated code to 0 through 4 if the target logging property is error, warning, info, log, or debug. The default level is info (2). Currently, 0, 1, and 2 are treated identically and lf_print_error, lf_print_warning, and lf_print all result in printed output. If log is set (3), then <a class="el" href="#gab202dc9383567eaa8d9ae7240c939c19">lf_print_log</a> messages will be printed as well. If debug is set (4), the <a class="el" href="#ga22ebee89c962ac34cc1fa7b9762b77d2">lf_print_debug</a> messages will be printed as well. </dd></dl>

</div>
</div>
<a id="ga2e25fe130cf710da4ad800747fdd51f3" name="ga2e25fe130cf710da4ad800747fdd51f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e25fe130cf710da4ad800747fdd51f3">&#9670;&#160;</a></span>LOG_LEVEL_INFO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_LEVEL_INFO&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="logging_8h.html">/Users/runner/work/reactor-c/reactor-c/logging/api/logging.h</a>&gt;</code></p>

<p>Warning log level. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga742fc70e331d7e568bd893c514756a29" title="Error log level, which is the lowest log level.">LOG_LEVEL_ERROR</a> </dd></dl>

</div>
</div>
<a id="ga8b58cabecd61bfd1b706be9cb992e0bd" name="ga8b58cabecd61bfd1b706be9cb992e0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b58cabecd61bfd1b706be9cb992e0bd">&#9670;&#160;</a></span>LOG_LEVEL_LOG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_LEVEL_LOG&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="logging_8h.html">/Users/runner/work/reactor-c/reactor-c/logging/api/logging.h</a>&gt;</code></p>

<p>Log log level. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga742fc70e331d7e568bd893c514756a29" title="Error log level, which is the lowest log level.">LOG_LEVEL_ERROR</a> </dd></dl>

</div>
</div>
<a id="gaf539a66abed2a7a15e3443d70a3cf1e1" name="gaf539a66abed2a7a15e3443d70a3cf1e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf539a66abed2a7a15e3443d70a3cf1e1">&#9670;&#160;</a></span>LOG_LEVEL_WARNING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_LEVEL_WARNING&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="logging_8h.html">/Users/runner/work/reactor-c/reactor-c/logging/api/logging.h</a>&gt;</code></p>

<p>Warning log level. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga742fc70e331d7e568bd893c514756a29" title="Error log level, which is the lowest log level.">LOG_LEVEL_ERROR</a> </dd></dl>

</div>
</div>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="ga827080fd3c574bad5a32db9f7c367587" name="ga827080fd3c574bad5a32db9f7c367587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga827080fd3c574bad5a32db9f7c367587">&#9670;&#160;</a></span>instant_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int64_t <a class="el" href="#ga827080fd3c574bad5a32db9f7c367587">instant_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tag_8h.html">/Users/runner/work/reactor-c/reactor-c/tag/api/tag.h</a>&gt;</code></p>

<p>Time instant. </p>
<p>Both physical and logical times are represented using this typedef. </p>

</div>
</div>
<a id="gaf5b4e62d03782997d813be6145316f4b" name="gaf5b4e62d03782997d813be6145316f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5b4e62d03782997d813be6145316f4b">&#9670;&#160;</a></span>interval_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int64_t <a class="el" href="#gaf5b4e62d03782997d813be6145316f4b">interval_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tag_8h.html">/Users/runner/work/reactor-c/reactor-c/tag/api/tag.h</a>&gt;</code></p>

<p>Interval of time. </p>

</div>
</div>
<a id="gaf8a81a7373f3d5f77fd865e437964ef3" name="gaf8a81a7373f3d5f77fd865e437964ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8a81a7373f3d5f77fd865e437964ef3">&#9670;&#160;</a></span>lf_multiport_iterator_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct lf_multiport_iterator_t lf_multiport_iterator_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="port_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/port.h</a>&gt;</code></p>

<p>An iterator over a record of the subset of channels of a multiport that have present inputs. </p>
<p>To use this, create an iterator using the function <a class="el" href="#ga5759266c62b989a6b305584cb72f8840">lf_multiport_iterator()</a>. That function returns a struct that can be passed to the <a class="el" href="#gac7c743d3c64a839642e54781b8e9127f">lf_multiport_next()</a> function to obtain the next channel number of a present input (or -1 if there is no next present input). </p>

</div>
</div>
<a id="ga973e404c4c1bd798a54501d0e1d640f9" name="ga973e404c4c1bd798a54501d0e1d640f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga973e404c4c1bd798a54501d0e1d640f9">&#9670;&#160;</a></span>lf_token_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct lf_token_t lf_token_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__token_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_token.h</a>&gt;</code></p>

<p>Token type for dynamically allocated arrays and structs sent as messages. </p>
<p>This struct is the wrapper around the dynamically allocated memory that carries the message. The message can be an array of values, where the size of each value is element_size (in bytes). If it is not an array, or is not to be treated as an array, the length == 1.</p>
<p>In the C LF target, a type for an output that ends in '<em>' or '[]' is treated specially. The value carried by the output is assumed to be in dynamically allocated memory, and, using reference counting, after the last downstream reader of the value has finished, the memory will be freed. To prevent this freeing from occurring, the output type can be specified using the syntax {= type</em> =}; this will not be treated as dynamically allocated memory. Alternatively, the programmer can give a typedef in the preamble that masks the trailing *. </p>

</div>
</div>
<a id="gad88f1caa8b9c216404eb196cb1850213" name="gad88f1caa8b9c216404eb196cb1850213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad88f1caa8b9c216404eb196cb1850213">&#9670;&#160;</a></span>microstep_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="#gad88f1caa8b9c216404eb196cb1850213">microstep_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tag_8h.html">/Users/runner/work/reactor-c/reactor-c/tag/api/tag.h</a>&gt;</code></p>

<p>Microstep. </p>

</div>
</div>
<a id="gadc4e09bf2433b9e06b632880ce81b897" name="gadc4e09bf2433b9e06b632880ce81b897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc4e09bf2433b9e06b632880ce81b897">&#9670;&#160;</a></span>print_message_function_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void print_message_function_t(const char *, va_list)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="logging_8h.html">/Users/runner/work/reactor-c/reactor-c/logging/api/logging.h</a>&gt;</code></p>

<p>Message print function type. </p>
<p>The arguments passed to one of these print functions are a printf-style format strin followed by a printf-style argument list collected into a va_list (variable argument list). </p>

</div>
</div>
<a id="ga4505c08c065b48840a30eedd9845cce2" name="ga4505c08c065b48840a30eedd9845cce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4505c08c065b48840a30eedd9845cce2">&#9670;&#160;</a></span>string</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char* <a class="el" href="#ga4505c08c065b48840a30eedd9845cce2">string</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__types_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_types.h</a>&gt;</code></p>

<p>String type so that we don't have to use {= char* =}. </p>
<p>Use this as the type for ports sending and receiving strings that are not dynamically allocated. For dynamically allocated strings that have to be freed after being consumed downstream, use type <span class="tt">char*</span>. </p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="gab3a04dd0a1581844829b28686b6b3c53" name="gab3a04dd0a1581844829b28686b6b3c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3a04dd0a1581844829b28686b6b3c53">&#9670;&#160;</a></span>lf_check_deadline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lf_check_deadline </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>invoke_deadline_handler</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="schedule_8h.html">/Users/runner/work/reactor-c/reactor-c/include/api/schedule.h</a>&gt;</code></p>

<p>Check the deadline of the currently executing reaction against the current physical time. </p>
<p>If the deadline has passed, invoke the deadline handler (if invoke_deadline_handler parameter is set true) and return true. Otherwise, return false.</p>
<p>This function is intended to be used within a reaction that has been invoked without a deadline violation, but that wishes to check whether the deadline gets violated <em>during</em> the execution of the reaction. This can be used, for example, to implement a timeout mechanism that bounds the execution time of a reaction, for example to realize an "anytime" computation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The self struct of the reactor. </td></tr>
    <tr><td class="paramname">invoke_deadline_handler</td><td>When this is set true, also invoke deadline handler if the deadline has passed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified deadline has passed and false otherwise. </dd></dl>

</div>
</div>
<a id="gae956f1688a3893b44cf4bced3c13ef9a" name="gae956f1688a3893b44cf4bced3c13ef9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae956f1688a3893b44cf4bced3c13ef9a">&#9670;&#160;</a></span>lf_comma_separated_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t lf_comma_separated_time </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga827080fd3c574bad5a32db9f7c367587">instant_t</a></td>          <td class="paramname"><span class="paramname"><em>time</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tag_8h.html">/Users/runner/work/reactor-c/reactor-c/tag/api/tag.h</a>&gt;</code></p>

<p>Print a non-negative time value in nanoseconds with commas separating thousands into the specified buffer. </p>
<p>Ideally, this would use the locale to use periods if appropriate, but I haven't found a sufficiently portable way to do that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A buffer long enough to contain a string like "9,223,372,036,854,775,807". </td></tr>
    <tr><td class="paramname">time</td><td>A time value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters written (not counting the null terminator). </dd></dl>

</div>
</div>
<a id="gaf7feb89416e60e458d6a86cadadbc41d" name="gaf7feb89416e60e458d6a86cadadbc41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7feb89416e60e458d6a86cadadbc41d">&#9670;&#160;</a></span>lf_delay_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtag__t.html">tag_t</a> lf_delay_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaf5b4e62d03782997d813be6145316f4b">interval_t</a></td>          <td class="paramname"><span class="paramname"><em>interval</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tag_8h.html">/Users/runner/work/reactor-c/reactor-c/tag/api/tag.h</a>&gt;</code></p>

<p>Delay a tag by the specified time interval to realize the "after" keyword. </p>
<p>Any interval less than 0 (including NEVER) is interpreted as "no delay", whereas an interval equal to 0 is interpreted as one microstep delay. If the time field of the tag is NEVER or the interval is negative, return the unmodified tag. If the time interval is 0LL, add one to the microstep, leave the time field alone, and return the result. Otherwise, add the interval to the time field of the tag and reset the microstep to 0. If the sum overflows, saturate the time value at FOREVER. For example:</p><ul>
<li>if tag = (t, 0) and interval = 10, return (t + 10, 0)</li>
<li>if tag = (t, 0) and interval = 0, return (t, 1)</li>
<li>if tag = (t, 0) and interval = NEVER, return (t, 0)</li>
<li>if tag = (FOREVER, 0) and interval = 10, return (FOREVER, 0)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>The tag to increment. </td></tr>
    <tr><td class="paramname">interval</td><td>The time interval. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf4bdd144e6cc65dfa3b996d4bd82f83a" name="gaf4bdd144e6cc65dfa3b996d4bd82f83a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4bdd144e6cc65dfa3b996d4bd82f83a">&#9670;&#160;</a></span>lf_is_tag_after_stop_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lf_is_tag_after_stop_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor.h</a>&gt;</code></p>

<p>Return true if the provided tag is after stop tag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>Environment in which we are executing. </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to check against stop tag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac7c743d3c64a839642e54781b8e9127f" name="gac7c743d3c64a839642e54781b8e9127f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7c743d3c64a839642e54781b8e9127f">&#9670;&#160;</a></span>lf_multiport_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lf_multiport_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlf__multiport__iterator__t.html">lf_multiport_iterator_t</a> *</td>          <td class="paramname"><span class="paramname"><em>iterator</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="port_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/port.h</a>&gt;</code></p>

<p>Return the channel number of the next present input on the multiport or -1 if there are no more present channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>The iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa47b51a11727eec252ff7e786794bd88" name="gaa47b51a11727eec252ff7e786794bd88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa47b51a11727eec252ff7e786794bd88">&#9670;&#160;</a></span>lf_new_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlf__token__t.html">lf_token_t</a> * lf_new_token </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>port_or_action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__token_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_token.h</a>&gt;</code></p>

<p>Return a new disassociated token with type matching the specified port or action and containing the specified value and length. </p>
<p>The value is assumed to point to dynamically allocated memory that will be automatically freed. The length is 1 unless the type of the port is an array, in which case the value points to an array of the specified length. The token must then be sent to the port using <span class="tt">lf_set_token</span> or scheduled with the action using <span class="tt">lf_schedule_token</span>. The token can also be safely sent to any other port or scheduled with any other action that has the same type. If it is not scheduled or sent, then it is up to the user to free the memory allocated for the token and its value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_or_action</td><td>A port or action. </td></tr>
    <tr><td class="paramname">val</td><td>The value. </td></tr>
    <tr><td class="paramname">len</td><td>The length, or 1 if it not an array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <a class="el" href="structlf__token__t.html" title="Token type for dynamically allocated arrays and structs sent as messages.">lf_token_t</a> struct. </dd></dl>

</div>
</div>
<a id="ga9d83e586b29a3316dd7dc505e30e6858" name="ga9d83e586b29a3316dd7dc505e30e6858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d83e586b29a3316dd7dc505e30e6858">&#9670;&#160;</a></span>lf_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_print </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="logging_8h.html">/Users/runner/work/reactor-c/reactor-c/logging/api/logging.h</a>&gt;</code></p>

<p>Report an informational message on stdout with a newline appended at the end. </p>
<p>If this execution is federated, then the message will be prefaced by identifying information for the federate. The arguments are just like printf().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>The format string to print. </td></tr>
    <tr><td class="paramname">...</td><td>The arguments to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga22ebee89c962ac34cc1fa7b9762b77d2" name="ga22ebee89c962ac34cc1fa7b9762b77d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22ebee89c962ac34cc1fa7b9762b77d2">&#9670;&#160;</a></span>lf_print_debug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void void void lf_print_debug </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="logging_8h.html">/Users/runner/work/reactor-c/reactor-c/logging/api/logging.h</a>&gt;</code></p>

<p>Report an debug message on stdout with the prefix "DEBUG: " and a newline appended at the end. </p>
<p>If this execution is federated, then the message will be prefaced by identifying information for the federate. The arguments are just like printf().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>The format string to print. </td></tr>
    <tr><td class="paramname">...</td><td>The arguments to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae0a6bd6b164c5cc3e9928f5375dd1a97" name="gae0a6bd6b164c5cc3e9928f5375dd1a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0a6bd6b164c5cc3e9928f5375dd1a97">&#9670;&#160;</a></span>lf_print_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void void void void lf_print_error </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="logging_8h.html">/Users/runner/work/reactor-c/reactor-c/logging/api/logging.h</a>&gt;</code></p>

<p>Report an error with the prefix "ERROR: " and a newline appended at the end. </p>
<p>The arguments are just like printf().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>The format string to print. </td></tr>
    <tr><td class="paramname">...</td><td>The arguments to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabf2630e80adfec45b8b4a2782a0767a7" name="gabf2630e80adfec45b8b4a2782a0767a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf2630e80adfec45b8b4a2782a0767a7">&#9670;&#160;</a></span>lf_print_error_and_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void void void void void void lf_print_error_and_exit </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="logging_8h.html">/Users/runner/work/reactor-c/reactor-c/logging/api/logging.h</a>&gt;</code></p>

<p>Report an error with the prefix "ERROR: " and a newline appended at the end, then exit with the failure code EXIT_FAILURE. </p>
<p>The arguments are just like printf().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>The format string to print. </td></tr>
    <tr><td class="paramname">...</td><td>The arguments to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacbc9741875a95bb30e1a8d68cfb7cf06" name="gacbc9741875a95bb30e1a8d68cfb7cf06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbc9741875a95bb30e1a8d68cfb7cf06">&#9670;&#160;</a></span>lf_print_error_system_failure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void void void void void void void lf_print_error_system_failure </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="logging_8h.html">/Users/runner/work/reactor-c/reactor-c/logging/api/logging.h</a>&gt;</code></p>

<p>Report an error and exit just like <a class="el" href="#gabf2630e80adfec45b8b4a2782a0767a7" title="Report an error with the prefix &quot;ERROR: &quot; and a newline appended at the end, then exit with the failu...">lf_print_error_and_exit()</a>, but also print the system error message associated with the error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>The format string to print. </td></tr>
    <tr><td class="paramname">...</td><td>The arguments to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab202dc9383567eaa8d9ae7240c939c19" name="gab202dc9383567eaa8d9ae7240c939c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab202dc9383567eaa8d9ae7240c939c19">&#9670;&#160;</a></span>lf_print_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void void lf_print_log </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="logging_8h.html">/Users/runner/work/reactor-c/reactor-c/logging/api/logging.h</a>&gt;</code></p>

<p>Report an log message on stdout with the prefix "LOG: " and a newline appended at the end. </p>
<p>If this execution is federated, then the message will be prefaced by identifying information for the federate. The arguments are just like printf().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>The format string to print. </td></tr>
    <tr><td class="paramname">...</td><td>The arguments to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga613bc8d331e3fd9a3f78eb1600092e1d" name="ga613bc8d331e3fd9a3f78eb1600092e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga613bc8d331e3fd9a3f78eb1600092e1d">&#9670;&#160;</a></span>lf_print_warning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void void void void void lf_print_warning </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="logging_8h.html">/Users/runner/work/reactor-c/reactor-c/logging/api/logging.h</a>&gt;</code></p>

<p>Report a warning with the prefix "WARNING: " and a newline appended at the end. </p>
<p>The arguments are just like printf().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>The format string to print. </td></tr>
    <tr><td class="paramname">...</td><td>The arguments to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab5bf112c4237da16d08736ff3e3e36b8" name="gab5bf112c4237da16d08736ff3e3e36b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5bf112c4237da16d08736ff3e3e36b8">&#9670;&#160;</a></span>lf_reactor_full_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * lf_reactor_full_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structself__base__t.html">self_base_t</a> *</td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor.h</a>&gt;</code></p>

<p>Return the full name of the reactor. </p>
<p>The fully qualified name of a reactor is the instance name of the reactor concatenated with the names of all of its parents, separated by dots. If the reactor or any of its parents is a bank, then the name will have a suffix of the form <span class="tt">[bank_index]</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The self struct of the reactor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae76171d83c29dadd3adb3f9294a92138" name="gae76171d83c29dadd3adb3f9294a92138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae76171d83c29dadd3adb3f9294a92138">&#9670;&#160;</a></span>lf_reactor_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * lf_reactor_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structself__base__t.html">self_base_t</a> *</td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor.h</a>&gt;</code></p>

<p>Return the instance name of the reactor. </p>
<p>The instance name is the name of given to the instance created by the <span class="tt">new</span> operator in LF. If the instance is in a bank, then the name will have a suffix of the form <span class="tt">[bank_index]</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The self struct of the reactor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga43509483b3e9886acd002c7d7b6482c8" name="ga43509483b3e9886acd002c7d7b6482c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43509483b3e9886acd002c7d7b6482c8">&#9670;&#160;</a></span>lf_readable_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t lf_readable_time </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga827080fd3c574bad5a32db9f7c367587">instant_t</a></td>          <td class="paramname"><span class="paramname"><em>time</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tag_8h.html">/Users/runner/work/reactor-c/reactor-c/tag/api/tag.h</a>&gt;</code></p>

<p>Store into the specified buffer a string giving a human-readable rendition of the specified time. </p>
<p>The buffer must have length at least equal to <a class="el" href="#gacc2b8ac5ac3020137e71dfcdbaedf335">LF_TIME_BUFFER_LENGTH</a>. The format is: </p><div class="fragment"><div class="line">x weeks, x d, x hr, x min, x s, x unit</div>
</div><!-- fragment --><p> where each <span class="tt">x</span> is a string of numbers with commas inserted if needed every three numbers and <span class="tt">unit</span> is ns, us, or ms. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer into which to write the string. </td></tr>
    <tr><td class="paramname">time</td><td>The time to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters written (not counting the null terminator). </dd></dl>

</div>
</div>
<a id="ga6ad22ca79136cd15dc0d560aec067f76" name="ga6ad22ca79136cd15dc0d560aec067f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ad22ca79136cd15dc0d560aec067f76">&#9670;&#160;</a></span>lf_register_print_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_register_print_function </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gadc4e09bf2433b9e06b632880ce81b897">print_message_function_t</a> *</td>          <td class="paramname"><span class="paramname"><em>function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>log_level</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="logging_8h.html">/Users/runner/work/reactor-c/reactor-c/logging/api/logging.h</a>&gt;</code></p>

<p>Register a function to display messages. </p>
<p>After calling this, all messages passed to the above print functions will be printed using the specified function rather than printf if their log level is greater than the specified level. The level should be one of LOG_LEVEL_ERROR, LOG_LEVEL_WARNING, LOG_LEVEL_INFO, LOG_LEVEL_LOG, or LOG_LEVEL_DEBUG.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>The print message function or NULL to revert to using printf. </td></tr>
    <tr><td class="paramname">log_level</td><td>The level of messages to redirect. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab49affc958f705d9e33c5e3463848bda" name="gab49affc958f705d9e33c5e3463848bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab49affc958f705d9e33c5e3463848bda">&#9670;&#160;</a></span>lf_request_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_request_stop </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor.h</a>&gt;</code></p>

<p>Request a stop to execution as soon as possible. </p>
<p>In a non-federated execution with only a single enclave, this will occur one microstep later than the current tag. In a federated execution or when there is more than one enclave, it will likely occur at a later tag determined by the RTI so that all federates and enclaves stop at the same tag. </p>

</div>
</div>
<a id="ga6778eef97447cf0ba1f0afa8ba3a8dca" name="ga6778eef97447cf0ba1f0afa8ba3a8dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6778eef97447cf0ba1f0afa8ba3a8dca">&#9670;&#160;</a></span>lf_schedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Internal.html#ga3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a> lf_schedule </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaf5b4e62d03782997d813be6145316f4b">interval_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="schedule_8h.html">/Users/runner/work/reactor-c/reactor-c/include/api/schedule.h</a>&gt;</code></p>

<p>Schedule an action to occur with the specified time offset with no payload (no value conveyed). </p>
<p>The later tag will depend on whether the action is logical or physical. If it is logical, the time of the event will be the current logical time of the environment associated with the action plus the minimum delay of the action plus the extra delay. If that time is equal to the current time, then the tag will be one microstep beyond the current tag. If the action is physical, the time will be the current physical time plus the extra delay, and the microstep will be zero.</p>
<p>See <a class="el" href="#gabe3fd30bf6a2689fdb3ec03b4e2f47d1" title="Schedule the specified action at a later tag with the specified token as a payload.">lf_schedule_token()</a>, which this uses, for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>The action to be triggered (a pointer to an <span class="tt"><a class="el" href="structlf__action__base__t.html" title="Base type for actions.">lf_action_base_t</a></span>). </td></tr>
    <tr><td class="paramname">offset</td><td>The time offset over and above the minimum delay of the action. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the event, or 0 if no event was scheduled, or -1 for error. </dd></dl>

</div>
</div>
<a id="ga747594e2d7264ae8b044a095eb92ba27" name="ga747594e2d7264ae8b044a095eb92ba27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga747594e2d7264ae8b044a095eb92ba27">&#9670;&#160;</a></span>lf_schedule_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Internal.html#ga3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a> lf_schedule_copy </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaf5b4e62d03782997d813be6145316f4b">interval_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="schedule_8h.html">/Users/runner/work/reactor-c/reactor-c/include/api/schedule.h</a>&gt;</code></p>

<p>Schedule an action to occur with the specified value and time offset with a copy of the specified value. </p>
<p>If the value is non-null, then it will be copied into newly allocated memory under the assumption that its size is given in the trigger's token object's element_size field multiplied by the specified length.</p>
<p>The later tag will depend on whether the action is logical or physical. If it is logical, the time of the event will be the current logical time of the environment associated with the action plus the minimum delay of the action plus the extra delay. If that time is equal to the current time, then the tag will be one microstep beyond the current tag. If the action is physical, the time will be the current physical time plus the extra delay, and the microstep will be zero.</p>
<p>See <a class="el" href="#gabe3fd30bf6a2689fdb3ec03b4e2f47d1">lf_schedule_token()</a>, which this uses, for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>The action to be triggered (a pointer to an <span class="tt"><a class="el" href="structlf__action__base__t.html" title="Base type for actions.">lf_action_base_t</a></span>). </td></tr>
    <tr><td class="paramname">offset</td><td>The time offset over and above that in the action. </td></tr>
    <tr><td class="paramname">value</td><td>A pointer to the value to copy. </td></tr>
    <tr><td class="paramname">length</td><td>The length, if an array, 1 if a scalar, and 0 if value is NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the event, or 0 if no event was scheduled, or -1 for error. </dd></dl>

</div>
</div>
<a id="ga073ea4406a084a24e71b65936ba39e36" name="ga073ea4406a084a24e71b65936ba39e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga073ea4406a084a24e71b65936ba39e36">&#9670;&#160;</a></span>lf_schedule_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Internal.html#ga3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a> lf_schedule_int </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaf5b4e62d03782997d813be6145316f4b">interval_t</a></td>          <td class="paramname"><span class="paramname"><em>extra_delay</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="schedule_8h.html">/Users/runner/work/reactor-c/reactor-c/include/api/schedule.h</a>&gt;</code></p>

<p>Schedule the specified action with an integer value at a later logical time. </p>
<p>The later tag will depend on whether the action is logical or physical. If it is logical, the time of the event will be the current logical time of the environment associated with the action plus the minimum delay of the action plus the extra delay. If that time is equal to the current time, then the tag will be one microstep beyond the current tag. If the action is physical, the time will be the current physical time plus the extra delay, and the microstep will be zero.</p>
<p>This wraps a copy of the integer value in a token. See <a class="el" href="#gabe3fd30bf6a2689fdb3ec03b4e2f47d1" title="Schedule the specified action at a later tag with the specified token as a payload.">lf_schedule_token()</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>The action to be triggered (a pointer to an <span class="tt"><a class="el" href="structlf__action__base__t.html" title="Base type for actions.">lf_action_base_t</a></span>). </td></tr>
    <tr><td class="paramname">extra_delay</td><td>Extra offset of the event release above that in the action. </td></tr>
    <tr><td class="paramname">value</td><td>The value to send. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the event, or 0 if no event was scheduled, or -1 for error. </dd></dl>

</div>
</div>
<a id="gabe3fd30bf6a2689fdb3ec03b4e2f47d1" name="gabe3fd30bf6a2689fdb3ec03b4e2f47d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe3fd30bf6a2689fdb3ec03b4e2f47d1">&#9670;&#160;</a></span>lf_schedule_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Internal.html#ga3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a> lf_schedule_token </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaf5b4e62d03782997d813be6145316f4b">interval_t</a></td>          <td class="paramname"><span class="paramname"><em>extra_delay</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlf__token__t.html">lf_token_t</a> *</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="schedule_8h.html">/Users/runner/work/reactor-c/reactor-c/include/api/schedule.h</a>&gt;</code></p>

<p>Schedule the specified action at a later tag with the specified token as a payload. </p>
<p>The later tag will depend on whether the action is logical or physical. If it is logical, the time of the event will be the current logical time of the environment associated with the action plus the minimum delay of the action plus the extra delay. If that time is equal to the current time, then the tag will be one microstep beyond the current tag. If the action is physical, the time will be the current physical time plus the extra delay, and the microstep will be zero.</p>
<p>In both cases, if the resulting tag of the event conincides with a previously scheduled event for the same action, then, by default, a microstep will be added to the tag until there is no colliding event. This behavior can be changed by specifying a minimum spacing and a policy, as explained below.</p>
<p>An action will trigger at a logical time that depends on the <span class="tt">extra_delay</span> argument given to this schedule function, the <span class="tt">&lt;min_delay&gt;</span>, <span class="tt">&lt;min_spacing&gt;</span>, and <span class="tt">&lt;policy&gt;</span> arguments in the action declaration, and whether the action is physical or logical.</p>
<p>For a <span class="tt">logical</span> action <span class="tt">a</span>, the tag assigned to the event is computed as follows. First, let <em>t</em> be the <em>current logical time</em>. For a logical action, <em>t</em> is just the logical time at which the reaction calling <span class="tt">schedule()</span> is called. The <b>preliminary time</b> of the action is then just <em>t</em> + <span class="tt">&lt;min_delay&gt;</span> + <span class="tt">&lt;offset&gt;</span>. This preliminary time may be further modified, as explained below.</p>
<p>For a <b>physical</b> action, the preliminary time is similar, except that <em>t</em> is replaced by the current <em>physical</em> time <em>T</em> when <span class="tt">schedule()</span> is called.</p>
<p>If no <span class="tt">&lt;min_spacing&gt;</span> has been declared, then the tag of the event is simply the preliminary time unless there is already an event scheduled for the same action with the same tag. In that case, a microstep is added to the tag. If there is again a previously scheduled event with the same tag, then a microstep is added to the tag again. This process is repeated until there is no previously scheduled event with the same tag. This is equvalent to specifying a <span class="tt">&lt;min_spacing&gt;</span> of 0 with a <span class="tt">"defer"</span> policy.</p>
<p>If a <span class="tt">&lt;min_spacing&gt;</span> has been declared, then it gives a minimum logical time interval between the tags of two subsequently scheduled events. If the preliminary time is closer than <span class="tt">&lt;min_spacing&gt;</span> to the time of the previously scheduled event (if there is one), or if the preliminary time is earlier than the previously scheduled event, then the time will be modified to enforce the minimum spacing. The <span class="tt">&lt;policy&gt;</span> argument (if supported by the target) determines how the minimum spacing constraint is enforced.</p>
<p>Note that "previously scheduled" here means specifically the tag resulting from the most recent call to the schedule function for the same action.</p>
<p>The <span class="tt">&lt;policy&gt;</span> is one of the following:</p>
<ul>
<li><span class="tt">"defer"</span>: (<b>the default</b>) The event is added to the event queue with a tag that is equal to earliest time that satisfies the minimal spacing requirement. Assuming the time of the preceding event is <em>t_prev</em>, then the tag of the new event simply becomes <em>t_prev</em> + <span class="tt">&lt;min_spacing&gt;</span>.</li>
<li><span class="tt">"drop"</span>: The new event is dropped and <span class="tt">schedule()</span> returns without having modified the event queue.</li>
<li><span class="tt">"replace"</span>: The payload (if any) of the new event is assigned to the preceding event if it is still pending in the event queue; no new event is added to the event queue in this case. If the preceding event has already been pulled from the event queue, the default <span class="tt">"defer"</span> policy is applied.</li>
</ul>
<p>Note that while the <span class="tt">"defer"</span> policy is conservative in the sense that it does not discard events, it could potentially cause an unbounded growth of the event queue.</p>
<p>For example, suppose the minimum spacing of a logical action is 10 ms and the policy is <span class="tt">"defer"</span>. Suppose that in a reaction to <span class="tt">startup</span>, the logical action is scheduled with a delay of 100 ms, then again with a delay of 99 ms, and a third time with a delay of 101 ms. The logical action will trigger at elapsed times 100 ms, 110 ms, and 120 ms.</p>
<p>There are three conditions under which this function will not actually put an event on the event queue and decrement the reference count of the token (if there is one), which could result in the payload being freed. In all three cases, this function returns 0. Otherwise, it returns a handle to the scheduled trigger, which is an integer greater than 0.</p>
<p>The first condition is that stop() has been called and the time offset of this event is greater than zero. The second condition is that the logical time of the event is greater that the stop time (timeout) that is specified in the target properties or on the command line. The third condition is that the trigger argument is null.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>The action to be triggered (a pointer to an <span class="tt"><a class="el" href="structlf__action__base__t.html" title="Base type for actions.">lf_action_base_t</a></span>). </td></tr>
    <tr><td class="paramname">extra_delay</td><td>Extra offset of the event release above that in the action. </td></tr>
    <tr><td class="paramname">token</td><td>The token to carry the payload or null for no payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the event, or 0 if no event was scheduled, or -1 for error. </dd></dl>

</div>
</div>
<a id="ga986bb1be3a9e4f71e5b5dde30d9dc6ad" name="ga986bb1be3a9e4f71e5b5dde30d9dc6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga986bb1be3a9e4f71e5b5dde30d9dc6ad">&#9670;&#160;</a></span>lf_schedule_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Internal.html#ga3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a> lf_schedule_value </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaf5b4e62d03782997d813be6145316f4b">interval_t</a></td>          <td class="paramname"><span class="paramname"><em>extra_delay</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="schedule_8h.html">/Users/runner/work/reactor-c/reactor-c/include/api/schedule.h</a>&gt;</code></p>

<p>Variant of lf_schedule_token that creates a token to carry the specified value. </p>
<p>The value is required to be malloc'd memory with a size equal to the element_size of the specified action times the length parameter.</p>
<p>See <a class="el" href="#gabe3fd30bf6a2689fdb3ec03b4e2f47d1">lf_schedule_token()</a>, which this uses, for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td>The action to be triggered (a pointer to an <span class="tt"><a class="el" href="structlf__action__base__t.html" title="Base type for actions.">lf_action_base_t</a></span>). </td></tr>
    <tr><td class="paramname">extra_delay</td><td>Extra offset of the event release above that in the action. </td></tr>
    <tr><td class="paramname">value</td><td>Dynamically allocated memory containing the value to send. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the array, if it is an array, or 1 for a scalar and 0 for no payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the event, or 0 if no event was scheduled, or -1 for error. </dd></dl>

</div>
</div>
<a id="gadaa6f5f1a265e7a37aeb3b6a0d101732" name="gadaa6f5f1a265e7a37aeb3b6a0d101732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadaa6f5f1a265e7a37aeb3b6a0d101732">&#9670;&#160;</a></span>lf_set_present()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_set_present </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlf__port__base__t.html">lf_port_base_t</a> *</td>          <td class="paramname"><span class="paramname"><em>port</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor.h</a>&gt;</code></p>

<p>Mark the given port's is_present field as true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>A pointer to the port struct as an <span class="tt">lf_port_base_t*</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacbe5117469b98e0e6df45b5421f58026" name="gacbe5117469b98e0e6df45b5421f58026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbe5117469b98e0e6df45b5421f58026">&#9670;&#160;</a></span>lf_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtag__t.html">tag_t</a> lf_tag </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tag_8h.html">/Users/runner/work/reactor-c/reactor-c/tag/api/tag.h</a>&gt;</code></p>

<p>Return the current tag, a logical time, microstep pair. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>A pointer to the environment from which we want the current tag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa1186f7e330ecbfd20a4dd90b97439e6" name="gaa1186f7e330ecbfd20a4dd90b97439e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1186f7e330ecbfd20a4dd90b97439e6">&#9670;&#160;</a></span>lf_tag_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtag__t.html">tag_t</a> lf_tag_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tag_8h.html">/Users/runner/work/reactor-c/reactor-c/tag/api/tag.h</a>&gt;</code></p>

<p>Add two tags. </p>
<p>If either tag has has NEVER or FOREVER in its time field, then return NEVER_TAG or FOREVER_TAG, respectively. Also return NEVER_TAG or FOREVER_TAG if the result underflows or overflows when adding the times. If the microstep overflows, also return FOREVER_TAG. If the time field of the second tag is greater than 0, then the microstep of the first tag is reset to 0 before adding. This models the delay semantics in LF and makes this addition operation non-commutative. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first tag. </td></tr>
    <tr><td class="paramname">b</td><td>The second tag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga596d8734432616c9c7847283fde63cfa" name="ga596d8734432616c9c7847283fde63cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga596d8734432616c9c7847283fde63cfa">&#9670;&#160;</a></span>lf_tag_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lf_tag_compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>tag1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>tag2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tag_8h.html">/Users/runner/work/reactor-c/reactor-c/tag/api/tag.h</a>&gt;</code></p>

<p>Compare two tags. </p>
<p>Return -1 if the first is less than the second, 0 if they are equal, and +1 if the first is greater than the second. A tag is greater than another if its time is greater or if its time is equal and its microstep is greater. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag1</td><td></td></tr>
    <tr><td class="paramname">tag2</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1, 0, or 1 depending on the relation. </dd></dl>

</div>
</div>
<a id="ga1789de56286aa33c086b194b544c2d91" name="ga1789de56286aa33c086b194b544c2d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1789de56286aa33c086b194b544c2d91">&#9670;&#160;</a></span>lf_time_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga827080fd3c574bad5a32db9f7c367587">instant_t</a> lf_time_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga827080fd3c574bad5a32db9f7c367587">instant_t</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaf5b4e62d03782997d813be6145316f4b">interval_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tag_8h.html">/Users/runner/work/reactor-c/reactor-c/tag/api/tag.h</a>&gt;</code></p>

<p>Return the sum of an interval and an instant, saturating on overflow and underflow. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="#ga827080fd3c574bad5a32db9f7c367587" title="Time instant.">instant_t</a> </dd></dl>

</div>
</div>
<a id="ga7538766a655ba2e60ddde55f2e020e58" name="ga7538766a655ba2e60ddde55f2e020e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7538766a655ba2e60ddde55f2e020e58">&#9670;&#160;</a></span>lf_time_physical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga827080fd3c574bad5a32db9f7c367587">instant_t</a> lf_time_physical </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tag_8h.html">/Users/runner/work/reactor-c/reactor-c/tag/api/tag.h</a>&gt;</code></p>

<p>Return the current physical time in nanoseconds. </p>
<p>On many platforms, this is the number of nanoseconds since January 1, 1970, but it is actually platform dependent.</p>
<dl class="section return"><dt>Returns</dt><dd>A time instant. </dd></dl>

</div>
</div>
<a id="ga98468f1c5132e3aa18d77f85d65bb6ec" name="ga98468f1c5132e3aa18d77f85d65bb6ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98468f1c5132e3aa18d77f85d65bb6ec">&#9670;&#160;</a></span>lf_time_physical_elapsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga827080fd3c574bad5a32db9f7c367587">instant_t</a> lf_time_physical_elapsed </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tag_8h.html">/Users/runner/work/reactor-c/reactor-c/tag/api/tag.h</a>&gt;</code></p>

<p>Return the elapsed physical time in nanoseconds. </p>
<p>This is the time returned by <a class="el" href="#ga7538766a655ba2e60ddde55f2e020e58" title="Return the current physical time in nanoseconds.">lf_time_physical(void)</a> minus the physical start time as measured by <a class="el" href="#ga7538766a655ba2e60ddde55f2e020e58" title="Return the current physical time in nanoseconds.">lf_time_physical(void)</a> when the program was started. </p>

</div>
</div>
<a id="ga8da2172c41ab13ff4748994a62ae34b5" name="ga8da2172c41ab13ff4748994a62ae34b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8da2172c41ab13ff4748994a62ae34b5">&#9670;&#160;</a></span>lf_time_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga827080fd3c574bad5a32db9f7c367587">instant_t</a> lf_time_start </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tag_8h.html">/Users/runner/work/reactor-c/reactor-c/tag/api/tag.h</a>&gt;</code></p>

<p>Return the physical and logical time of the start of execution in nanoseconds. </p>
<p>On many platforms, this is the number of nanoseconds since January 1, 1970, but it is actually platform dependent.</p>
<dl class="section return"><dt>Returns</dt><dd>A time instant. </dd></dl>

</div>
</div>
<a id="ga9107f7f62874fa972f7a31f9c277b8fc" name="ga9107f7f62874fa972f7a31f9c277b8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9107f7f62874fa972f7a31f9c277b8fc">&#9670;&#160;</a></span>lf_time_subtract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga827080fd3c574bad5a32db9f7c367587">instant_t</a> lf_time_subtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ga827080fd3c574bad5a32db9f7c367587">instant_t</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaf5b4e62d03782997d813be6145316f4b">interval_t</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tag_8h.html">/Users/runner/work/reactor-c/reactor-c/tag/api/tag.h</a>&gt;</code></p>

<p>Return an instant minus an interval, saturating on overflow and underflow. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
    <tr><td class="paramname">b</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="#ga827080fd3c574bad5a32db9f7c367587" title="Time instant.">instant_t</a> </dd></dl>

</div>
</div>
<a id="ga82bf2c7bd91fdf03b357914cf875dbb9" name="ga82bf2c7bd91fdf03b357914cf875dbb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82bf2c7bd91fdf03b357914cf875dbb9">&#9670;&#160;</a></span>lf_watchdog_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_watchdog_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwatchdog__t.html">watchdog_t</a> *</td>          <td class="paramname"><span class="paramname"><em>watchdog</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaf5b4e62d03782997d813be6145316f4b">interval_t</a></td>          <td class="paramname"><span class="paramname"><em>additional_timeout</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="watchdog_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/threaded/watchdog.h</a>&gt;</code></p>

<p>Start or restart the watchdog timer. </p>
<p>This function sets the expiration time of the watchdog to the current logical time plus the minimum timeout of the watchdog plus the specified <span class="tt">additional_timeout</span>. This function assumes the reactor mutex is held when it is called; this assumption is satisfied whenever this function is called from within a reaction that declares the watchdog as an effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">watchdog</td><td>The watchdog to be started </td></tr>
    <tr><td class="paramname">additional_timeout</td><td>Additional timeout to be added to the watchdog's minimum expiration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa27ad22f94bbdaa33b99fe6cd81f1bdc" name="gaa27ad22f94bbdaa33b99fe6cd81f1bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa27ad22f94bbdaa33b99fe6cd81f1bdc">&#9670;&#160;</a></span>lf_watchdog_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_watchdog_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structwatchdog__t.html">watchdog_t</a> *</td>          <td class="paramname"><span class="paramname"><em>watchdog</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="watchdog_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/threaded/watchdog.h</a>&gt;</code></p>

<p>Stop the specified watchdog without invoking the expiration handler. </p>
<p>This function sets the expiration time of the watchdog to <span class="tt">NEVER</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">watchdog</td><td>The watchdog. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaf8e6f18b021d0b8ece7e1b64280432f" name="gaaf8e6f18b021d0b8ece7e1b64280432f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf8e6f18b021d0b8ece7e1b64280432f">&#9670;&#160;</a></span>lf_writable_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlf__token__t.html">lf_token_t</a> * lf_writable_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlf__port__base__t.html">lf_port_base_t</a> *</td>          <td class="paramname"><span class="paramname"><em>port</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__token_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_token.h</a>&gt;</code></p>

<p>Return a writable copy of the token in the specified template. </p>
<p>If the reference count is 1, this returns the template's token rather than a copy. The reference count will be 1. Otherwise, if the size of the token payload is zero, this also returns the original token, again with reference count of 1. Otherwise, this returns a new token with a reference count of 1. The new token is added to a list of tokens whose reference counts will be decremented at the start of the next tag. If the template has no token (it has a primitive type), then there is no need for a writable copy. Return NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>An input port, cast to (lf_port_base_t*). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a writable copy of the token, or NULL if the type is primitive. </dd></dl>

</div>
</div>
<a id="gae6078a659280c57ae1c4dfe939f319e7" name="gae6078a659280c57ae1c4dfe939f319e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6078a659280c57ae1c4dfe939f319e7">&#9670;&#160;</a></span>register_user_trace_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int register_user_trace_event </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>description</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tracepoint_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/tracepoint.h</a>&gt;</code></p>

<p>Register a user trace event. </p>
<p>This should be called once, providing a pointer to a string that describes a phenomenon being traced. Use the same pointer as the first argument to <a class="el" href="#gacd97e049ba442bdd90f020c0b7c1a4fa">tracepoint_user_event()</a> and <a class="el" href="#ga064170081cf3de9c123b58bdc51b1d4f">tracepoint_user_value()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Pointer to the self struct of the reactor from which we want to trace this event. This pointer is used to get the correct environment and thus the correct logical tag of the event. </td></tr>
    <tr><td class="paramname">description</td><td>Pointer to a human-readable description of the event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 if the trace object table is full. </dd></dl>

</div>
</div>
<a id="gacd97e049ba442bdd90f020c0b7c1a4fa" name="gacd97e049ba442bdd90f020c0b7c1a4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd97e049ba442bdd90f020c0b7c1a4fa">&#9670;&#160;</a></span>tracepoint_user_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tracepoint_user_event </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>description</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tracepoint_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/tracepoint.h</a>&gt;</code></p>

<p>Trace a user-defined event. </p>
<p>Before calling this, you must call <a class="el" href="#gae6078a659280c57ae1c4dfe939f319e7">register_user_trace_event()</a> with a pointer to the same string or else the event will not be recognized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Pointer to the self struct of the reactor from which we want to trace this event. This pointer is used to get the correct environment and thus the correct logical tag of the event. </td></tr>
    <tr><td class="paramname">description</td><td>Pointer to the description string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga064170081cf3de9c123b58bdc51b1d4f" name="ga064170081cf3de9c123b58bdc51b1d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga064170081cf3de9c123b58bdc51b1d4f">&#9670;&#160;</a></span>tracepoint_user_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tracepoint_user_value </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>self</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>description</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tracepoint_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/tracepoint.h</a>&gt;</code></p>

<p>Trace a user-defined event with a value. </p>
<p>Before calling this, you must call <a class="el" href="#gae6078a659280c57ae1c4dfe939f319e7">register_user_trace_event()</a> with a pointer to the same string or else the event will not be recognized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>Pointer to the self struct of the reactor from which we want to trace this event. This pointer is used to get the correct environment and thus the correct logical tag of the event. </td></tr>
    <tr><td class="paramname">description</td><td>Pointer to the description string. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the event. This is a long long for convenience so that time values can be passed unchanged. But int values work as well. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on <span class="timestamp"></span> for reactor-c by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
