<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>reactor-c: Federated</title>
<link rel="icon" href="favicon.ico" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">reactor-c<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">C Runtime for Lingua Franca</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__Federated.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Federated </div></div>
</div><!--header-->
<div class="contents">

<p>Functions for federated execution.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-files" class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:clock-sync_2Eh" id="r_clock-sync_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clock-sync_8h.html">clock-sync.h</a></td></tr>
<tr class="memdesc:clock-sync_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility functions for clock synchronization in federated Lingua Franca programs. <br /></td></tr>
<tr class="memitem:federate_2Eh" id="r_federate_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="federate_8h.html">federate.h</a></td></tr>
<tr class="memdesc:federate_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structures and functions for federated Lingua Franca programs. <br /></td></tr>
<tr class="memitem:net_5Fcommon_2Eh" id="r_net_5Fcommon_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__common_8h.html">net_common.h</a></td></tr>
<tr class="memdesc:net__common_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common message types and definitions for federated Lingua Franca programs. <br /></td></tr>
<tr class="memitem:net_5Futil_2Eh" id="r_net_5Futil_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8h.html">net_util.h</a></td></tr>
<tr class="memdesc:net__util_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Network utility functions for Lingua Franca programs. <br /></td></tr>
<tr class="memitem:socket_5Fcommon_2Eh" id="r_socket_5Fcommon_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="socket__common_8h.html">socket_common.h</a></td></tr>
<tr class="memdesc:socket__common_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common socket operations and utilities for federated Lingua Franca programs. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:federate_5Finstance_5Ft" id="r_federate_5Finstance_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfederate__instance__t.html">federate_instance_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that a federate instance uses to keep track of its own state.  <a href="structfederate__instance__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:federation_5Fmetadata_5Ft" id="r_federation_5Fmetadata_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfederation__metadata__t.html">federation_metadata_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for federation metadata.  <a href="structfederation__metadata__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:lf_5Fstat_5Fll" id="r_lf_5Fstat_5Fll"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlf__stat__ll.html">lf_stat_ll</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds generic statistical data.  <a href="structlf__stat__ll.html#details">More...</a><br /></td></tr>
<tr class="memitem:rti_5Faddr_5Finfo_5Ft" id="r_rti_5Faddr_5Finfo_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrti__addr__info__t.html">rti_addr_info_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper struct for passing rti_addr information between lf_parse_rti_addr and extract_rti_addr_info.  <a href="structrti__addr__info__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:socket_5Fstat_5Ft" id="r_socket_5Fstat_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsocket__stat__t.html">socket_stat_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics and state for clock synchronization over a socket connection.  <a href="structsocket__stat__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:staa_5Ft" id="r_staa_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstaa__t.html">staa_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for STAA (safe to assume absent).  <a href="structstaa__t.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga532da6f271eb75c9ac745571b995c404" id="r_ga532da6f271eb75c9ac745571b995c404"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga532da6f271eb75c9ac745571b995c404">_LF_CLOCK_SYNC_ATTENUATION</a>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:ga532da6f271eb75c9ac745571b995c404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime clock offset updates will be divided by this number.  <br /></td></tr>
<tr class="memitem:ga4b9290ecd850995c857e04746aa45d10" id="r_ga4b9290ecd850995c857e04746aa45d10"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4b9290ecd850995c857e04746aa45d10">_LF_CLOCK_SYNC_COLLECT_STATS</a>&#160;&#160;&#160;true</td></tr>
<tr class="memdesc:ga4b9290ecd850995c857e04746aa45d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">By default, collect statistics on clock synchronization.  <br /></td></tr>
<tr class="memitem:gab0eeaea19d6e5c9217a4eed928c32141" id="r_gab0eeaea19d6e5c9217a4eed928c32141"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab0eeaea19d6e5c9217a4eed928c32141">_LF_CLOCK_SYNC_EXCHANGES_PER_INTERVAL</a>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:gab0eeaea19d6e5c9217a4eed928c32141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of required clock sync T4 messages per synchronization interval.  <br /></td></tr>
<tr class="memitem:ga8ce563da4edbe9c4f7c1ccf35ad8694f" id="r_ga8ce563da4edbe9c4f7c1ccf35ad8694f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8ce563da4edbe9c4f7c1ccf35ad8694f">ADDRESS_QUERY_RETRY_INTERVAL</a>&#160;&#160;&#160;<a class="el" href="group__Constants.html#ga673a8ebab8ec621a1cf731871dd170c8">MSEC</a>(250)</td></tr>
<tr class="memdesc:ga8ce563da4edbe9c4f7c1ccf35ad8694f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time that a federate waits before asking the RTI again for the port and IP address of a federate.  <br /></td></tr>
<tr class="memitem:ga0810a64801750ce9b148848c228c86e9" id="r_ga0810a64801750ce9b148848c228c86e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0810a64801750ce9b148848c228c86e9">CLOCK_SYNC_GUARD_BAND</a>&#160;&#160;&#160;<a class="el" href="group__Constants.html#gaa2aeaab0c2033d1db412c8021bff93fc">USEC</a>(100)</td></tr>
<tr class="memdesc:ga0810a64801750ce9b148848c228c86e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a guard band to filter clock synchronization messages based on discrepancies in the network delay.  <br /></td></tr>
<tr class="memitem:gab2106828de539188aed925f592751c12" id="r_gab2106828de539188aed925f592751c12"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab2106828de539188aed925f592751c12">CONNECT_RETRY_INTERVAL</a>&#160;&#160;&#160;<a class="el" href="group__Constants.html#ga673a8ebab8ec621a1cf731871dd170c8">MSEC</a>(500)</td></tr>
<tr class="memdesc:gab2106828de539188aed925f592751c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time between a federate's attempts to connect to the RTI.  <br /></td></tr>
<tr class="memitem:ga252b2cb72531cb00ecd4d4db37a5a473" id="r_ga252b2cb72531cb00ecd4d4db37a5a473"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga252b2cb72531cb00ecd4d4db37a5a473">CONNECT_TIMEOUT</a>&#160;&#160;&#160;<a class="el" href="group__Constants.html#ga694878332b974b464c7d58c7114ee6e9">MINUTES</a>(1)</td></tr>
<tr class="memdesc:ga252b2cb72531cb00ecd4d4db37a5a473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound on the number of retries to connect to the RTI.  <br /></td></tr>
<tr class="memitem:ga16b710f592bf8f7900666392adc444dc" id="r_ga16b710f592bf8f7900666392adc444dc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga16b710f592bf8f7900666392adc444dc">DEFAULT_PORT</a>&#160;&#160;&#160;15045u</td></tr>
<tr class="memdesc:ga16b710f592bf8f7900666392adc444dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default port number for the RTI.  <br /></td></tr>
<tr class="memitem:ga7b7cd916c6c027dc9ebdff449fb6edad" id="r_ga7b7cd916c6c027dc9ebdff449fb6edad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7b7cd916c6c027dc9ebdff449fb6edad">DELAY_BETWEEN_SOCKET_RETRIES</a>&#160;&#160;&#160;<a class="el" href="group__Constants.html#ga673a8ebab8ec621a1cf731871dd170c8">MSEC</a>(100)</td></tr>
<tr class="memdesc:ga7b7cd916c6c027dc9ebdff449fb6edad"><td class="mdescLeft">&#160;</td><td class="mdescRight">The amount of time to wait after a failed socket read or write before trying again.  <br /></td></tr>
<tr class="memitem:ga4b8c713b515dba0c86d9205dc0caf4ed" id="r_ga4b8c713b515dba0c86d9205dc0caf4ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4b8c713b515dba0c86d9205dc0caf4ed">DELAY_START</a>&#160;&#160;&#160;<a class="el" href="group__Constants.html#ga30e47c4dd44d168c2982d3ec1d4e0825">SEC</a>(1)</td></tr>
<tr class="memdesc:ga4b8c713b515dba0c86d9205dc0caf4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay the start of all federates by this amount.  <br /></td></tr>
<tr class="memitem:ga8086398bfefdc0104767df037e59daa5" id="r_ga8086398bfefdc0104767df037e59daa5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8086398bfefdc0104767df037e59daa5">ENCODE_STOP_GRANTED</a>(buffer,  time,  microstep)</td></tr>
<tr class="memdesc:ga8086398bfefdc0104767df037e59daa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a stop granted message.  <br /></td></tr>
<tr class="memitem:ga3268a658c2cb5126be5284a86ad9bd62" id="r_ga3268a658c2cb5126be5284a86ad9bd62"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3268a658c2cb5126be5284a86ad9bd62">ENCODE_STOP_REQUEST</a>(buffer,  time,  microstep)</td></tr>
<tr class="memdesc:ga3268a658c2cb5126be5284a86ad9bd62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a stop request message.  <br /></td></tr>
<tr class="memitem:gae06b33f7fcdc71f52eb0fcf81e07e4d6" id="r_gae06b33f7fcdc71f52eb0fcf81e07e4d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae06b33f7fcdc71f52eb0fcf81e07e4d6">ENCODE_STOP_REQUEST_REPLY</a>(buffer,  time,  microstep)</td></tr>
<tr class="memdesc:gae06b33f7fcdc71f52eb0fcf81e07e4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode a stop request reply message.  <br /></td></tr>
<tr class="memitem:gacc95612e1d2dbbdf34afe76d50e75223" id="r_gacc95612e1d2dbbdf34afe76d50e75223"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacc95612e1d2dbbdf34afe76d50e75223">FED_COM_BUFFER_SIZE</a>&#160;&#160;&#160;256u</td></tr>
<tr class="memdesc:gacc95612e1d2dbbdf34afe76d50e75223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the buffer used for messages sent between federates.  <br /></td></tr>
<tr class="memitem:gae3bd830cd17cf0914b61d0516360abc1" id="r_gae3bd830cd17cf0914b61d0516360abc1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae3bd830cd17cf0914b61d0516360abc1">FEDERATE_ID_IN_USE</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:gae3bd830cd17cf0914b61d0516360abc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code sent with a <a class="el" href="#ga59a69d0685fdc2a216718f1efa083c4c">MSG_TYPE_REJECT</a> message indicating that the federate ID is already in use.  <br /></td></tr>
<tr class="memitem:ga5846fdcf4c92041f543b73e29e78aa21" id="r_ga5846fdcf4c92041f543b73e29e78aa21"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5846fdcf4c92041f543b73e29e78aa21">FEDERATE_ID_OUT_OF_RANGE</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:ga5846fdcf4c92041f543b73e29e78aa21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code sent with a <a class="el" href="#ga59a69d0685fdc2a216718f1efa083c4c">MSG_TYPE_REJECT</a> message indicating that the federate ID is out of range.  <br /></td></tr>
<tr class="memitem:ga653676d1f302fe08249af3dee78fa294" id="r_ga653676d1f302fe08249af3dee78fa294"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga653676d1f302fe08249af3dee78fa294">FEDERATION_ID_DOES_NOT_MATCH</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga653676d1f302fe08249af3dee78fa294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code sent with a <a class="el" href="#ga59a69d0685fdc2a216718f1efa083c4c">MSG_TYPE_REJECT</a> message indicating that the federation ID does not match.  <br /></td></tr>
<tr class="memitem:ga51d08a784b4ee6463688a971d99d2944" id="r_ga51d08a784b4ee6463688a971d99d2944"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga51d08a784b4ee6463688a971d99d2944">HMAC_DOES_NOT_MATCH</a>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:ga51d08a784b4ee6463688a971d99d2944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code sent with a <a class="el" href="#ga59a69d0685fdc2a216718f1efa083c4c">MSG_TYPE_REJECT</a> message indicating that the HMAC authentication failed.  <br /></td></tr>
<tr class="memitem:gab36196523f89c0d8f30c1965b458beb6" id="r_gab36196523f89c0d8f30c1965b458beb6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab36196523f89c0d8f30c1965b458beb6">LF_CLOCK_SYNC</a>&#160;&#160;&#160;<a class="el" href="#ga7ed4e5f2a4216fdf6d76eafcab5b49b7">LF_CLOCK_SYNC_INIT</a></td></tr>
<tr class="memdesc:gab36196523f89c0d8f30c1965b458beb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clock synchronization mode.  <br /></td></tr>
<tr class="memitem:ga7ed4e5f2a4216fdf6d76eafcab5b49b7" id="r_ga7ed4e5f2a4216fdf6d76eafcab5b49b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7ed4e5f2a4216fdf6d76eafcab5b49b7">LF_CLOCK_SYNC_INIT</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ga7ed4e5f2a4216fdf6d76eafcab5b49b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicator for clock synchronization to be turned on at initialization.  <br /></td></tr>
<tr class="memitem:ga742c3183fb89d811377514d09e526b8f" id="r_ga742c3183fb89d811377514d09e526b8f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga742c3183fb89d811377514d09e526b8f">LF_CLOCK_SYNC_OFF</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga742c3183fb89d811377514d09e526b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicator for clock synchronization to be turned off altogether.  <br /></td></tr>
<tr class="memitem:gaa9efe35bfc06d22220c852574c4a5feb" id="r_gaa9efe35bfc06d22220c852574c4a5feb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa9efe35bfc06d22220c852574c4a5feb">LF_CLOCK_SYNC_ON</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:gaa9efe35bfc06d22220c852574c4a5feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicator for clock synchronization to be turned on at initialization and runtime.  <br /></td></tr>
<tr class="memitem:ga5dbc42b5857eb262a06aa04399475d16" id="r_ga5dbc42b5857eb262a06aa04399475d16"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5dbc42b5857eb262a06aa04399475d16">MAX_NUM_PORT_ADDRESSES</a>&#160;&#160;&#160;16u</td></tr>
<tr class="memdesc:ga5dbc42b5857eb262a06aa04399475d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of port addresses that a federate will try to connect to the RTI on.  <br /></td></tr>
<tr class="memitem:gad94567b2d2e277ddc1be0da9a92b09e7" id="r_gad94567b2d2e277ddc1be0da9a92b09e7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad94567b2d2e277ddc1be0da9a92b09e7">MSG_TYPE_ACK</a>&#160;&#160;&#160;255</td></tr>
<tr class="memdesc:gad94567b2d2e277ddc1be0da9a92b09e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte identifying an acknowledgment of the previously received message.  <br /></td></tr>
<tr class="memitem:gae004cb4e5add42afe5483f6706e11d35" id="r_gae004cb4e5add42afe5483f6706e11d35"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae004cb4e5add42afe5483f6706e11d35">MSG_TYPE_ADDRESS_ADVERTISEMENT</a>&#160;&#160;&#160;15</td></tr>
<tr class="memdesc:gae004cb4e5add42afe5483f6706e11d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte identifying a message advertising the port for the TCP connection server of a federate.  <br /></td></tr>
<tr class="memitem:ga5ac191bca25da16eca3e4f02d21172ef" id="r_ga5ac191bca25da16eca3e4f02d21172ef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5ac191bca25da16eca3e4f02d21172ef">MSG_TYPE_ADDRESS_QUERY</a>&#160;&#160;&#160;13</td></tr>
<tr class="memdesc:ga5ac191bca25da16eca3e4f02d21172ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte identifying a address query message, sent by a federate to RTI to ask for another federate's address and port number.  <br /></td></tr>
<tr class="memitem:gaabe4cac3ef1d0834a99fa2532dfaa6ba" id="r_gaabe4cac3ef1d0834a99fa2532dfaa6ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaabe4cac3ef1d0834a99fa2532dfaa6ba">MSG_TYPE_ADDRESS_QUERY_REPLY</a>&#160;&#160;&#160;14</td></tr>
<tr class="memdesc:gaabe4cac3ef1d0834a99fa2532dfaa6ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte identifying a address query message reply, sent by a RTI to a federate to reply with a remote federate's address and port number.  <br /></td></tr>
<tr class="memitem:gaa13eface5080ad75bbd53abe919c80b6" id="r_gaa13eface5080ad75bbd53abe919c80b6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa13eface5080ad75bbd53abe919c80b6">MSG_TYPE_CLOCK_SYNC_CODED_PROBE</a>&#160;&#160;&#160;22</td></tr>
<tr class="memdesc:gaa13eface5080ad75bbd53abe919c80b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coded probe message.  <br /></td></tr>
<tr class="memitem:gaea37eff76ade1b2781a7e6298afb3a04" id="r_gaea37eff76ade1b2781a7e6298afb3a04"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaea37eff76ade1b2781a7e6298afb3a04">MSG_TYPE_CLOCK_SYNC_T1</a>&#160;&#160;&#160;19</td></tr>
<tr class="memdesc:gaea37eff76ade1b2781a7e6298afb3a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physical clock synchronization messages according to PTP.  <br /></td></tr>
<tr class="memitem:ga52a76e4cc36217a169f32d5adde590cc" id="r_ga52a76e4cc36217a169f32d5adde590cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga52a76e4cc36217a169f32d5adde590cc">MSG_TYPE_CLOCK_SYNC_T3</a>&#160;&#160;&#160;20</td></tr>
<tr class="memdesc:ga52a76e4cc36217a169f32d5adde590cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prompt the master to send a T4.  <br /></td></tr>
<tr class="memitem:gae128056ab2af39988103856ee815d930" id="r_gae128056ab2af39988103856ee815d930"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae128056ab2af39988103856ee815d930">MSG_TYPE_CLOCK_SYNC_T4</a>&#160;&#160;&#160;21</td></tr>
<tr class="memdesc:gae128056ab2af39988103856ee815d930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physical clock synchronization message according to PTP.  <br /></td></tr>
<tr class="memitem:gafb060091e032562cf32c0eb62340d309" id="r_gafb060091e032562cf32c0eb62340d309"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafb060091e032562cf32c0eb62340d309">MSG_TYPE_DOWNSTREAM_NEXT_EVENT_TAG</a>&#160;&#160;&#160;26</td></tr>
<tr class="memdesc:gafb060091e032562cf32c0eb62340d309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte identifying a downstream next event tag (DNET) message sent from the RTI in centralized coordination.  <br /></td></tr>
<tr class="memitem:gaf27674f627be1c469a529a995da5c074" id="r_gaf27674f627be1c469a529a995da5c074"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf27674f627be1c469a529a995da5c074">MSG_TYPE_FAILED</a>&#160;&#160;&#160;25</td></tr>
<tr class="memdesc:gaf27674f627be1c469a529a995da5c074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte identifying that the federate or the RTI has failed.  <br /></td></tr>
<tr class="memitem:gaf27674f627be1c469a529a995da5c074" id="r_gaf27674f627be1c469a529a995da5c074"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf27674f627be1c469a529a995da5c074">MSG_TYPE_FAILED</a>&#160;&#160;&#160;25</td></tr>
<tr class="memdesc:gaf27674f627be1c469a529a995da5c074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte identifying that the federate or the RTI has failed.  <br /></td></tr>
<tr class="memitem:ga8e49ce0b1c3a58c881849ca4d0bae824" id="r_ga8e49ce0b1c3a58c881849ca4d0bae824"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8e49ce0b1c3a58c881849ca4d0bae824">MSG_TYPE_FED_IDS</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga8e49ce0b1c3a58c881849ca4d0bae824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte identifying a message from a federate to an RTI containing the federation ID and the federate ID.  <br /></td></tr>
<tr class="memitem:ga191b27bec42ab0370248fbc64cc9b860" id="r_ga191b27bec42ab0370248fbc64cc9b860"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga191b27bec42ab0370248fbc64cc9b860">MSG_TYPE_FED_NONCE</a>&#160;&#160;&#160;100</td></tr>
<tr class="memdesc:ga191b27bec42ab0370248fbc64cc9b860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte identifying a message from a federate to an RTI containing federate's 8-byte random nonce for HMAC-based authentication.  <br /></td></tr>
<tr class="memitem:gacd7e1e07253e568044a204a1f82d36a1" id="r_gacd7e1e07253e568044a204a1f82d36a1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacd7e1e07253e568044a204a1f82d36a1">MSG_TYPE_FED_RESPONSE</a>&#160;&#160;&#160;102</td></tr>
<tr class="memdesc:gacd7e1e07253e568044a204a1f82d36a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte identifying a message from federate to RTI as a response to the RTI_RESPONSE message.  <br /></td></tr>
<tr class="memitem:gada47c9f6736992a3df380526d87089f9" id="r_gada47c9f6736992a3df380526d87089f9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gada47c9f6736992a3df380526d87089f9">MSG_TYPE_LATEST_TAG_CONFIRMED</a>&#160;&#160;&#160;9</td></tr>
<tr class="memdesc:gada47c9f6736992a3df380526d87089f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte identifying a latest tag confirmed (LTC) message sent by a federate to the RTI.  <br /></td></tr>
<tr class="memitem:gac79b5228f132029285408a30a31a174e" id="r_gac79b5228f132029285408a30a31a174e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac79b5228f132029285408a30a31a174e">MSG_TYPE_MESSAGE</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:gac79b5228f132029285408a30a31a174e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte identifying a message to forward to another federate.  <br /></td></tr>
<tr class="memitem:ga48ec489cb1543b161c262f4bee6c9598" id="r_ga48ec489cb1543b161c262f4bee6c9598"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga48ec489cb1543b161c262f4bee6c9598">MSG_TYPE_NEIGHBOR_STRUCTURE</a>&#160;&#160;&#160;24</td></tr>
<tr class="memdesc:ga48ec489cb1543b161c262f4bee6c9598"><td class="mdescLeft">&#160;</td><td class="mdescRight">A message that informs the RTI about connections between this federate and other federates where messages are routed through the RTI.  <br /></td></tr>
<tr class="memitem:ga77a9c1b741d7ca0f4e8d00a5b74ef91e" id="r_ga77a9c1b741d7ca0f4e8d00a5b74ef91e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga77a9c1b741d7ca0f4e8d00a5b74ef91e">MSG_TYPE_NEIGHBOR_STRUCTURE_HEADER_SIZE</a>&#160;&#160;&#160;9</td></tr>
<tr class="memdesc:ga77a9c1b741d7ca0f4e8d00a5b74ef91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of the header of a neighbor structure message.  <br /></td></tr>
<tr class="memitem:gaf662a6a84cd64cddad92e20e26af877e" id="r_gaf662a6a84cd64cddad92e20e26af877e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf662a6a84cd64cddad92e20e26af877e">MSG_TYPE_NEXT_EVENT_TAG</a>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:gaf662a6a84cd64cddad92e20e26af877e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte identifying a next event tag (NET) message sent from a federate in centralized coordination.  <br /></td></tr>
<tr class="memitem:ga2b9f13f8df66448bf81ac5fe0774c124" id="r_ga2b9f13f8df66448bf81ac5fe0774c124"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2b9f13f8df66448bf81ac5fe0774c124">MSG_TYPE_P2P_MESSAGE</a>&#160;&#160;&#160;17</td></tr>
<tr class="memdesc:ga2b9f13f8df66448bf81ac5fe0774c124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte identifying a message to send directly to another federate.  <br /></td></tr>
<tr class="memitem:gacd33bbab7bf74e5ac8bad3bd27145f8b" id="r_gacd33bbab7bf74e5ac8bad3bd27145f8b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacd33bbab7bf74e5ac8bad3bd27145f8b">MSG_TYPE_P2P_SENDING_FED_ID</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:gacd33bbab7bf74e5ac8bad3bd27145f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte identifying a first message that is sent by a federate directly to another federate after establishing a socket connection to send messages directly to the federate.  <br /></td></tr>
<tr class="memitem:ga5c1256c8c62fbbcb1b16ea67d8f529fb" id="r_ga5c1256c8c62fbbcb1b16ea67d8f529fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5c1256c8c62fbbcb1b16ea67d8f529fb">MSG_TYPE_P2P_TAGGED_MESSAGE</a>&#160;&#160;&#160;18</td></tr>
<tr class="memdesc:ga5c1256c8c62fbbcb1b16ea67d8f529fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte identifying a timestamped message to send directly to another federate.  <br /></td></tr>
<tr class="memitem:gadb9610b1edbee4c85e194e391a6eeb74" id="r_gadb9610b1edbee4c85e194e391a6eeb74"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadb9610b1edbee4c85e194e391a6eeb74">MSG_TYPE_PORT_ABSENT</a>&#160;&#160;&#160;23</td></tr>
<tr class="memdesc:gadb9610b1edbee4c85e194e391a6eeb74"><td class="mdescLeft">&#160;</td><td class="mdescRight">A port absent message, informing the receiver that a given port will not have event for the current logical time.  <br /></td></tr>
<tr class="memitem:ga9a9bb60d4df1ba581a29319850097cc2" id="r_ga9a9bb60d4df1ba581a29319850097cc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9a9bb60d4df1ba581a29319850097cc2">MSG_TYPE_PROVISIONAL_TAG_ADVANCE_GRANT</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:ga9a9bb60d4df1ba581a29319850097cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte identifying a provisional time advance grant (PTAG) sent by the RTI to a federate in centralized coordination.  <br /></td></tr>
<tr class="memitem:ga59a69d0685fdc2a216718f1efa083c4c" id="r_ga59a69d0685fdc2a216718f1efa083c4c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga59a69d0685fdc2a216718f1efa083c4c">MSG_TYPE_REJECT</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga59a69d0685fdc2a216718f1efa083c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte identifying a rejection of the previously received message.  <br /></td></tr>
<tr class="memitem:ga9e19e307a4c3a9dbccea4f2539cd67dd" id="r_ga9e19e307a4c3a9dbccea4f2539cd67dd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9e19e307a4c3a9dbccea4f2539cd67dd">MSG_TYPE_RESIGN</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:ga9e19e307a4c3a9dbccea4f2539cd67dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte identifying that the federate or the RTI is ending its execution.  <br /></td></tr>
<tr class="memitem:ga20f24b4b20547d44523120689afd9b98" id="r_ga20f24b4b20547d44523120689afd9b98"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga20f24b4b20547d44523120689afd9b98">MSG_TYPE_RTI_RESPONSE</a>&#160;&#160;&#160;101</td></tr>
<tr class="memdesc:ga20f24b4b20547d44523120689afd9b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte identifying a message from RTI to federate as a response to the FED_NONCE message.  <br /></td></tr>
<tr class="memitem:gaad37dd00423e88f213ca7d7d238bce2e" id="r_gaad37dd00423e88f213ca7d7d238bce2e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaad37dd00423e88f213ca7d7d238bce2e">MSG_TYPE_STOP_GRANTED</a>&#160;&#160;&#160;12</td></tr>
<tr class="memdesc:gaad37dd00423e88f213ca7d7d238bce2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte sent by the RTI indicating that the stop request from some federate has been granted.  <br /></td></tr>
<tr class="memitem:ga76275384e9865f1f1ed32408c03d876a" id="r_ga76275384e9865f1f1ed32408c03d876a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga76275384e9865f1f1ed32408c03d876a">MSG_TYPE_STOP_GRANTED_LENGTH</a>&#160;&#160;&#160;(1 + sizeof(<a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a>) + sizeof(<a class="el" href="group__API.html#gad88f1caa8b9c216404eb196cb1850213">microstep_t</a>))</td></tr>
<tr class="memdesc:ga76275384e9865f1f1ed32408c03d876a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The length of a stop granted message.  <br /></td></tr>
<tr class="memitem:gaa3ed75054ae1aaa64dafa6399f7a23cb" id="r_gaa3ed75054ae1aaa64dafa6399f7a23cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa3ed75054ae1aaa64dafa6399f7a23cb">MSG_TYPE_STOP_REQUEST_LENGTH</a>&#160;&#160;&#160;(1 + sizeof(<a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a>) + sizeof(<a class="el" href="group__API.html#gad88f1caa8b9c216404eb196cb1850213">microstep_t</a>))</td></tr>
<tr class="memdesc:gaa3ed75054ae1aaa64dafa6399f7a23cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The length of a stop request message.  <br /></td></tr>
<tr class="memitem:gaa62d9986e928cb5e872caa6a509cae6c" id="r_gaa62d9986e928cb5e872caa6a509cae6c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa62d9986e928cb5e872caa6a509cae6c">MSG_TYPE_STOP_REQUEST_REPLY_LENGTH</a>&#160;&#160;&#160;(1 + sizeof(<a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a>) + sizeof(<a class="el" href="group__API.html#gad88f1caa8b9c216404eb196cb1850213">microstep_t</a>))</td></tr>
<tr class="memdesc:gaa62d9986e928cb5e872caa6a509cae6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The length of a stop request reply message.  <br /></td></tr>
<tr class="memitem:ga94fe2c510160682b2c0ffc00b35e0ad5" id="r_ga94fe2c510160682b2c0ffc00b35e0ad5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga94fe2c510160682b2c0ffc00b35e0ad5">MSG_TYPE_TAG_ADVANCE_GRANT</a>&#160;&#160;&#160;7</td></tr>
<tr class="memdesc:ga94fe2c510160682b2c0ffc00b35e0ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte identifying a time advance grant (TAG) sent by the RTI to a federate in centralized coordination.  <br /></td></tr>
<tr class="memitem:ga2922af172f2e95bc73bd0675a4107b3b" id="r_ga2922af172f2e95bc73bd0675a4107b3b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2922af172f2e95bc73bd0675a4107b3b">MSG_TYPE_TAGGED_MESSAGE</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:ga2922af172f2e95bc73bd0675a4107b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte identifying a timestamped message to forward to another federate.  <br /></td></tr>
<tr class="memitem:ga27db349e7460afc1758bf2eec95d7005" id="r_ga27db349e7460afc1758bf2eec95d7005"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga27db349e7460afc1758bf2eec95d7005">MSG_TYPE_TIMESTAMP</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ga27db349e7460afc1758bf2eec95d7005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte identifying a timestamp message, which is 64 bits long.  <br /></td></tr>
<tr class="memitem:ga3450aedd1ca1c368ed28ed2e859588ef" id="r_ga3450aedd1ca1c368ed28ed2e859588ef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3450aedd1ca1c368ed28ed2e859588ef">MSG_TYPE_TIMESTAMP_LENGTH</a>&#160;&#160;&#160;(1 + sizeof(int64_t))</td></tr>
<tr class="memdesc:ga3450aedd1ca1c368ed28ed2e859588ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">The length of a timestamp message.  <br /></td></tr>
<tr class="memitem:gae2c2fdb5fbcc47750409348d37b0cd78" id="r_gae2c2fdb5fbcc47750409348d37b0cd78"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae2c2fdb5fbcc47750409348d37b0cd78">MSG_TYPE_UDP_PORT</a>&#160;&#160;&#160;254</td></tr>
<tr class="memdesc:gae2c2fdb5fbcc47750409348d37b0cd78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte identifying an acknowledgment of the previously received MSG_TYPE_FED_IDS message.  <br /></td></tr>
<tr class="memitem:ga6771c37605e49c8faae7898797f254b7" id="r_ga6771c37605e49c8faae7898797f254b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6771c37605e49c8faae7898797f254b7">NONCE_LENGTH</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:ga6771c37605e49c8faae7898797f254b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The randomly created nonce size will be 8 bytes.  <br /></td></tr>
<tr class="memitem:gaf58c457e08491f7cfd5a0a46940e11ad" id="r_gaf58c457e08491f7cfd5a0a46940e11ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf58c457e08491f7cfd5a0a46940e11ad">NUMBER_OF_FEDERATES</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gaf58c457e08491f7cfd5a0a46940e11ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of federates.  <br /></td></tr>
<tr class="memitem:gaf11c9d6cd02e9e78e38a848cf75205cb" id="r_gaf11c9d6cd02e9e78e38a848cf75205cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf11c9d6cd02e9e78e38a848cf75205cb">PORT_BIND_RETRY_INTERVAL</a>&#160;&#160;&#160;<a class="el" href="group__Constants.html#ga30e47c4dd44d168c2982d3ec1d4e0825">SEC</a>(1)</td></tr>
<tr class="memdesc:gaf11c9d6cd02e9e78e38a848cf75205cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time to wait before re-attempting to bind to a port.  <br /></td></tr>
<tr class="memitem:ga04c08dc0b0733010f3190bf6df123433" id="r_ga04c08dc0b0733010f3190bf6df123433"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga04c08dc0b0733010f3190bf6df123433">PORT_BIND_RETRY_LIMIT</a>&#160;&#160;&#160;60</td></tr>
<tr class="memdesc:ga04c08dc0b0733010f3190bf6df123433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of attempts to bind to a port before giving up.  <br /></td></tr>
<tr class="memitem:gae546b6c6176fe607616181e144364f2b" id="r_gae546b6c6176fe607616181e144364f2b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae546b6c6176fe607616181e144364f2b">RTI_NOT_EXECUTED_WITH_AUTH</a>&#160;&#160;&#160;7</td></tr>
<tr class="memdesc:gae546b6c6176fe607616181e144364f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code sent with a <a class="el" href="#ga59a69d0685fdc2a216718f1efa083c4c">MSG_TYPE_REJECT</a> message indicating that the RTI was not executed using the -a or &ndash;auth option.  <br /></td></tr>
<tr class="memitem:gabd435507a255ff2571133013bdf93bd2" id="r_gabd435507a255ff2571133013bdf93bd2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabd435507a255ff2571133013bdf93bd2">SHA256_HMAC_LENGTH</a>&#160;&#160;&#160;32</td></tr>
<tr class="memdesc:gabd435507a255ff2571133013bdf93bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HMAC tag uses the SHA256 hash algorithm, creating a 32 byte length hash tag.  <br /></td></tr>
<tr class="memitem:gab1edbb864391382835b9ad71408c5c53" id="r_gab1edbb864391382835b9ad71408c5c53"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab1edbb864391382835b9ad71408c5c53">TCP_TIMEOUT_TIME</a>&#160;&#160;&#160;<a class="el" href="group__Constants.html#ga30e47c4dd44d168c2982d3ec1d4e0825">SEC</a>(10)</td></tr>
<tr class="memdesc:gab1edbb864391382835b9ad71408c5c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">The timeout time in ns for TCP operations.  <br /></td></tr>
<tr class="memitem:gaac9f4a449d302b4f39e69a14b3a4c8d5" id="r_gaac9f4a449d302b4f39e69a14b3a4c8d5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaac9f4a449d302b4f39e69a14b3a4c8d5">UDP_TIMEOUT_TIME</a>&#160;&#160;&#160;<a class="el" href="group__Constants.html#ga30e47c4dd44d168c2982d3ec1d4e0825">SEC</a>(1)</td></tr>
<tr class="memdesc:gaac9f4a449d302b4f39e69a14b3a4c8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The timeout time in ns for UDP operations.  <br /></td></tr>
<tr class="memitem:gae2e1a44a10d4219f4645a4e99fee009c" id="r_gae2e1a44a10d4219f4645a4e99fee009c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae2e1a44a10d4219f4645a4e99fee009c">UNEXPECTED_MESSAGE</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:gae2e1a44a10d4219f4645a4e99fee009c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code sent with a <a class="el" href="#ga59a69d0685fdc2a216718f1efa083c4c">MSG_TYPE_REJECT</a> message indicating that the incoming message is not expected.  <br /></td></tr>
<tr class="memitem:ga5a6c87886a0136b58ae5bb1d627c7ae3" id="r_ga5a6c87886a0136b58ae5bb1d627c7ae3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5a6c87886a0136b58ae5bb1d627c7ae3">WRONG_SERVER</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:ga5a6c87886a0136b58ae5bb1d627c7ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code sent with a <a class="el" href="#ga59a69d0685fdc2a216718f1efa083c4c">MSG_TYPE_REJECT</a> message indicating that the connected to the wrong server.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga675c841ec6a29e45cacc71b61ef8d270" id="r_ga675c841ec6a29e45cacc71b61ef8d270"><td class="memItemLeft" align="right" valign="top">typedef struct federate_instance_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga675c841ec6a29e45cacc71b61ef8d270">federate_instance_t</a></td></tr>
<tr class="memdesc:ga675c841ec6a29e45cacc71b61ef8d270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that a federate instance uses to keep track of its own state.  <br /></td></tr>
<tr class="memitem:gae335f4cb4e7d5e88ed712be8cf9592ac" id="r_gae335f4cb4e7d5e88ed712be8cf9592ac"><td class="memItemLeft" align="right" valign="top">typedef struct federation_metadata_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae335f4cb4e7d5e88ed712be8cf9592ac">federation_metadata_t</a></td></tr>
<tr class="memdesc:gae335f4cb4e7d5e88ed712be8cf9592ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for federation metadata.  <br /></td></tr>
<tr class="memitem:ga9e708b16d53622a88d5a2638affb6934" id="r_ga9e708b16d53622a88d5a2638affb6934"><td class="memItemLeft" align="right" valign="top">typedef struct lf_stat_ll&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9e708b16d53622a88d5a2638affb6934">lf_stat_ll</a></td></tr>
<tr class="memdesc:ga9e708b16d53622a88d5a2638affb6934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds generic statistical data.  <br /></td></tr>
<tr class="memitem:ga98d812b2acffbba5c8b1b72913513d19" id="r_ga98d812b2acffbba5c8b1b72913513d19"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="#ga9acb70e6b48452bd9d146e35bafc535c">parse_rti_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga98d812b2acffbba5c8b1b72913513d19">parse_rti_code_t</a></td></tr>
<tr class="memdesc:ga98d812b2acffbba5c8b1b72913513d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code returned by <a class="el" href="#gae612f180643d0436d4496738b957af68">lf_parse_rti_addr()</a>.  <br /></td></tr>
<tr class="memitem:gaf820f39ab52ce0a58d7ba739051b8f24" id="r_gaf820f39ab52ce0a58d7ba739051b8f24"><td class="memItemLeft" align="right" valign="top">typedef struct rti_addr_info_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf820f39ab52ce0a58d7ba739051b8f24">rti_addr_info_t</a></td></tr>
<tr class="memdesc:gaf820f39ab52ce0a58d7ba739051b8f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper struct for passing rti_addr information between lf_parse_rti_addr and extract_rti_addr_info.  <br /></td></tr>
<tr class="memitem:ga7e49fed082ec884e26d761e1c4f0d428" id="r_ga7e49fed082ec884e26d761e1c4f0d428"><td class="memItemLeft" align="right" valign="top">typedef struct socket_stat_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7e49fed082ec884e26d761e1c4f0d428">socket_stat_t</a></td></tr>
<tr class="memdesc:ga7e49fed082ec884e26d761e1c4f0d428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Statistics and state for clock synchronization over a socket connection.  <br /></td></tr>
<tr class="memitem:ga45bb50f52b617bc6a30719cbaafd075d" id="r_ga45bb50f52b617bc6a30719cbaafd075d"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="#ga54c375e3893ff5969d20df65b90c8335">socket_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga45bb50f52b617bc6a30719cbaafd075d">socket_type_t</a></td></tr>
<tr class="memdesc:ga45bb50f52b617bc6a30719cbaafd075d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of socket.  <br /></td></tr>
<tr class="memitem:ga0bce8f0d13040846780f5bb02e43e81d" id="r_ga0bce8f0d13040846780f5bb02e43e81d"><td class="memItemLeft" align="right" valign="top">typedef struct staa_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0bce8f0d13040846780f5bb02e43e81d">staa_t</a></td></tr>
<tr class="memdesc:ga0bce8f0d13040846780f5bb02e43e81d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for STAA (safe to assume absent).  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga9acb70e6b48452bd9d146e35bafc535c" id="r_ga9acb70e6b48452bd9d146e35bafc535c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9acb70e6b48452bd9d146e35bafc535c">parse_rti_code_t</a> { <br />
&#160;&#160;<a class="el" href="#gga9acb70e6b48452bd9d146e35bafc535cac7f69f7c9e5aea9b8f54cf02870e2bf8">SUCCESS</a>
, <a class="el" href="#gga9acb70e6b48452bd9d146e35bafc535cad65c958d0ccb000b69ef0ef4e3a5bfdf">INVALID_PORT</a>
, <a class="el" href="#gga9acb70e6b48452bd9d146e35bafc535caea85d37354b294f21e7ab9c5c142a237">INVALID_HOST</a>
, <a class="el" href="#gga9acb70e6b48452bd9d146e35bafc535ca1dbf923bd60da7209a684ed484935973">INVALID_USER</a>
, <br />
&#160;&#160;<a class="el" href="#gga9acb70e6b48452bd9d146e35bafc535ca3ad4ab464aba04397206e8b89aa1955a">FAILED_TO_PARSE</a>
<br />
 }</td></tr>
<tr class="memdesc:ga9acb70e6b48452bd9d146e35bafc535c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code returned by <a class="el" href="#gae612f180643d0436d4496738b957af68">lf_parse_rti_addr()</a>.  <a href="#ga9acb70e6b48452bd9d146e35bafc535c">More...</a><br /></td></tr>
<tr class="memitem:ga54c375e3893ff5969d20df65b90c8335" id="r_ga54c375e3893ff5969d20df65b90c8335"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga54c375e3893ff5969d20df65b90c8335">socket_type_t</a> { <a class="el" href="#gga54c375e3893ff5969d20df65b90c8335aa040cd7feeb588104634cdadf35abf1c">TCP</a>
, <a class="el" href="#gga54c375e3893ff5969d20df65b90c8335adb542475cf9d0636e4225e216cee9ae6">UDP</a>
 }</td></tr>
<tr class="memdesc:ga54c375e3893ff5969d20df65b90c8335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of socket.  <a href="#ga54c375e3893ff5969d20df65b90c8335">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3f3dfc2ccd62e181467f7a22ab5ebe49" id="r_ga3f3dfc2ccd62e181467f7a22ab5ebe49"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3f3dfc2ccd62e181467f7a22ab5ebe49">accept_socket</a> (int socket, int rti_socket)</td></tr>
<tr class="memdesc:ga3f3dfc2ccd62e181467f7a22ab5ebe49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for an incoming connection request on the specified server socket.  <br /></td></tr>
<tr class="memitem:ga6b3edec4d337711a2e914c9f5581ce1c" id="r_ga6b3edec4d337711a2e914c9f5581ce1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6b3edec4d337711a2e914c9f5581ce1c">clock_sync_add_offset</a> (<a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a> *t)</td></tr>
<tr class="memdesc:ga6b3edec4d337711a2e914c9f5581ce1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the current clock synchronization offset to a specified timestamp.  <br /></td></tr>
<tr class="memitem:ga4f1aaaa9e0b74867ba6b60eb962dfca6" id="r_ga4f1aaaa9e0b74867ba6b60eb962dfca6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4f1aaaa9e0b74867ba6b60eb962dfca6">clock_sync_set_constant_bias</a> (<a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> offset)</td></tr>
<tr class="memdesc:ga4f1aaaa9e0b74867ba6b60eb962dfca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a fixed offset to the physical clock.  <br /></td></tr>
<tr class="memitem:gaf5fb44eb0db80b9dfa61399bdab8b85c" id="r_gaf5fb44eb0db80b9dfa61399bdab8b85c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf5fb44eb0db80b9dfa61399bdab8b85c">clock_sync_subtract_offset</a> (<a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a> *t)</td></tr>
<tr class="memdesc:gaf5fb44eb0db80b9dfa61399bdab8b85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract the clock synchronization offset from a timestamp.  <br /></td></tr>
<tr class="memitem:ga5ac5b1b8bf1c832cbdd2f6cdbb769df8" id="r_ga5ac5b1b8bf1c832cbdd2f6cdbb769df8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5ac5b1b8bf1c832cbdd2f6cdbb769df8">connect_to_socket</a> (int sock, const char *hostname, int port)</td></tr>
<tr class="memdesc:ga5ac5b1b8bf1c832cbdd2f6cdbb769df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to establish a TCP connection to the specified hostname and port.  <br /></td></tr>
<tr class="memitem:gac094b53ced87d3cbd617a66591f4282a" id="r_gac094b53ced87d3cbd617a66591f4282a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac094b53ced87d3cbd617a66591f4282a">create_clock_sync_thread</a> (lf_thread_t *thread_id)</td></tr>
<tr class="memdesc:gac094b53ced87d3cbd617a66591f4282a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the thread responsible for handling clock synchronization with the RTI if (runtime) clock synchronization is on.  <br /></td></tr>
<tr class="memitem:ga10b0373c1cff0213b17cb7308949f0a2" id="r_ga10b0373c1cff0213b17cb7308949f0a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga10b0373c1cff0213b17cb7308949f0a2">create_real_time_tcp_socket_errexit</a> ()</td></tr>
<tr class="memdesc:ga10b0373c1cff0213b17cb7308949f0a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an IPv4 TCP socket with Nagle's algorithm disabled.  <br /></td></tr>
<tr class="memitem:ga94aaee169c4c822e4c9e6a73f59a6952" id="r_ga94aaee169c4c822e4c9e6a73f59a6952"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga94aaee169c4c822e4c9e6a73f59a6952">create_server</a> (uint16_t port, int *final_socket, uint16_t *final_port, <a class="el" href="#ga54c375e3893ff5969d20df65b90c8335">socket_type_t</a> sock_type, bool increment_port_on_retry)</td></tr>
<tr class="memdesc:ga94aaee169c4c822e4c9e6a73f59a6952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a TCP server that listens for socket connections.  <br /></td></tr>
<tr class="memitem:gafc6b3d0e0e777738422c11fa07b35e0f" id="r_gafc6b3d0e0e777738422c11fa07b35e0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafc6b3d0e0e777738422c11fa07b35e0f">encode_int32</a> (int32_t data, unsigned char *buffer)</td></tr>
<tr class="memdesc:gafc6b3d0e0e777738422c11fa07b35e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the specified data as a sequence of bytes starting at the specified address.  <br /></td></tr>
<tr class="memitem:gae233fa02382ed619a78b1c32e14a8657" id="r_gae233fa02382ed619a78b1c32e14a8657"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae233fa02382ed619a78b1c32e14a8657">encode_int64</a> (int64_t data, unsigned char *buffer)</td></tr>
<tr class="memdesc:gae233fa02382ed619a78b1c32e14a8657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the specified data as a sequence of bytes starting at the specified address.  <br /></td></tr>
<tr class="memitem:ga7b5ae6582f28e14a37d50a2d243613c5" id="r_ga7b5ae6582f28e14a37d50a2d243613c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7b5ae6582f28e14a37d50a2d243613c5">encode_tag</a> (unsigned char *buffer, <a class="el" href="structtag__t.html">tag_t</a> tag)</td></tr>
<tr class="memdesc:ga7b5ae6582f28e14a37d50a2d243613c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode tag information into buffer.  <br /></td></tr>
<tr class="memitem:gafad4dadc9bbc06596be44e7ecc4c7281" id="r_gafad4dadc9bbc06596be44e7ecc4c7281"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafad4dadc9bbc06596be44e7ecc4c7281">encode_uint16</a> (uint16_t data, unsigned char *buffer)</td></tr>
<tr class="memdesc:gafad4dadc9bbc06596be44e7ecc4c7281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the specified data as a sequence of bytes starting at the specified address.  <br /></td></tr>
<tr class="memitem:ga9b75c9d94d4f3d34d52f46c65cf950d4" id="r_ga9b75c9d94d4f3d34d52f46c65cf950d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9b75c9d94d4f3d34d52f46c65cf950d4">encode_uint32</a> (uint32_t data, unsigned char *buffer)</td></tr>
<tr class="memdesc:ga9b75c9d94d4f3d34d52f46c65cf950d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the specified data as a sequence of bytes starting at the specified address.  <br /></td></tr>
<tr class="memitem:ga82060dae45e1c3b922005e56829c9814" id="r_ga82060dae45e1c3b922005e56829c9814"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga82060dae45e1c3b922005e56829c9814">extract_header</a> (unsigned char *buffer, uint16_t *port_id, uint16_t *federate_id, size_t *length)</td></tr>
<tr class="memdesc:ga82060dae45e1c3b922005e56829c9814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the core header information that all messages between federates share.  <br /></td></tr>
<tr class="memitem:ga8f772b5761c6b74b4136db6ee021e6c5" id="r_ga8f772b5761c6b74b4136db6ee021e6c5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8f772b5761c6b74b4136db6ee021e6c5">extract_int32</a> (unsigned char *bytes)</td></tr>
<tr class="memdesc:ga8f772b5761c6b74b4136db6ee021e6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will swap the order of the bytes if this machine is big endian.  <br /></td></tr>
<tr class="memitem:ga8decc0f4a38aa42fbc6ccfb029e3a061" id="r_ga8decc0f4a38aa42fbc6ccfb029e3a061"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8decc0f4a38aa42fbc6ccfb029e3a061">extract_int64</a> (unsigned char *bytes)</td></tr>
<tr class="memdesc:ga8decc0f4a38aa42fbc6ccfb029e3a061"><td class="mdescLeft">&#160;</td><td class="mdescRight">This will swap the order of the bytes if this machine is big endian.  <br /></td></tr>
<tr class="memitem:ga8ec38908b111a79943446bfbdec188f0" id="r_ga8ec38908b111a79943446bfbdec188f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8ec38908b111a79943446bfbdec188f0">extract_match_group</a> (const char *rti_addr, char *dest, regmatch_t group, size_t max_len, size_t min_len, const char *err_msg)</td></tr>
<tr class="memdesc:ga8ec38908b111a79943446bfbdec188f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract one match group from the rti_addr regex .  <br /></td></tr>
<tr class="memitem:ga50c7f94caa2a61bcba5f89535da07036" id="r_ga50c7f94caa2a61bcba5f89535da07036"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga50c7f94caa2a61bcba5f89535da07036">extract_match_groups</a> (const char *rti_addr, char **rti_addr_strs, bool **rti_addr_flags, regmatch_t *group_array, int *gids, size_t *max_lens, size_t *min_lens, const char **err_msgs)</td></tr>
<tr class="memdesc:ga50c7f94caa2a61bcba5f89535da07036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract match groups from the rti_addr regex.  <br /></td></tr>
<tr class="memitem:ga0737fc3d45aae606811f57a16ad87208" id="r_ga0737fc3d45aae606811f57a16ad87208"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0737fc3d45aae606811f57a16ad87208">extract_rti_addr_info</a> (const char *rti_addr, <a class="el" href="structrti__addr__info__t.html">rti_addr_info_t</a> *rti_addr_info)</td></tr>
<tr class="memdesc:ga0737fc3d45aae606811f57a16ad87208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the host, port and user from rti_addr.  <br /></td></tr>
<tr class="memitem:ga9cd95311c2c29ce5bed1c44d5336584d" id="r_ga9cd95311c2c29ce5bed1c44d5336584d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9cd95311c2c29ce5bed1c44d5336584d">extract_tag</a> (unsigned char *buffer)</td></tr>
<tr class="memdesc:ga9cd95311c2c29ce5bed1c44d5336584d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract tag information from buffer.  <br /></td></tr>
<tr class="memitem:ga8e2cc45fc8571af05bb05f4952d4cde5" id="r_ga8e2cc45fc8571af05bb05f4952d4cde5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8e2cc45fc8571af05bb05f4952d4cde5">extract_timed_header</a> (unsigned char *buffer, uint16_t *port_id, uint16_t *federate_id, size_t *length, <a class="el" href="structtag__t.html">tag_t</a> *tag)</td></tr>
<tr class="memdesc:ga8e2cc45fc8571af05bb05f4952d4cde5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the timed header information for timed messages between federates.  <br /></td></tr>
<tr class="memitem:ga1686d838d49741a6ff2ee65bd766a987" id="r_ga1686d838d49741a6ff2ee65bd766a987"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1686d838d49741a6ff2ee65bd766a987">extract_uint16</a> (unsigned char *bytes)</td></tr>
<tr class="memdesc:ga1686d838d49741a6ff2ee65bd766a987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract an uint16_t from the specified byte sequence.  <br /></td></tr>
<tr class="memitem:gace14df89540b56b069c6c619e8f37493" id="r_gace14df89540b56b069c6c619e8f37493"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gace14df89540b56b069c6c619e8f37493">handle_T1_clock_sync_message</a> (unsigned char *buffer, int socket, <a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a> t2)</td></tr>
<tr class="memdesc:gace14df89540b56b069c6c619e8f37493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle a clock synchroninzation message T1 coming from the RTI.  <br /></td></tr>
<tr class="memitem:ga1b35d21eda090ea4bf8a79f401dbdad0" id="r_ga1b35d21eda090ea4bf8a79f401dbdad0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1b35d21eda090ea4bf8a79f401dbdad0">handle_T4_clock_sync_message</a> (unsigned char *buffer, int socket, <a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a> r4)</td></tr>
<tr class="memdesc:ga1b35d21eda090ea4bf8a79f401dbdad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle a clock synchronization message T4 coming from the RTI.  <br /></td></tr>
<tr class="memitem:gad791461950852eb074b90bc75156b413" id="r_gad791461950852eb074b90bc75156b413"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad791461950852eb074b90bc75156b413">host_is_big_endian</a> (void)</td></tr>
<tr class="memdesc:gad791461950852eb074b90bc75156b413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true (1) if the host is big endian.  <br /></td></tr>
<tr class="memitem:gadc2dc02aa0e242eab3574240e90984b4" id="r_gadc2dc02aa0e242eab3574240e90984b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadc2dc02aa0e242eab3574240e90984b4">init_shutdown_mutex</a> (void)</td></tr>
<tr class="memdesc:gadc2dc02aa0e242eab3574240e90984b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize shutdown mutex.  <br /></td></tr>
<tr class="memitem:ga26b7c3ab8c2a50f65e53997a6f26a0dc" id="r_ga26b7c3ab8c2a50f65e53997a6f26a0dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga26b7c3ab8c2a50f65e53997a6f26a0dc">lf_connect_to_federate</a> (uint16_t remote_federate_id)</td></tr>
<tr class="memdesc:ga26b7c3ab8c2a50f65e53997a6f26a0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to the federate with the specified id.  <br /></td></tr>
<tr class="memitem:ga92e8c30255091911a80601bf341cf0a2" id="r_ga92e8c30255091911a80601bf341cf0a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga92e8c30255091911a80601bf341cf0a2">lf_connect_to_rti</a> (const char *hostname, int port_number)</td></tr>
<tr class="memdesc:ga92e8c30255091911a80601bf341cf0a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to the RTI at the specified host and port.  <br /></td></tr>
<tr class="memitem:ga926a4fb7f9b045acb13fee6c2b7192dd" id="r_ga926a4fb7f9b045acb13fee6c2b7192dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga926a4fb7f9b045acb13fee6c2b7192dd">lf_create_server</a> (int specified_port)</td></tr>
<tr class="memdesc:ga926a4fb7f9b045acb13fee6c2b7192dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a server to listen to incoming P2P connections.  <br /></td></tr>
<tr class="memitem:gae427b4c0340dbe19d46c93708fb6151a" id="r_gae427b4c0340dbe19d46c93708fb6151a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae427b4c0340dbe19d46c93708fb6151a">lf_enqueue_port_absent_reactions</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env)</td></tr>
<tr class="memdesc:gae427b4c0340dbe19d46c93708fb6151a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue port absent reactions.  <br /></td></tr>
<tr class="memitem:gab4b57d55b69a4864eb694ed080b84d0e" id="r_gab4b57d55b69a4864eb694ed080b84d0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab4b57d55b69a4864eb694ed080b84d0e">lf_get_fed_maxwait</a> (void)</td></tr>
<tr class="memdesc:gab4b57d55b69a4864eb694ed080b84d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the global maxwait for the current federate.  <br /></td></tr>
<tr class="memitem:gae03d197bf8d64f82be4a68c95a940195" id="r_gae03d197bf8d64f82be4a68c95a940195"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae03d197bf8d64f82be4a68c95a940195">lf_get_sta</a> (void)</td></tr>
<tr class="memdesc:gae03d197bf8d64f82be4a68c95a940195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the global STA (safe to advance) offset for federated execution.  <br /></td></tr>
<tr class="memitem:gaf7ba635fb6ffa82e4b05a51d4fc0020f" id="r_gaf7ba635fb6ffa82e4b05a51d4fc0020f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf7ba635fb6ffa82e4b05a51d4fc0020f">lf_handle_p2p_connections_from_federates</a> (void *ignored)</td></tr>
<tr class="memdesc:gaf7ba635fb6ffa82e4b05a51d4fc0020f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread to accept connections from other federates.  <br /></td></tr>
<tr class="memitem:ga80af1b6a9d7200df3d85c534edd8cbbc" id="r_ga80af1b6a9d7200df3d85c534edd8cbbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga80af1b6a9d7200df3d85c534edd8cbbc">lf_latest_tag_confirmed</a> (<a class="el" href="structtag__t.html">tag_t</a> tag_to_send)</td></tr>
<tr class="memdesc:ga80af1b6a9d7200df3d85c534edd8cbbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a latest tag confirmed (LTC) signal to the RTI.  <br /></td></tr>
<tr class="memitem:gae612f180643d0436d4496738b957af68" id="r_gae612f180643d0436d4496738b957af68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga9acb70e6b48452bd9d146e35bafc535c">parse_rti_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae612f180643d0436d4496738b957af68">lf_parse_rti_addr</a> (const char *rti_addr)</td></tr>
<tr class="memdesc:gae612f180643d0436d4496738b957af68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse the address of the RTI and store them into the global federation_metadata struct.  <br /></td></tr>
<tr class="memitem:gae3bc503fcbeaffe48f4500fddba4b21a" id="r_gae3bc503fcbeaffe48f4500fddba4b21a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae3bc503fcbeaffe48f4500fddba4b21a">lf_reset_status_fields_on_input_port_triggers</a> (void)</td></tr>
<tr class="memdesc:gae3bc503fcbeaffe48f4500fddba4b21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the status fields on network input ports to unknown or absent.  <br /></td></tr>
<tr class="memitem:ga2f330bfe2fdb03cbf49596bcc012bc58" id="r_ga2f330bfe2fdb03cbf49596bcc012bc58"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2f330bfe2fdb03cbf49596bcc012bc58">lf_send_message</a> (int message_type, unsigned short port, unsigned short federate, const char *next_destination_str, size_t length, unsigned char *message)</td></tr>
<tr class="memdesc:ga2f330bfe2fdb03cbf49596bcc012bc58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to another federate.  <br /></td></tr>
<tr class="memitem:ga131226459d7dacc6068c0a6d1d9ebde1" id="r_ga131226459d7dacc6068c0a6d1d9ebde1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga131226459d7dacc6068c0a6d1d9ebde1">lf_send_neighbor_structure_to_RTI</a> (int socket_TCP_RTI)</td></tr>
<tr class="memdesc:ga131226459d7dacc6068c0a6d1d9ebde1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send information about connections to the RTI.  <br /></td></tr>
<tr class="memitem:ga33d69f68b22b5143c029f463d6efba4f" id="r_ga33d69f68b22b5143c029f463d6efba4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga33d69f68b22b5143c029f463d6efba4f">lf_send_next_event_tag</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env, <a class="el" href="structtag__t.html">tag_t</a> tag, bool wait_for_reply)</td></tr>
<tr class="memdesc:ga33d69f68b22b5143c029f463d6efba4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a next event tag (NET) signal.  <br /></td></tr>
<tr class="memitem:ga527e8cd401ba68b503403706815ed1a0" id="r_ga527e8cd401ba68b503403706815ed1a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga527e8cd401ba68b503403706815ed1a0">lf_send_port_absent_to_federate</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env, <a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> additional_delay, unsigned short port_ID, unsigned short fed_ID)</td></tr>
<tr class="memdesc:ga527e8cd401ba68b503403706815ed1a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a port absent message.  <br /></td></tr>
<tr class="memitem:gab4d7e691d4b52f2c0dac90e772d86dd5" id="r_gab4d7e691d4b52f2c0dac90e772d86dd5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab4d7e691d4b52f2c0dac90e772d86dd5">lf_send_stop_request_to_rti</a> (<a class="el" href="structtag__t.html">tag_t</a> stop_tag)</td></tr>
<tr class="memdesc:gab4d7e691d4b52f2c0dac90e772d86dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a MSG_TYPE_STOP_REQUEST message to the RTI.  <br /></td></tr>
<tr class="memitem:ga0931fe1bb9eac2a9beebe0c0ed03408e" id="r_ga0931fe1bb9eac2a9beebe0c0ed03408e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0931fe1bb9eac2a9beebe0c0ed03408e">lf_send_tagged_message</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env, <a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> additional_delay, int message_type, unsigned short port, unsigned short federate, const char *next_destination_str, size_t length, unsigned char *message)</td></tr>
<tr class="memdesc:ga0931fe1bb9eac2a9beebe0c0ed03408e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a tagged message to the specified port of the specified federate.  <br /></td></tr>
<tr class="memitem:ga952c8552f9e327a465f3db2f72d8415e" id="r_ga952c8552f9e327a465f3db2f72d8415e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga952c8552f9e327a465f3db2f72d8415e">lf_set_fed_maxwait</a> (<a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> offset)</td></tr>
<tr class="memdesc:ga952c8552f9e327a465f3db2f72d8415e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the global maxwait for the current federate.  <br /></td></tr>
<tr class="memitem:ga032d945ee3fd6995a5f7bb15b57f2ddf" id="r_ga032d945ee3fd6995a5f7bb15b57f2ddf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga032d945ee3fd6995a5f7bb15b57f2ddf">lf_set_federation_id</a> (const char *fid)</td></tr>
<tr class="memdesc:ga032d945ee3fd6995a5f7bb15b57f2ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the federation_id of this federate.  <br /></td></tr>
<tr class="memitem:gaccbc0981eff8f1f1726075d2ee4ba0ef" id="r_gaccbc0981eff8f1f1726075d2ee4ba0ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaccbc0981eff8f1f1726075d2ee4ba0ef">lf_set_sta</a> (<a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> offset)</td></tr>
<tr class="memdesc:gaccbc0981eff8f1f1726075d2ee4ba0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the global STA (safe to advance) offset for federated execution.  <br /></td></tr>
<tr class="memitem:ga3aff644df1b85540aa6a3d2997f819c5" id="r_ga3aff644df1b85540aa6a3d2997f819c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3aff644df1b85540aa6a3d2997f819c5">lf_spawn_staa_thread</a> (void)</td></tr>
<tr class="memdesc:ga3aff644df1b85540aa6a3d2997f819c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawn a thread to iterate through STAA structs.  <br /></td></tr>
<tr class="memitem:ga971322f63f26490a27bdd9006c05b8fe" id="r_ga971322f63f26490a27bdd9006c05b8fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga971322f63f26490a27bdd9006c05b8fe">lf_stall_advance_level_federation</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env, size_t level)</td></tr>
<tr class="memdesc:ga971322f63f26490a27bdd9006c05b8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until inputs statuses are known up to and including the specified level.  <br /></td></tr>
<tr class="memitem:gab0f2188d27dfffa9fbbd417bed9305ea" id="r_gab0f2188d27dfffa9fbbd417bed9305ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab0f2188d27dfffa9fbbd417bed9305ea">lf_stall_advance_level_federation_locked</a> (size_t level)</td></tr>
<tr class="memdesc:gab0f2188d27dfffa9fbbd417bed9305ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <a class="el" href="#ga971322f63f26490a27bdd9006c05b8fe" title="Wait until inputs statuses are known up to and including the specified level.">lf_stall_advance_level_federation()</a> that assumes the caller holds the mutex lock.  <br /></td></tr>
<tr class="memitem:ga36681c905141edace5d23ff8d5c8f205" id="r_ga36681c905141edace5d23ff8d5c8f205"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga36681c905141edace5d23ff8d5c8f205">lf_synchronize_with_other_federates</a> (void)</td></tr>
<tr class="memdesc:ga36681c905141edace5d23ff8d5c8f205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize the start with other federates via the RTI.  <br /></td></tr>
<tr class="memitem:ga84e5177d12e705274be1e6652b5d7c01" id="r_ga84e5177d12e705274be1e6652b5d7c01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga84e5177d12e705274be1e6652b5d7c01">lf_update_max_level</a> (<a class="el" href="structtag__t.html">tag_t</a> tag, bool is_provisional)</td></tr>
<tr class="memdesc:ga84e5177d12e705274be1e6652b5d7c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the max level allowed to advance (MLAA).  <br /></td></tr>
<tr class="memitem:gaa0c8d0811c7faae11b9f1a7fcb30f917" id="r_gaa0c8d0811c7faae11b9f1a7fcb30f917"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa0c8d0811c7faae11b9f1a7fcb30f917">lf_wait_until_time</a> (<a class="el" href="structtag__t.html">tag_t</a> tag)</td></tr>
<tr class="memdesc:gaa0c8d0811c7faae11b9f1a7fcb30f917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the physical time that we should wait until before advancing to the specified tag.  <br /></td></tr>
<tr class="memitem:ga7a568c79c856e633f5f181dd21700b74" id="r_ga7a568c79c856e633f5f181dd21700b74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7a568c79c856e633f5f181dd21700b74">match_regex</a> (const char *str, char *regex)</td></tr>
<tr class="memdesc:ga7a568c79c856e633f5f181dd21700b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether str matches regex.  <br /></td></tr>
<tr class="memitem:gae4ba6b1361cd7c47e8a0eb70729d9636" id="r_gae4ba6b1361cd7c47e8a0eb70729d9636"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae4ba6b1361cd7c47e8a0eb70729d9636">peek_from_socket</a> (int socket, unsigned char *result)</td></tr>
<tr class="memdesc:gae4ba6b1361cd7c47e8a0eb70729d9636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Without blocking, peek at the specified socket.  <br /></td></tr>
<tr class="memitem:gaa8f7af0d4004aa925499fecefa1ac6b8" id="r_gaa8f7af0d4004aa925499fecefa1ac6b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa8f7af0d4004aa925499fecefa1ac6b8">read_from_socket</a> (int socket, size_t num_bytes, unsigned char *buffer)</td></tr>
<tr class="memdesc:gaa8f7af0d4004aa925499fecefa1ac6b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the specified number of bytes from the specified socket into the specified buffer.  <br /></td></tr>
<tr class="memitem:ga941fd71700b7646e6edbbb76db4f7bd2" id="r_ga941fd71700b7646e6edbbb76db4f7bd2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga941fd71700b7646e6edbbb76db4f7bd2">read_from_socket_close_on_error</a> (int *socket, size_t num_bytes, unsigned char *buffer)</td></tr>
<tr class="memdesc:ga941fd71700b7646e6edbbb76db4f7bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the specified number of bytes from the specified socket into the specified buffer.  <br /></td></tr>
<tr class="memitem:ga46a44d92c24d3caadec0bc9e59a26361" id="r_ga46a44d92c24d3caadec0bc9e59a26361"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga46a44d92c24d3caadec0bc9e59a26361">read_from_socket_fail_on_error</a> (int *socket, size_t num_bytes, unsigned char *buffer, char *format,...)</td></tr>
<tr class="memdesc:ga46a44d92c24d3caadec0bc9e59a26361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the specified number of bytes from the specified socket into the specified buffer and close the socket if an error occurs.  <br /></td></tr>
<tr class="memitem:gae267d03a5f2263604459ca4c1aef2c2c" id="r_gae267d03a5f2263604459ca4c1aef2c2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae267d03a5f2263604459ca4c1aef2c2c">reset_socket_stat</a> (struct <a class="el" href="structsocket__stat__t.html">socket_stat_t</a> *socket_stat)</td></tr>
<tr class="memdesc:gae267d03a5f2263604459ca4c1aef2c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset statistics on the socket.  <br /></td></tr>
<tr class="memitem:ga834b31e00e677a23b6a86119b7a2fe59" id="r_ga834b31e00e677a23b6a86119b7a2fe59"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga834b31e00e677a23b6a86119b7a2fe59">setup_clock_synchronization_with_rti</a> (void)</td></tr>
<tr class="memdesc:ga834b31e00e677a23b6a86119b7a2fe59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup necessary functionalities to synchronize clock with the RTI.  <br /></td></tr>
<tr class="memitem:ga365eba5b8b3f6445eeaffcb4435165c5" id="r_ga365eba5b8b3f6445eeaffcb4435165c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga365eba5b8b3f6445eeaffcb4435165c5">shutdown_socket</a> (int *socket, bool read_before_closing)</td></tr>
<tr class="memdesc:ga365eba5b8b3f6445eeaffcb4435165c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown and close the socket.  <br /></td></tr>
<tr class="memitem:gaeaff8773e0cba7d0f8a6d03b8f0f7766" id="r_gaeaff8773e0cba7d0f8a6d03b8f0f7766"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaeaff8773e0cba7d0f8a6d03b8f0f7766">swap_bytes_if_big_endian_int32</a> (int32_t src)</td></tr>
<tr class="memdesc:gaeaff8773e0cba7d0f8a6d03b8f0f7766"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this host is little endian, then reverse the order of the bytes of the argument.  <br /></td></tr>
<tr class="memitem:gaa548ffc52c264f564127b80f63170c33" id="r_gaa548ffc52c264f564127b80f63170c33"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa548ffc52c264f564127b80f63170c33">swap_bytes_if_big_endian_int64</a> (int64_t src)</td></tr>
<tr class="memdesc:gaa548ffc52c264f564127b80f63170c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this host is little endian, then reverse the order of the bytes of the argument.  <br /></td></tr>
<tr class="memitem:ga48fa075b3a868790da8fb303a397cd60" id="r_ga48fa075b3a868790da8fb303a397cd60"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga48fa075b3a868790da8fb303a397cd60">swap_bytes_if_big_endian_uint16</a> (uint16_t src)</td></tr>
<tr class="memdesc:ga48fa075b3a868790da8fb303a397cd60"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this host is little endian, then reverse the order of the bytes of the argument.  <br /></td></tr>
<tr class="memitem:ga3eba5f95a19f86a70d9d11fd2c736dd1" id="r_ga3eba5f95a19f86a70d9d11fd2c736dd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3eba5f95a19f86a70d9d11fd2c736dd1">synchronize_initial_physical_clock_with_rti</a> (int *rti_socket_TCP)</td></tr>
<tr class="memdesc:ga3eba5f95a19f86a70d9d11fd2c736dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize the initial physical clock with the RTI.  <br /></td></tr>
<tr class="memitem:ga43868b9ea442f34eedbfe7052247f0a3" id="r_ga43868b9ea442f34eedbfe7052247f0a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga43868b9ea442f34eedbfe7052247f0a3">tracepoint_federate_from_federate</a> (<a class="el" href="group__Tracing.html#gab02e9e69539d60297cedb38c2193a453">trace_event_t</a> event_type, int fed_id, int partner_id, <a class="el" href="structtag__t.html">tag_t</a> *tag)</td></tr>
<tr class="memdesc:ga43868b9ea442f34eedbfe7052247f0a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace federate receiving a message from another federate.  <br /></td></tr>
<tr class="memitem:gab1bd5a0184ea0773425733fe1d9faa1c" id="r_gab1bd5a0184ea0773425733fe1d9faa1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab1bd5a0184ea0773425733fe1d9faa1c">tracepoint_federate_from_rti</a> (<a class="el" href="group__Tracing.html#gab02e9e69539d60297cedb38c2193a453">trace_event_t</a> event_type, int fed_id, <a class="el" href="structtag__t.html">tag_t</a> *tag)</td></tr>
<tr class="memdesc:gab1bd5a0184ea0773425733fe1d9faa1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace federate receiving a message from the RTI.  <br /></td></tr>
<tr class="memitem:ga1307585fa1ca4dc4506f0398842115ee" id="r_ga1307585fa1ca4dc4506f0398842115ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1307585fa1ca4dc4506f0398842115ee">tracepoint_federate_to_federate</a> (<a class="el" href="group__Tracing.html#gab02e9e69539d60297cedb38c2193a453">trace_event_t</a> event_type, int fed_id, int partner_id, <a class="el" href="structtag__t.html">tag_t</a> *tag)</td></tr>
<tr class="memdesc:ga1307585fa1ca4dc4506f0398842115ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace federate sending a message to another federate.  <br /></td></tr>
<tr class="memitem:gaa074cf1f2690197f9edfd7a115381d6a" id="r_gaa074cf1f2690197f9edfd7a115381d6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa074cf1f2690197f9edfd7a115381d6a">tracepoint_federate_to_rti</a> (<a class="el" href="group__Tracing.html#gab02e9e69539d60297cedb38c2193a453">trace_event_t</a> event_type, int fed_id, <a class="el" href="structtag__t.html">tag_t</a> *tag)</td></tr>
<tr class="memdesc:gaa074cf1f2690197f9edfd7a115381d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace federate sending a message to the RTI.  <br /></td></tr>
<tr class="memitem:ga0f6ec1479ffe28cc089fe6b13e675f0e" id="r_ga0f6ec1479ffe28cc089fe6b13e675f0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0f6ec1479ffe28cc089fe6b13e675f0e">validate_host</a> (const char *host)</td></tr>
<tr class="memdesc:ga0f6ec1479ffe28cc089fe6b13e675f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether host is valid.  <br /></td></tr>
<tr class="memitem:ga841bec9ddc3fb61c2b615f5d512dc3f0" id="r_ga841bec9ddc3fb61c2b615f5d512dc3f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga841bec9ddc3fb61c2b615f5d512dc3f0">validate_port</a> (char *port)</td></tr>
<tr class="memdesc:ga841bec9ddc3fb61c2b615f5d512dc3f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether port is valid.  <br /></td></tr>
<tr class="memitem:ga1285f4b0283c8e0c020e12e76a4426c2" id="r_ga1285f4b0283c8e0c020e12e76a4426c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1285f4b0283c8e0c020e12e76a4426c2">validate_user</a> (const char *user)</td></tr>
<tr class="memdesc:ga1285f4b0283c8e0c020e12e76a4426c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether user is valid.  <br /></td></tr>
<tr class="memitem:gae8d4b83faeac37f665666429742813f9" id="r_gae8d4b83faeac37f665666429742813f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae8d4b83faeac37f665666429742813f9">write_to_socket</a> (int socket, size_t num_bytes, unsigned char *buffer)</td></tr>
<tr class="memdesc:gae8d4b83faeac37f665666429742813f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the specified number of bytes to the specified socket from the specified buffer.  <br /></td></tr>
<tr class="memitem:gaf88884c303b81143ef5ab7af4683a66c" id="r_gaf88884c303b81143ef5ab7af4683a66c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf88884c303b81143ef5ab7af4683a66c">write_to_socket_close_on_error</a> (int *socket, size_t num_bytes, unsigned char *buffer)</td></tr>
<tr class="memdesc:gaf88884c303b81143ef5ab7af4683a66c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the specified number of bytes to the specified socket.  <br /></td></tr>
<tr class="memitem:gada8d9360bdf4e9d7f36bbfc7e682f06e" id="r_gada8d9360bdf4e9d7f36bbfc7e682f06e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gada8d9360bdf4e9d7f36bbfc7e682f06e">write_to_socket_fail_on_error</a> (int *socket, size_t num_bytes, unsigned char *buffer, lf_mutex_t *mutex, char *format,...)</td></tr>
<tr class="memdesc:gada8d9360bdf4e9d7f36bbfc7e682f06e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the specified number of bytes to the specified socket.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga1881fdaaffead81a8d2993121d9cd78f" id="r_ga1881fdaaffead81a8d2993121d9cd78f"><td class="memItemLeft" align="right" valign="top">lf_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1881fdaaffead81a8d2993121d9cd78f">lf_outbound_socket_mutex</a></td></tr>
<tr class="memdesc:ga1881fdaaffead81a8d2993121d9cd78f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex lock held while performing outbound socket write and close operations.  <br /></td></tr>
<tr class="memitem:ga4ea10c9ed824595585d91f37dbfd4364" id="r_ga4ea10c9ed824595585d91f37dbfd4364"><td class="memItemLeft" align="right" valign="top">lf_cond_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4ea10c9ed824595585d91f37dbfd4364">lf_port_status_changed</a></td></tr>
<tr class="memdesc:ga4ea10c9ed824595585d91f37dbfd4364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Condition variable for blocking on unkonwn federate input ports.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<p>Functions for federated execution. </p>
<p>This group contains functions for federated execution. The message types and protocols are defined in <a class="el" href="net__common_8h.html">net_common.h</a>. </p>
<a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="ga532da6f271eb75c9ac745571b995c404" name="ga532da6f271eb75c9ac745571b995c404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga532da6f271eb75c9ac745571b995c404">&#9670;&#160;</a></span>_LF_CLOCK_SYNC_ATTENUATION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _LF_CLOCK_SYNC_ATTENUATION&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="clock-sync_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/clock-sync.h</a>&gt;</code></p>

<p>Runtime clock offset updates will be divided by this number. </p>

</div>
</div>
<a id="ga4b9290ecd850995c857e04746aa45d10" name="ga4b9290ecd850995c857e04746aa45d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b9290ecd850995c857e04746aa45d10">&#9670;&#160;</a></span>_LF_CLOCK_SYNC_COLLECT_STATS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _LF_CLOCK_SYNC_COLLECT_STATS&#160;&#160;&#160;true</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="clock-sync_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/clock-sync.h</a>&gt;</code></p>

<p>By default, collect statistics on clock synchronization. </p>

</div>
</div>
<a id="gab0eeaea19d6e5c9217a4eed928c32141" name="gab0eeaea19d6e5c9217a4eed928c32141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0eeaea19d6e5c9217a4eed928c32141">&#9670;&#160;</a></span>_LF_CLOCK_SYNC_EXCHANGES_PER_INTERVAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _LF_CLOCK_SYNC_EXCHANGES_PER_INTERVAL&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="clock-sync_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/clock-sync.h</a>&gt;</code></p>

<p>Number of required clock sync T4 messages per synchronization interval. </p>
<p>The offset to the clock will not be adjusted until this number of T4 clock synchronization messages have been received. </p>

</div>
</div>
<a id="ga8ce563da4edbe9c4f7c1ccf35ad8694f" name="ga8ce563da4edbe9c4f7c1ccf35ad8694f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ce563da4edbe9c4f7c1ccf35ad8694f">&#9670;&#160;</a></span>ADDRESS_QUERY_RETRY_INTERVAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADDRESS_QUERY_RETRY_INTERVAL&#160;&#160;&#160;<a class="el" href="group__Constants.html#ga673a8ebab8ec621a1cf731871dd170c8">MSEC</a>(250)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Time that a federate waits before asking the RTI again for the port and IP address of a federate. </p>
<p>The federate repeatedly sends an MSG_TYPE_ADDRESS_QUERY message after the RTI responds that it does not know to previous such messages. This allows time for federates to start separately. </p>

</div>
</div>
<a id="ga0810a64801750ce9b148848c228c86e9" name="ga0810a64801750ce9b148848c228c86e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0810a64801750ce9b148848c228c86e9">&#9670;&#160;</a></span>CLOCK_SYNC_GUARD_BAND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CLOCK_SYNC_GUARD_BAND&#160;&#160;&#160;<a class="el" href="group__Constants.html#gaa2aeaab0c2033d1db412c8021bff93fc">USEC</a>(100)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="clock-sync_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/clock-sync.h</a>&gt;</code></p>

<p>Define a guard band to filter clock synchronization messages based on discrepancies in the network delay. </p>
<dl class="section see"><dt>See also</dt><dd>Coded probes in Geng, Yilong, et al. "Exploiting a natural network effect for scalable, fine-grained clock
synchronization." </dd></dl>

</div>
</div>
<a id="gab2106828de539188aed925f592751c12" name="gab2106828de539188aed925f592751c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2106828de539188aed925f592751c12">&#9670;&#160;</a></span>CONNECT_RETRY_INTERVAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONNECT_RETRY_INTERVAL&#160;&#160;&#160;<a class="el" href="group__Constants.html#ga673a8ebab8ec621a1cf731871dd170c8">MSEC</a>(500)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="socket__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/socket_common.h</a>&gt;</code></p>

<p>Time between a federate's attempts to connect to the RTI. </p>

</div>
</div>
<a id="ga252b2cb72531cb00ecd4d4db37a5a473" name="ga252b2cb72531cb00ecd4d4db37a5a473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga252b2cb72531cb00ecd4d4db37a5a473">&#9670;&#160;</a></span>CONNECT_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONNECT_TIMEOUT&#160;&#160;&#160;<a class="el" href="group__Constants.html#ga694878332b974b464c7d58c7114ee6e9">MINUTES</a>(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="socket__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/socket_common.h</a>&gt;</code></p>

<p>Bound on the number of retries to connect to the RTI. </p>
<p>A federate will retry every CONNECT_RETRY_INTERVAL nanoseconds until CONNECTION_TIMEOUT expires. </p>

</div>
</div>
<a id="ga16b710f592bf8f7900666392adc444dc" name="ga16b710f592bf8f7900666392adc444dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16b710f592bf8f7900666392adc444dc">&#9670;&#160;</a></span>DEFAULT_PORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_PORT&#160;&#160;&#160;15045u</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="socket__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/socket_common.h</a>&gt;</code></p>

<p>Default port number for the RTI. </p>
<p>Unless a specific port has been specified by the LF program in the "at" for the RTI or on the command line, when the RTI starts up, it will attempt to open a socket server on this port. </p>

</div>
</div>
<a id="ga7b7cd916c6c027dc9ebdff449fb6edad" name="ga7b7cd916c6c027dc9ebdff449fb6edad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b7cd916c6c027dc9ebdff449fb6edad">&#9670;&#160;</a></span>DELAY_BETWEEN_SOCKET_RETRIES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DELAY_BETWEEN_SOCKET_RETRIES&#160;&#160;&#160;<a class="el" href="group__Constants.html#ga673a8ebab8ec621a1cf731871dd170c8">MSEC</a>(100)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="socket__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/socket_common.h</a>&gt;</code></p>

<p>The amount of time to wait after a failed socket read or write before trying again. </p>
<p>This defaults to 100 ms. </p>

</div>
</div>
<a id="ga4b8c713b515dba0c86d9205dc0caf4ed" name="ga4b8c713b515dba0c86d9205dc0caf4ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b8c713b515dba0c86d9205dc0caf4ed">&#9670;&#160;</a></span>DELAY_START</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DELAY_START&#160;&#160;&#160;<a class="el" href="group__Constants.html#ga30e47c4dd44d168c2982d3ec1d4e0825">SEC</a>(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Delay the start of all federates by this amount. </p>
<p>This helps ensure that the federates do not start at the same time. Each federate has provided its current physical time to the RTI, and the RTI has picked the largest of these. It will add this quantity and declare that to be the start time. </p><dl class="section note"><dt>Note</dt><dd>This could use the latency estimates that were acquired during initial clock synchronization. </dd></dl>

</div>
</div>
<a id="ga8086398bfefdc0104767df037e59daa5" name="ga8086398bfefdc0104767df037e59daa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8086398bfefdc0104767df037e59daa5">&#9670;&#160;</a></span>ENCODE_STOP_GRANTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENCODE_STOP_GRANTED</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>microstep</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                                                                 \</div>
<div class="line">    buffer[0] = <a class="code hl_define" href="#gaad37dd00423e88f213ca7d7d238bce2e">MSG_TYPE_STOP_GRANTED</a>;                                                                                 \</div>
<div class="line">    encode_int64(time, &amp;(buffer[1]));                                                                                  \</div>
<div class="line">    encode_int32((int32_t)microstep, &amp;(buffer[1 + <span class="keyword">sizeof</span>(<a class="code hl_typedef" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a>)]));                                                \</div>
<div class="line">  } <span class="keywordflow">while</span> (0)</div>
<div class="ttc" id="agroup__API_html_ga827080fd3c574bad5a32db9f7c367587"><div class="ttname"><a href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a></div><div class="ttdeci">int64_t instant_t</div><div class="ttdoc">Time instant.</div><div class="ttdef"><b>Definition</b> tag.h:101</div></div>
<div class="ttc" id="agroup__Federated_html_gaad37dd00423e88f213ca7d7d238bce2e"><div class="ttname"><a href="#gaad37dd00423e88f213ca7d7d238bce2e">MSG_TYPE_STOP_GRANTED</a></div><div class="ttdeci">#define MSG_TYPE_STOP_GRANTED</div><div class="ttdoc">Byte sent by the RTI indicating that the stop request from some federate has been granted.</div><div class="ttdef"><b>Definition</b> net_common.h:525</div></div>
</div><!-- fragment -->
<p>Encode a stop granted message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to encode the message into. </td></tr>
    <tr><td class="paramname">time</td><td>The time at which the federates will stop. </td></tr>
    <tr><td class="paramname">microstep</td><td>The microstep at which the federates will stop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3268a658c2cb5126be5284a86ad9bd62" name="ga3268a658c2cb5126be5284a86ad9bd62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3268a658c2cb5126be5284a86ad9bd62">&#9670;&#160;</a></span>ENCODE_STOP_REQUEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENCODE_STOP_REQUEST</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>microstep</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                                                                 \</div>
<div class="line">    buffer[0] = <a class="code hl_define" href="net__common_8h.html#a8588a57a3ae81bf33c740dfc57103a23">MSG_TYPE_STOP_REQUEST</a>;                                                                                 \</div>
<div class="line">    encode_int64(time, &amp;(buffer[1]));                                                                                  \</div>
<div class="line">    encode_int32((int32_t)microstep, &amp;(buffer[1 + <span class="keyword">sizeof</span>(<a class="code hl_typedef" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a>)]));                                                \</div>
<div class="line">  } <span class="keywordflow">while</span> (0)</div>
<div class="ttc" id="anet__common_8h_html_a8588a57a3ae81bf33c740dfc57103a23"><div class="ttname"><a href="net__common_8h.html#a8588a57a3ae81bf33c740dfc57103a23">MSG_TYPE_STOP_REQUEST</a></div><div class="ttdeci">#define MSG_TYPE_STOP_REQUEST</div><div class="ttdoc">Byte identifying a stop request.</div><div class="ttdef"><b>Definition</b> net_common.h:462</div></div>
</div><!-- fragment -->
<p>Encode a stop request message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to encode the message into. </td></tr>
    <tr><td class="paramname">time</td><td>The time at which the federates will stop. </td></tr>
    <tr><td class="paramname">microstep</td><td>The microstep at which the federates will stop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae06b33f7fcdc71f52eb0fcf81e07e4d6" name="gae06b33f7fcdc71f52eb0fcf81e07e4d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae06b33f7fcdc71f52eb0fcf81e07e4d6">&#9670;&#160;</a></span>ENCODE_STOP_REQUEST_REPLY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENCODE_STOP_REQUEST_REPLY</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>microstep</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                                                                 \</div>
<div class="line">    buffer[0] = <a class="code hl_define" href="net__common_8h.html#adbe10e103635ee7ec4bca3226ccebc56">MSG_TYPE_STOP_REQUEST_REPLY</a>;                                                                           \</div>
<div class="line">    encode_int64(time, &amp;(buffer[1]));                                                                                  \</div>
<div class="line">    encode_int32((int32_t)microstep, &amp;(buffer[1 + <span class="keyword">sizeof</span>(<a class="code hl_typedef" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a>)]));                                                \</div>
<div class="line">  } <span class="keywordflow">while</span> (0)</div>
<div class="ttc" id="anet__common_8h_html_adbe10e103635ee7ec4bca3226ccebc56"><div class="ttname"><a href="net__common_8h.html#adbe10e103635ee7ec4bca3226ccebc56">MSG_TYPE_STOP_REQUEST_REPLY</a></div><div class="ttdeci">#define MSG_TYPE_STOP_REQUEST_REPLY</div><div class="ttdoc">Byte indicating a federate&#39;s reply to a MSG_TYPE_STOP_REQUEST that was sent by the RTI.</div><div class="ttdef"><b>Definition</b> net_common.h:493</div></div>
</div><!-- fragment -->
<p>Encode a stop request reply message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to encode the message into. </td></tr>
    <tr><td class="paramname">time</td><td>The time at which the federates will stop. </td></tr>
    <tr><td class="paramname">microstep</td><td>The microstep at which the federates will stop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacc95612e1d2dbbdf34afe76d50e75223" name="gacc95612e1d2dbbdf34afe76d50e75223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc95612e1d2dbbdf34afe76d50e75223">&#9670;&#160;</a></span>FED_COM_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FED_COM_BUFFER_SIZE&#160;&#160;&#160;256u</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Size of the buffer used for messages sent between federates. </p>
<p>This is used by both the federates and the RTI, so message lengths should generally match. </p>

</div>
</div>
<a id="gae3bd830cd17cf0914b61d0516360abc1" name="gae3bd830cd17cf0914b61d0516360abc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3bd830cd17cf0914b61d0516360abc1">&#9670;&#160;</a></span>FEDERATE_ID_IN_USE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FEDERATE_ID_IN_USE&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Code sent with a <a class="el" href="#ga59a69d0685fdc2a216718f1efa083c4c">MSG_TYPE_REJECT</a> message indicating that the federate ID is already in use. </p>

</div>
</div>
<a id="ga5846fdcf4c92041f543b73e29e78aa21" name="ga5846fdcf4c92041f543b73e29e78aa21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5846fdcf4c92041f543b73e29e78aa21">&#9670;&#160;</a></span>FEDERATE_ID_OUT_OF_RANGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FEDERATE_ID_OUT_OF_RANGE&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Code sent with a <a class="el" href="#ga59a69d0685fdc2a216718f1efa083c4c">MSG_TYPE_REJECT</a> message indicating that the federate ID is out of range. </p>

</div>
</div>
<a id="ga653676d1f302fe08249af3dee78fa294" name="ga653676d1f302fe08249af3dee78fa294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga653676d1f302fe08249af3dee78fa294">&#9670;&#160;</a></span>FEDERATION_ID_DOES_NOT_MATCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FEDERATION_ID_DOES_NOT_MATCH&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Code sent with a <a class="el" href="#ga59a69d0685fdc2a216718f1efa083c4c">MSG_TYPE_REJECT</a> message indicating that the federation ID does not match. </p>

</div>
</div>
<a id="ga51d08a784b4ee6463688a971d99d2944" name="ga51d08a784b4ee6463688a971d99d2944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51d08a784b4ee6463688a971d99d2944">&#9670;&#160;</a></span>HMAC_DOES_NOT_MATCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HMAC_DOES_NOT_MATCH&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Code sent with a <a class="el" href="#ga59a69d0685fdc2a216718f1efa083c4c">MSG_TYPE_REJECT</a> message indicating that the HMAC authentication failed. </p>

</div>
</div>
<a id="gab36196523f89c0d8f30c1965b458beb6" name="gab36196523f89c0d8f30c1965b458beb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab36196523f89c0d8f30c1965b458beb6">&#9670;&#160;</a></span>LF_CLOCK_SYNC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LF_CLOCK_SYNC&#160;&#160;&#160;<a class="el" href="#ga7ed4e5f2a4216fdf6d76eafcab5b49b7">LF_CLOCK_SYNC_INIT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="clock-sync_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/clock-sync.h</a>&gt;</code></p>

<p>Clock synchronization mode. </p>
<p>This is one of LF_CLOCK_SYNC_OFF, LF_CLOCK_SYNC_INIT, or LF_CLOCK_SYNC_ON. The default is LF_CLOCK_SYNC_INIT, which indicates that clock synchronization is performed only at initialization. </p><dl class="section note"><dt>Note</dt><dd>This is a compile-time option. </dd></dl>

</div>
</div>
<a id="ga7ed4e5f2a4216fdf6d76eafcab5b49b7" name="ga7ed4e5f2a4216fdf6d76eafcab5b49b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ed4e5f2a4216fdf6d76eafcab5b49b7">&#9670;&#160;</a></span>LF_CLOCK_SYNC_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LF_CLOCK_SYNC_INIT&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="clock-sync_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/clock-sync.h</a>&gt;</code></p>

<p>Indicator for clock synchronization to be turned on at initialization. </p>

</div>
</div>
<a id="ga742c3183fb89d811377514d09e526b8f" name="ga742c3183fb89d811377514d09e526b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga742c3183fb89d811377514d09e526b8f">&#9670;&#160;</a></span>LF_CLOCK_SYNC_OFF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LF_CLOCK_SYNC_OFF&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="clock-sync_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/clock-sync.h</a>&gt;</code></p>

<p>Indicator for clock synchronization to be turned off altogether. </p>

</div>
</div>
<a id="gaa9efe35bfc06d22220c852574c4a5feb" name="gaa9efe35bfc06d22220c852574c4a5feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9efe35bfc06d22220c852574c4a5feb">&#9670;&#160;</a></span>LF_CLOCK_SYNC_ON</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LF_CLOCK_SYNC_ON&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="clock-sync_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/clock-sync.h</a>&gt;</code></p>

<p>Indicator for clock synchronization to be turned on at initialization and runtime. </p>

</div>
</div>
<a id="ga5dbc42b5857eb262a06aa04399475d16" name="ga5dbc42b5857eb262a06aa04399475d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dbc42b5857eb262a06aa04399475d16">&#9670;&#160;</a></span>MAX_NUM_PORT_ADDRESSES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_NUM_PORT_ADDRESSES&#160;&#160;&#160;16u</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="socket__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/socket_common.h</a>&gt;</code></p>

<p>Maximum number of port addresses that a federate will try to connect to the RTI on. </p>
<p>If you are using automatic ports begining at DEFAULT_PORT, this puts an upper bound on the number of RTIs that can be running on the same host. </p>

</div>
</div>
<a id="gad94567b2d2e277ddc1be0da9a92b09e7" name="gad94567b2d2e277ddc1be0da9a92b09e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad94567b2d2e277ddc1be0da9a92b09e7">&#9670;&#160;</a></span>MSG_TYPE_ACK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_ACK&#160;&#160;&#160;255</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Byte identifying an acknowledgment of the previously received message. </p>
<p>This message carries no payload. </p>

</div>
</div>
<a id="gae004cb4e5add42afe5483f6706e11d35" name="gae004cb4e5add42afe5483f6706e11d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae004cb4e5add42afe5483f6706e11d35">&#9670;&#160;</a></span>MSG_TYPE_ADDRESS_ADVERTISEMENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_ADDRESS_ADVERTISEMENT&#160;&#160;&#160;15</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Byte identifying a message advertising the port for the TCP connection server of a federate. </p>
<p>This is utilized in decentralized coordination as well as for physical connections in centralized coordination. The next four bytes (or sizeof(int32_t)) will be the port number. The sending federate will not wait for a response from the RTI and assumes its request will be processed eventually by the RTI. </p>

</div>
</div>
<a id="ga5ac191bca25da16eca3e4f02d21172ef" name="ga5ac191bca25da16eca3e4f02d21172ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ac191bca25da16eca3e4f02d21172ef">&#9670;&#160;</a></span>MSG_TYPE_ADDRESS_QUERY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_ADDRESS_QUERY&#160;&#160;&#160;13</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Byte identifying a address query message, sent by a federate to RTI to ask for another federate's address and port number. </p>
<p>The next two bytes are the other federate's ID. </p>

</div>
</div>
<a id="gaabe4cac3ef1d0834a99fa2532dfaa6ba" name="gaabe4cac3ef1d0834a99fa2532dfaa6ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabe4cac3ef1d0834a99fa2532dfaa6ba">&#9670;&#160;</a></span>MSG_TYPE_ADDRESS_QUERY_REPLY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_ADDRESS_QUERY_REPLY&#160;&#160;&#160;14</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Byte identifying a address query message reply, sent by a RTI to a federate to reply with a remote federate's address and port number. </p>
<p>The reply from the RTI will be a port number (an int32_t), which is -1 if the RTI does not know yet (it has not received MSG_TYPE_ADDRESS_ADVERTISEMENT from the other federate), followed by the IP address of the other federate (an IPV4 address, which has length INET_ADDRSTRLEN). The next four bytes (or sizeof(int32_t)) will be the port number. The next four bytes (or sizeof(in_addr), which is uint32_t) will be the ip address. </p>

</div>
</div>
<a id="gaa13eface5080ad75bbd53abe919c80b6" name="gaa13eface5080ad75bbd53abe919c80b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa13eface5080ad75bbd53abe919c80b6">&#9670;&#160;</a></span>MSG_TYPE_CLOCK_SYNC_CODED_PROBE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_CLOCK_SYNC_CODED_PROBE&#160;&#160;&#160;22</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Coded probe message. </p>
<p>This messages is sent by the server (master) right after <a class="el" href="#gae128056ab2af39988103856ee815d930" title="Physical clock synchronization message according to PTP.">MSG_TYPE_CLOCK_SYNC_T4(t1)</a> with a new physical clock snapshot t2. At the receiver, the previous MSG_TYPE_CLOCK_SYNC_T4 message and this message are assigned a receive timestamp r1 and r2. If |(r2 - r1) - (t2 - t1)| &lt; GUARD_BAND, then the current clock sync cycle is considered pure and can be processed. </p><dl class="section see"><dt>See also</dt><dd>Geng, Yilong, et al. "Exploiting a natural network effect for scalable, fine-grained clock synchronization." </dd></dl>

</div>
</div>
<a id="gaea37eff76ade1b2781a7e6298afb3a04" name="gaea37eff76ade1b2781a7e6298afb3a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea37eff76ade1b2781a7e6298afb3a04">&#9670;&#160;</a></span>MSG_TYPE_CLOCK_SYNC_T1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_CLOCK_SYNC_T1&#160;&#160;&#160;19</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Physical clock synchronization messages according to PTP. </p>
<p>The next 8 bytes will be a timestamp sent according to PTP. </p>

</div>
</div>
<a id="ga52a76e4cc36217a169f32d5adde590cc" name="ga52a76e4cc36217a169f32d5adde590cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52a76e4cc36217a169f32d5adde590cc">&#9670;&#160;</a></span>MSG_TYPE_CLOCK_SYNC_T3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_CLOCK_SYNC_T3&#160;&#160;&#160;20</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Prompt the master to send a T4. </p>
<p>The next four bytes will be the sending federate's id. </p>

</div>
</div>
<a id="gae128056ab2af39988103856ee815d930" name="gae128056ab2af39988103856ee815d930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae128056ab2af39988103856ee815d930">&#9670;&#160;</a></span>MSG_TYPE_CLOCK_SYNC_T4</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_CLOCK_SYNC_T4&#160;&#160;&#160;21</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Physical clock synchronization message according to PTP. </p>
<p>The next 8 bytes will be a timestamp sent according to PTP. </p>

</div>
</div>
<a id="gafb060091e032562cf32c0eb62340d309" name="gafb060091e032562cf32c0eb62340d309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb060091e032562cf32c0eb62340d309">&#9670;&#160;</a></span>MSG_TYPE_DOWNSTREAM_NEXT_EVENT_TAG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_DOWNSTREAM_NEXT_EVENT_TAG&#160;&#160;&#160;26</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Byte identifying a downstream next event tag (DNET) message sent from the RTI in centralized coordination. </p>
<p>The next eight bytes will be the timestamp. The next four bytes will be the microstep. This signal from the RTI tells the destination federate that downstream federates do not need for it to send any next event tag (NET) signal with a tag <em>g</em> less than the specified tag. Thus, it should only send those signals if needs permission from the RTI to advance to <em>g</em>. </p>

</div>
</div>
<a id="gaf27674f627be1c469a529a995da5c074" name="gaf27674f627be1c469a529a995da5c074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf27674f627be1c469a529a995da5c074">&#9670;&#160;</a></span>MSG_TYPE_FAILED <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_FAILED&#160;&#160;&#160;25</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Byte identifying that the federate or the RTI has failed. </p>

</div>
</div>
<a id="gaf27674f627be1c469a529a995da5c074" name="gaf27674f627be1c469a529a995da5c074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf27674f627be1c469a529a995da5c074">&#9670;&#160;</a></span>MSG_TYPE_FAILED <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_FAILED&#160;&#160;&#160;25</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="socket__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/socket_common.h</a>&gt;</code></p>

<p>Byte identifying that the federate or the RTI has failed. </p>

</div>
</div>
<a id="ga8e49ce0b1c3a58c881849ca4d0bae824" name="ga8e49ce0b1c3a58c881849ca4d0bae824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e49ce0b1c3a58c881849ca4d0bae824">&#9670;&#160;</a></span>MSG_TYPE_FED_IDS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_FED_IDS&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Byte identifying a message from a federate to an RTI containing the federation ID and the federate ID. </p>
<p>The message contains, in this order:</p><ul>
<li>One byte equal to MSG_TYPE_FED_IDS.</li>
<li>Two bytes (ushort) giving the federate ID.</li>
<li>One byte (uchar) giving the length N of the federation ID.</li>
<li>N bytes containing the federation ID. Each federate needs to have a unique ID between 0 and NUMBER_OF_FEDERATES-1. Each federate, when starting up, should send this message to the RTI. This is its first message to the RTI. The RTI will respond with either MSG_TYPE_REJECT, MSG_TYPE_ACK, or MSG_TYPE_UDP_PORT. If the federate is a C target LF program, the generated federate code does this by calling <a class="el" href="#ga36681c905141edace5d23ff8d5c8f205" title="Synchronize the start with other federates via the RTI.">lf_synchronize_with_other_federates()</a>, passing to it its federate ID. </li>
</ul>

</div>
</div>
<a id="ga191b27bec42ab0370248fbc64cc9b860" name="ga191b27bec42ab0370248fbc64cc9b860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga191b27bec42ab0370248fbc64cc9b860">&#9670;&#160;</a></span>MSG_TYPE_FED_NONCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_FED_NONCE&#160;&#160;&#160;100</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Byte identifying a message from a federate to an RTI containing federate's 8-byte random nonce for HMAC-based authentication. </p>
<p>The federate sends this message to an incoming RTI when TCP connection is established between the RTI and the federate. The message contains, in this order:</p><ul>
<li>One byte equal to MSG_TYPE_FED_NONCE.</li>
<li>Two bytes (ushort) giving the federate ID.</li>
<li>Eight bytes for federate's nonce. </li>
</ul>

</div>
</div>
<a id="gacd7e1e07253e568044a204a1f82d36a1" name="gacd7e1e07253e568044a204a1f82d36a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd7e1e07253e568044a204a1f82d36a1">&#9670;&#160;</a></span>MSG_TYPE_FED_RESPONSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_FED_RESPONSE&#160;&#160;&#160;102</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Byte identifying a message from federate to RTI as a response to the RTI_RESPONSE message. </p>
<p>The federate sends this message to RTI for HMAC-based authentication. The message contains, in this order:</p><ul>
<li>One byte equal to MSG_TYPE_FED_RESPONSE.</li>
<li>32 bytes for HMAC tag based on SHA256. The HMAC tag is composed of the following order:</li>
<li>One byte equal to MSG_TYPE_FED_RESPONSE.</li>
<li>Eight bytes for received RTI's nonce. </li>
</ul>

</div>
</div>
<a id="gada47c9f6736992a3df380526d87089f9" name="gada47c9f6736992a3df380526d87089f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada47c9f6736992a3df380526d87089f9">&#9670;&#160;</a></span>MSG_TYPE_LATEST_TAG_CONFIRMED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_LATEST_TAG_CONFIRMED&#160;&#160;&#160;9</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Byte identifying a latest tag confirmed (LTC) message sent by a federate to the RTI. </p>
<p>The next eight bytes will be the timestep of the completed tag. The next four bytes will be the microsteps of the completed tag. </p>

</div>
</div>
<a id="gac79b5228f132029285408a30a31a174e" name="gac79b5228f132029285408a30a31a174e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac79b5228f132029285408a30a31a174e">&#9670;&#160;</a></span>MSG_TYPE_MESSAGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_MESSAGE&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Byte identifying a message to forward to another federate. </p>
<p>The next two bytes will be the ID of the destination port. The next two bytes are the destination federate ID. The four bytes after that will be the length of the message. The remaining bytes are the message. </p><dl class="section note"><dt>Note</dt><dd>This is currently not used. All messages are tagged, even on physical connections, because if "after" is used, the message may preserve the logical timestamp rather than using the physical time. </dd></dl>

</div>
</div>
<a id="ga48ec489cb1543b161c262f4bee6c9598" name="ga48ec489cb1543b161c262f4bee6c9598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48ec489cb1543b161c262f4bee6c9598">&#9670;&#160;</a></span>MSG_TYPE_NEIGHBOR_STRUCTURE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_NEIGHBOR_STRUCTURE&#160;&#160;&#160;24</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>A message that informs the RTI about connections between this federate and other federates where messages are routed through the RTI. </p>
<p>Currently, this only includes logical connections when the coordination is centralized. This information is needed for the RTI to perform the centralized coordination.</p>
<dl class="section note"><dt>Note</dt><dd>Only information about the immediate neighbors is required. The RTI can transitively obtain the structure of the federation based on each federate's immediate neighbor information.</dd></dl>
<p>The next 4 bytes is the number of upstream federates. The next 4 bytes is the number of downstream federates.</p>
<p>Depending on the first four bytes, the next bytes are pairs of (fed ID (2 bytes), delay (8 bytes)) for this federate's connection to upstream federates (by direct connection). The delay is the minimum "after" delay of all connections from the upstream federate.</p>
<p>Depending on the second four bytes, the next bytes are fed IDs (2 bytes each), of this federate's downstream federates (by direct connection).</p>
<dl class="section note"><dt>Note</dt><dd>The upstream and downstream connections are transmitted on the same message to prevent (at least to some degree) the scenario where the RTI has information about one, but not the other (which is a critical error). </dd></dl>

</div>
</div>
<a id="ga77a9c1b741d7ca0f4e8d00a5b74ef91e" name="ga77a9c1b741d7ca0f4e8d00a5b74ef91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77a9c1b741d7ca0f4e8d00a5b74ef91e">&#9670;&#160;</a></span>MSG_TYPE_NEIGHBOR_STRUCTURE_HEADER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_NEIGHBOR_STRUCTURE_HEADER_SIZE&#160;&#160;&#160;9</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>The size of the header of a neighbor structure message. </p>

</div>
</div>
<a id="gaf662a6a84cd64cddad92e20e26af877e" name="gaf662a6a84cd64cddad92e20e26af877e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf662a6a84cd64cddad92e20e26af877e">&#9670;&#160;</a></span>MSG_TYPE_NEXT_EVENT_TAG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_NEXT_EVENT_TAG&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Byte identifying a next event tag (NET) message sent from a federate in centralized coordination. </p>
<p>The next eight bytes will be the timestamp. The next four bytes will be the microstep. This message from a federate tells the RTI the tag of the earliest event on that federate's event queue. In other words, absent any further inputs from other federates, this will be the least tag of the next set of reactions on that federate. tag of the next set of reactions on that federate. If the event queue is empty and a timeout time has been specified, then the timeout time will be sent. If there is no timeout time, then FOREVER will be sent. Note that if there are physical actions and the earliest event on the event queue has a tag that is ahead of physical time (or the queue is empty), the federate should try to regularly advance its tag (and thus send NET messages) to make sure downstream federates can make progress. </p>

</div>
</div>
<a id="ga2b9f13f8df66448bf81ac5fe0774c124" name="ga2b9f13f8df66448bf81ac5fe0774c124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b9f13f8df66448bf81ac5fe0774c124">&#9670;&#160;</a></span>MSG_TYPE_P2P_MESSAGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_P2P_MESSAGE&#160;&#160;&#160;17</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Byte identifying a message to send directly to another federate. </p>
<p>The next two bytes will be the ID of the destination port. The next two bytes are the destination federate ID. This is checked against the _lf_my_fed_id of the receiving federate to ensure the message was intended for The four bytes after will be the length of the message. The ramaining bytes are the message. </p>

</div>
</div>
<a id="gacd33bbab7bf74e5ac8bad3bd27145f8b" name="gacd33bbab7bf74e5ac8bad3bd27145f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd33bbab7bf74e5ac8bad3bd27145f8b">&#9670;&#160;</a></span>MSG_TYPE_P2P_SENDING_FED_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_P2P_SENDING_FED_ID&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Byte identifying a first message that is sent by a federate directly to another federate after establishing a socket connection to send messages directly to the federate. </p>
<p>This first message contains two bytes identifying the sending federate (its ID), a byte giving the length of the federation ID, followed by the federation ID (a string). The response from the remote federate is expected to be MSG_TYPE_ACK, but if the remote federate does not expect this federate or federation to connect, it will respond instead with MSG_TYPE_REJECT. </p>

</div>
</div>
<a id="ga5c1256c8c62fbbcb1b16ea67d8f529fb" name="ga5c1256c8c62fbbcb1b16ea67d8f529fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c1256c8c62fbbcb1b16ea67d8f529fb">&#9670;&#160;</a></span>MSG_TYPE_P2P_TAGGED_MESSAGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_P2P_TAGGED_MESSAGE&#160;&#160;&#160;18</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Byte identifying a timestamped message to send directly to another federate. </p>
<p>This is a variant of </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga2922af172f2e95bc73bd0675a4107b3b" title="Byte identifying a timestamped message to forward to another federate.">MSG_TYPE_TAGGED_MESSAGE</a> that is used in P2P connections between federates. Having a separate message type for P2P connections between federates will be useful in preventing crosstalk.</dd></dl>
<p>The next two bytes will be the ID of the destination port. The next two bytes are the destination federate ID. This is checked against the _lf_my_fed_id of the receiving federate to ensure the message was intended for the correct federate. The four bytes after will be the length of the message. The next eight bytes will be the timestamp. The next four bytes will be the microstep of the sender. The ramaining bytes are the message. </p>

</div>
</div>
<a id="gadb9610b1edbee4c85e194e391a6eeb74" name="gadb9610b1edbee4c85e194e391a6eeb74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb9610b1edbee4c85e194e391a6eeb74">&#9670;&#160;</a></span>MSG_TYPE_PORT_ABSENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_PORT_ABSENT&#160;&#160;&#160;23</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>A port absent message, informing the receiver that a given port will not have event for the current logical time. </p>
<p>The next 2 bytes is the port id. The next 2 bytes will be the federate id of the destination federate. This is needed for the centralized coordination so that the RTI knows where to forward the message. The next 8 bytes are the intended time of the absent message The next 4 bytes are the intended microstep of the absent message </p>

</div>
</div>
<a id="ga9a9bb60d4df1ba581a29319850097cc2" name="ga9a9bb60d4df1ba581a29319850097cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a9bb60d4df1ba581a29319850097cc2">&#9670;&#160;</a></span>MSG_TYPE_PROVISIONAL_TAG_ADVANCE_GRANT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_PROVISIONAL_TAG_ADVANCE_GRANT&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Byte identifying a provisional time advance grant (PTAG) sent by the RTI to a federate in centralized coordination. </p>
<p>This message is a promise by the RTI to the federate that no later message sent to the federate will have a tag earlier than the tag carried by this PTAG message. The next eight bytes will be the timestamp. The next four bytes will be the microstep. </p>

</div>
</div>
<a id="ga59a69d0685fdc2a216718f1efa083c4c" name="ga59a69d0685fdc2a216718f1efa083c4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59a69d0685fdc2a216718f1efa083c4c">&#9670;&#160;</a></span>MSG_TYPE_REJECT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_REJECT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Byte identifying a rejection of the previously received message. </p>
<p>The reason for the rejection is included as an additional byte (uchar) (see below for encodings of rejection reasons). </p>

</div>
</div>
<a id="ga9e19e307a4c3a9dbccea4f2539cd67dd" name="ga9e19e307a4c3a9dbccea4f2539cd67dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e19e307a4c3a9dbccea4f2539cd67dd">&#9670;&#160;</a></span>MSG_TYPE_RESIGN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_RESIGN&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Byte identifying that the federate or the RTI is ending its execution. </p>

</div>
</div>
<a id="ga20f24b4b20547d44523120689afd9b98" name="ga20f24b4b20547d44523120689afd9b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20f24b4b20547d44523120689afd9b98">&#9670;&#160;</a></span>MSG_TYPE_RTI_RESPONSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_RTI_RESPONSE&#160;&#160;&#160;101</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Byte identifying a message from RTI to federate as a response to the FED_NONCE message. </p>
<p>The RTI sends this message to federate for HMAC-based authentication. The message contains, in this order:</p><ul>
<li>One byte equal to MSG_TYPE_RTI_RESPONSE.</li>
<li>Eight bytes for RTI's nonce.</li>
<li>32 bytes for HMAC tag based on SHA256. The HMAC tag is composed of the following order:</li>
<li>One byte equal to MSG_TYPE_RTI_RESPONSE.</li>
<li>Two bytes (ushort) giving the received federate ID.</li>
<li>Eight bytes for received federate's nonce. </li>
</ul>

</div>
</div>
<a id="gaad37dd00423e88f213ca7d7d238bce2e" name="gaad37dd00423e88f213ca7d7d238bce2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad37dd00423e88f213ca7d7d238bce2e">&#9670;&#160;</a></span>MSG_TYPE_STOP_GRANTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_STOP_GRANTED&#160;&#160;&#160;12</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Byte sent by the RTI indicating that the stop request from some federate has been granted. </p>
<p>The payload is the tag at which all federates have agreed that they can stop. The next 8 bytes will be the time at which the federates will stop. The next 4 bytes will be the microstep at which the federates will stop. </p>

</div>
</div>
<a id="ga76275384e9865f1f1ed32408c03d876a" name="ga76275384e9865f1f1ed32408c03d876a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76275384e9865f1f1ed32408c03d876a">&#9670;&#160;</a></span>MSG_TYPE_STOP_GRANTED_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_STOP_GRANTED_LENGTH&#160;&#160;&#160;(1 + sizeof(<a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a>) + sizeof(<a class="el" href="group__API.html#gad88f1caa8b9c216404eb196cb1850213">microstep_t</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>The length of a stop granted message. </p>

</div>
</div>
<a id="gaa3ed75054ae1aaa64dafa6399f7a23cb" name="gaa3ed75054ae1aaa64dafa6399f7a23cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3ed75054ae1aaa64dafa6399f7a23cb">&#9670;&#160;</a></span>MSG_TYPE_STOP_REQUEST_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_STOP_REQUEST_LENGTH&#160;&#160;&#160;(1 + sizeof(<a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a>) + sizeof(<a class="el" href="group__API.html#gad88f1caa8b9c216404eb196cb1850213">microstep_t</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>The length of a stop request message. </p>

</div>
</div>
<a id="gaa62d9986e928cb5e872caa6a509cae6c" name="gaa62d9986e928cb5e872caa6a509cae6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa62d9986e928cb5e872caa6a509cae6c">&#9670;&#160;</a></span>MSG_TYPE_STOP_REQUEST_REPLY_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_STOP_REQUEST_REPLY_LENGTH&#160;&#160;&#160;(1 + sizeof(<a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a>) + sizeof(<a class="el" href="group__API.html#gad88f1caa8b9c216404eb196cb1850213">microstep_t</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>The length of a stop request reply message. </p>

</div>
</div>
<a id="ga94fe2c510160682b2c0ffc00b35e0ad5" name="ga94fe2c510160682b2c0ffc00b35e0ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94fe2c510160682b2c0ffc00b35e0ad5">&#9670;&#160;</a></span>MSG_TYPE_TAG_ADVANCE_GRANT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_TAG_ADVANCE_GRANT&#160;&#160;&#160;7</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Byte identifying a time advance grant (TAG) sent by the RTI to a federate in centralized coordination. </p>
<p>This message is a promise by the RTI to the federate that no later message sent to the federate will have a tag earlier than or equal to the tag carried by this TAG message. The next eight bytes will be the timestamp. The next four bytes will be the microstep. </p>

</div>
</div>
<a id="ga2922af172f2e95bc73bd0675a4107b3b" name="ga2922af172f2e95bc73bd0675a4107b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2922af172f2e95bc73bd0675a4107b3b">&#9670;&#160;</a></span>MSG_TYPE_TAGGED_MESSAGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_TAGGED_MESSAGE&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Byte identifying a timestamped message to forward to another federate. </p>
<p>The next two bytes will be the ID of the destination reactor port. The next two bytes are the destination federate ID. The four bytes after that will be the length of the message (as an unsigned 32-bit int). The next eight bytes will be the timestamp of the message. The next four bytes will be the microstep of the message. The remaining bytes are the message.</p>
<p>With centralized coordination, all such messages flow through the RTI. With decentralized coordination, tagged messages are sent peer-to-peer between federates and are marked with MSG_TYPE_P2P_TAGGED_MESSAGE. </p>

</div>
</div>
<a id="ga27db349e7460afc1758bf2eec95d7005" name="ga27db349e7460afc1758bf2eec95d7005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27db349e7460afc1758bf2eec95d7005">&#9670;&#160;</a></span>MSG_TYPE_TIMESTAMP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_TIMESTAMP&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Byte identifying a timestamp message, which is 64 bits long. </p>
<p>Each federate sends its starting physical time as a message of this type, and the RTI broadcasts to all the federates the starting logical time as a message of this type. </p>

</div>
</div>
<a id="ga3450aedd1ca1c368ed28ed2e859588ef" name="ga3450aedd1ca1c368ed28ed2e859588ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3450aedd1ca1c368ed28ed2e859588ef">&#9670;&#160;</a></span>MSG_TYPE_TIMESTAMP_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_TIMESTAMP_LENGTH&#160;&#160;&#160;(1 + sizeof(int64_t))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>The length of a timestamp message. </p>

</div>
</div>
<a id="gae2c2fdb5fbcc47750409348d37b0cd78" name="gae2c2fdb5fbcc47750409348d37b0cd78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2c2fdb5fbcc47750409348d37b0cd78">&#9670;&#160;</a></span>MSG_TYPE_UDP_PORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MSG_TYPE_UDP_PORT&#160;&#160;&#160;254</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Byte identifying an acknowledgment of the previously received MSG_TYPE_FED_IDS message. </p>
<p>This message is sent by the RTI to the federate with a payload indicating the UDP port to use for clock synchronization. The next four bytes will be the port number for the UDP server, or 0 or USHRT_MAX if there is no UDP server. 0 means that initial clock synchronization is enabled, whereas USHRT_MAX mean that no synchronization should be performed at all. </p>

</div>
</div>
<a id="ga6771c37605e49c8faae7898797f254b7" name="ga6771c37605e49c8faae7898797f254b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6771c37605e49c8faae7898797f254b7">&#9670;&#160;</a></span>NONCE_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NONCE_LENGTH&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>The randomly created nonce size will be 8 bytes. </p>

</div>
</div>
<a id="gaf58c457e08491f7cfd5a0a46940e11ad" name="gaf58c457e08491f7cfd5a0a46940e11ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf58c457e08491f7cfd5a0a46940e11ad">&#9670;&#160;</a></span>NUMBER_OF_FEDERATES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUMBER_OF_FEDERATES&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="socket__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/socket_common.h</a>&gt;</code></p>

<p>The number of federates. </p>
<p>This defaults to 1. </p>

</div>
</div>
<a id="gaf11c9d6cd02e9e78e38a848cf75205cb" name="gaf11c9d6cd02e9e78e38a848cf75205cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf11c9d6cd02e9e78e38a848cf75205cb">&#9670;&#160;</a></span>PORT_BIND_RETRY_INTERVAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PORT_BIND_RETRY_INTERVAL&#160;&#160;&#160;<a class="el" href="group__Constants.html#ga30e47c4dd44d168c2982d3ec1d4e0825">SEC</a>(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="socket__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/socket_common.h</a>&gt;</code></p>

<p>Time to wait before re-attempting to bind to a port. </p>
<p>When a process closes, the network stack typically waits between 30 and 120 seconds before releasing the port. This is to allow for delayed packets so that a new process does not receive packets from a previous process. Here, we limit the retries to 60 seconds. </p>

</div>
</div>
<a id="ga04c08dc0b0733010f3190bf6df123433" name="ga04c08dc0b0733010f3190bf6df123433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04c08dc0b0733010f3190bf6df123433">&#9670;&#160;</a></span>PORT_BIND_RETRY_LIMIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PORT_BIND_RETRY_LIMIT&#160;&#160;&#160;60</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="socket__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/socket_common.h</a>&gt;</code></p>

<p>Number of attempts to bind to a port before giving up. </p>

</div>
</div>
<a id="gae546b6c6176fe607616181e144364f2b" name="gae546b6c6176fe607616181e144364f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae546b6c6176fe607616181e144364f2b">&#9670;&#160;</a></span>RTI_NOT_EXECUTED_WITH_AUTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTI_NOT_EXECUTED_WITH_AUTH&#160;&#160;&#160;7</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Code sent with a <a class="el" href="#ga59a69d0685fdc2a216718f1efa083c4c">MSG_TYPE_REJECT</a> message indicating that the RTI was not executed using the -a or &ndash;auth option. </p>

</div>
</div>
<a id="gabd435507a255ff2571133013bdf93bd2" name="gabd435507a255ff2571133013bdf93bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd435507a255ff2571133013bdf93bd2">&#9670;&#160;</a></span>SHA256_HMAC_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SHA256_HMAC_LENGTH&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>The HMAC tag uses the SHA256 hash algorithm, creating a 32 byte length hash tag. </p>

</div>
</div>
<a id="gab1edbb864391382835b9ad71408c5c53" name="gab1edbb864391382835b9ad71408c5c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1edbb864391382835b9ad71408c5c53">&#9670;&#160;</a></span>TCP_TIMEOUT_TIME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TCP_TIMEOUT_TIME&#160;&#160;&#160;<a class="el" href="group__Constants.html#ga30e47c4dd44d168c2982d3ec1d4e0825">SEC</a>(10)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="socket__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/socket_common.h</a>&gt;</code></p>

<p>The timeout time in ns for TCP operations. </p>
<p>Default value is 10 secs. </p>

</div>
</div>
<a id="gaac9f4a449d302b4f39e69a14b3a4c8d5" name="gaac9f4a449d302b4f39e69a14b3a4c8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac9f4a449d302b4f39e69a14b3a4c8d5">&#9670;&#160;</a></span>UDP_TIMEOUT_TIME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UDP_TIMEOUT_TIME&#160;&#160;&#160;<a class="el" href="group__Constants.html#ga30e47c4dd44d168c2982d3ec1d4e0825">SEC</a>(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="socket__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/socket_common.h</a>&gt;</code></p>

<p>The timeout time in ns for UDP operations. </p>
<p>Default value is 1 sec. </p>

</div>
</div>
<a id="gae2e1a44a10d4219f4645a4e99fee009c" name="gae2e1a44a10d4219f4645a4e99fee009c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2e1a44a10d4219f4645a4e99fee009c">&#9670;&#160;</a></span>UNEXPECTED_MESSAGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNEXPECTED_MESSAGE&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Code sent with a <a class="el" href="#ga59a69d0685fdc2a216718f1efa083c4c">MSG_TYPE_REJECT</a> message indicating that the incoming message is not expected. </p>

</div>
</div>
<a id="ga5a6c87886a0136b58ae5bb1d627c7ae3" name="ga5a6c87886a0136b58ae5bb1d627c7ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a6c87886a0136b58ae5bb1d627c7ae3">&#9670;&#160;</a></span>WRONG_SERVER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define WRONG_SERVER&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_common.h</a>&gt;</code></p>

<p>Code sent with a <a class="el" href="#ga59a69d0685fdc2a216718f1efa083c4c">MSG_TYPE_REJECT</a> message indicating that the connected to the wrong server. </p>

</div>
</div>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="ga675c841ec6a29e45cacc71b61ef8d270" name="ga675c841ec6a29e45cacc71b61ef8d270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga675c841ec6a29e45cacc71b61ef8d270">&#9670;&#160;</a></span>federate_instance_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct federate_instance_t federate_instance_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Structure that a federate instance uses to keep track of its own state. </p>

</div>
</div>
<a id="gae335f4cb4e7d5e88ed712be8cf9592ac" name="gae335f4cb4e7d5e88ed712be8cf9592ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae335f4cb4e7d5e88ed712be8cf9592ac">&#9670;&#160;</a></span>federation_metadata_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct federation_metadata_t federation_metadata_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Structure for federation metadata. </p>

</div>
</div>
<a id="ga9e708b16d53622a88d5a2638affb6934" name="ga9e708b16d53622a88d5a2638affb6934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e708b16d53622a88d5a2638affb6934">&#9670;&#160;</a></span>lf_stat_ll</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct lf_stat_ll lf_stat_ll</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="clock-sync_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/clock-sync.h</a>&gt;</code></p>

<p>Holds generic statistical data. </p>

</div>
</div>
<a id="ga98d812b2acffbba5c8b1b72913513d19" name="ga98d812b2acffbba5c8b1b72913513d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98d812b2acffbba5c8b1b72913513d19">&#9670;&#160;</a></span>parse_rti_code_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="#ga9acb70e6b48452bd9d146e35bafc535c">parse_rti_code_t</a> <a class="el" href="#ga9acb70e6b48452bd9d146e35bafc535c">parse_rti_code_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Code returned by <a class="el" href="#gae612f180643d0436d4496738b957af68">lf_parse_rti_addr()</a>. </p>

</div>
</div>
<a id="gaf820f39ab52ce0a58d7ba739051b8f24" name="gaf820f39ab52ce0a58d7ba739051b8f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf820f39ab52ce0a58d7ba739051b8f24">&#9670;&#160;</a></span>rti_addr_info_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct rti_addr_info_t rti_addr_info_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_util.h</a>&gt;</code></p>

<p>A helper struct for passing rti_addr information between lf_parse_rti_addr and extract_rti_addr_info. </p>

</div>
</div>
<a id="ga7e49fed082ec884e26d761e1c4f0d428" name="ga7e49fed082ec884e26d761e1c4f0d428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e49fed082ec884e26d761e1c4f0d428">&#9670;&#160;</a></span>socket_stat_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct socket_stat_t socket_stat_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="clock-sync_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/clock-sync.h</a>&gt;</code></p>

<p>Statistics and state for clock synchronization over a socket connection. </p>
<p>This struct maintains the state and statistics needed for clock synchronization between a federate and the RTI using a variant of the Precision Time Protocol (PTP). The synchronization process involves four timestamps (T1-T4) to estimate network delays and clock offsets:</p>
<ol type="1">
<li>T1: RTI's physical time when sending sync message</li>
<li>T2: Federate's physical time when receiving T1</li>
<li>T3: Federate's physical time when sending reply</li>
<li>T4: RTI's physical time when receiving reply</li>
</ol>
<p>The round trip delay is estimated as: (T4 - T1) - (T3 - T2) The clock offset can be estimated as: ((T2 - T1) + (T3 - T4)) / 2 </p>

</div>
</div>
<a id="ga45bb50f52b617bc6a30719cbaafd075d" name="ga45bb50f52b617bc6a30719cbaafd075d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45bb50f52b617bc6a30719cbaafd075d">&#9670;&#160;</a></span>socket_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="#ga54c375e3893ff5969d20df65b90c8335">socket_type_t</a> <a class="el" href="#ga54c375e3893ff5969d20df65b90c8335">socket_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="socket__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/socket_common.h</a>&gt;</code></p>

<p>Type of socket. </p>

</div>
</div>
<a id="ga0bce8f0d13040846780f5bb02e43e81d" name="ga0bce8f0d13040846780f5bb02e43e81d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bce8f0d13040846780f5bb02e43e81d">&#9670;&#160;</a></span>staa_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct staa_t staa_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Structure for STAA (safe to assume absent). </p>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="ga9acb70e6b48452bd9d146e35bafc535c" name="ga9acb70e6b48452bd9d146e35bafc535c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9acb70e6b48452bd9d146e35bafc535c">&#9670;&#160;</a></span>parse_rti_code_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga9acb70e6b48452bd9d146e35bafc535c">parse_rti_code_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Code returned by <a class="el" href="#gae612f180643d0436d4496738b957af68">lf_parse_rti_addr()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9acb70e6b48452bd9d146e35bafc535cac7f69f7c9e5aea9b8f54cf02870e2bf8" name="gga9acb70e6b48452bd9d146e35bafc535cac7f69f7c9e5aea9b8f54cf02870e2bf8"></a>SUCCESS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga9acb70e6b48452bd9d146e35bafc535cad65c958d0ccb000b69ef0ef4e3a5bfdf" name="gga9acb70e6b48452bd9d146e35bafc535cad65c958d0ccb000b69ef0ef4e3a5bfdf"></a>INVALID_PORT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga9acb70e6b48452bd9d146e35bafc535caea85d37354b294f21e7ab9c5c142a237" name="gga9acb70e6b48452bd9d146e35bafc535caea85d37354b294f21e7ab9c5c142a237"></a>INVALID_HOST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga9acb70e6b48452bd9d146e35bafc535ca1dbf923bd60da7209a684ed484935973" name="gga9acb70e6b48452bd9d146e35bafc535ca1dbf923bd60da7209a684ed484935973"></a>INVALID_USER&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga9acb70e6b48452bd9d146e35bafc535ca3ad4ab464aba04397206e8b89aa1955a" name="gga9acb70e6b48452bd9d146e35bafc535ca3ad4ab464aba04397206e8b89aa1955a"></a>FAILED_TO_PARSE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ga54c375e3893ff5969d20df65b90c8335" name="ga54c375e3893ff5969d20df65b90c8335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54c375e3893ff5969d20df65b90c8335">&#9670;&#160;</a></span>socket_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga54c375e3893ff5969d20df65b90c8335">socket_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="socket__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/socket_common.h</a>&gt;</code></p>

<p>Type of socket. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga54c375e3893ff5969d20df65b90c8335aa040cd7feeb588104634cdadf35abf1c" name="gga54c375e3893ff5969d20df65b90c8335aa040cd7feeb588104634cdadf35abf1c"></a>TCP&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga54c375e3893ff5969d20df65b90c8335adb542475cf9d0636e4225e216cee9ae6" name="gga54c375e3893ff5969d20df65b90c8335adb542475cf9d0636e4225e216cee9ae6"></a>UDP&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ga3f3dfc2ccd62e181467f7a22ab5ebe49" name="ga3f3dfc2ccd62e181467f7a22ab5ebe49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f3dfc2ccd62e181467f7a22ab5ebe49">&#9670;&#160;</a></span>accept_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int accept_socket </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>rti_socket</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="socket__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/socket_common.h</a>&gt;</code></p>

<p>Wait for an incoming connection request on the specified server socket. </p>
<p>This blocks until a connection is successfully accepted. If an error occurs that is not temporary (e.g., <span class="tt">EAGAIN</span> or <span class="tt">EWOULDBLOCK</span>), it reports the error and exits. Temporary errors cause the function to retry accepting the connection.</p>
<p>If the <span class="tt">rti_socket</span> is not -1, this function checks whether the specified socket is still open. If it is not open, then this function returns -1. This is useful for federates to determine whether they are still connected to the federation and to stop waiting when they are not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The server socket file descriptor that is listening for incoming connections. </td></tr>
    <tr><td class="paramname">rti_socket</td><td>The rti socket for the federate to check if it is still open. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The file descriptor for the newly accepted socket on success, or -1 on failure (with an appropriate error message printed). </dd></dl>

</div>
</div>
<a id="ga6b3edec4d337711a2e914c9f5581ce1c" name="ga6b3edec4d337711a2e914c9f5581ce1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b3edec4d337711a2e914c9f5581ce1c">&#9670;&#160;</a></span>clock_sync_add_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clock_sync_add_offset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a> *</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="clock-sync_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/clock-sync.h</a>&gt;</code></p>

<p>Add the current clock synchronization offset to a specified timestamp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Pointer to the timestamp to which to add the offset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4f1aaaa9e0b74867ba6b60eb962dfca6" name="ga4f1aaaa9e0b74867ba6b60eb962dfca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f1aaaa9e0b74867ba6b60eb962dfca6">&#9670;&#160;</a></span>clock_sync_set_constant_bias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clock_sync_set_constant_bias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="clock-sync_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/clock-sync.h</a>&gt;</code></p>

<p>Set a fixed offset to the physical clock. </p>
<p>After calling this, the value returned by <a class="el" href="group__API.html#ga7538766a655ba2e60ddde55f2e020e58" title="Return the current physical time in nanoseconds.">lf_time_physical(void)</a> and get_elpased_physical_time(void) will have this specified offset added to what it would have returned before the call. </p>

</div>
</div>
<a id="gaf5fb44eb0db80b9dfa61399bdab8b85c" name="gaf5fb44eb0db80b9dfa61399bdab8b85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5fb44eb0db80b9dfa61399bdab8b85c">&#9670;&#160;</a></span>clock_sync_subtract_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clock_sync_subtract_offset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a> *</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="clock-sync_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/clock-sync.h</a>&gt;</code></p>

<p>Subtract the clock synchronization offset from a timestamp. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The timestamp from which to subtract the current clock sync offset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5ac5b1b8bf1c832cbdd2f6cdbb769df8" name="ga5ac5b1b8bf1c832cbdd2f6cdbb769df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ac5b1b8bf1c832cbdd2f6cdbb769df8">&#9670;&#160;</a></span>connect_to_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int connect_to_socket </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>hostname</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>port</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="socket__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/socket_common.h</a>&gt;</code></p>

<p>Attempt to establish a TCP connection to the specified hostname and port. </p>
<p>Attempt to establish a TCP connection to the specified hostname and port. This function uses <span class="tt">getaddrinfo</span> to resolve the hostname and retries the connection periodically if it fails. If the specified port is 0, it iterates through a range of default ports starting from <span class="tt">DEFAULT_PORT</span>. The function will stop retrying if the <span class="tt">CONNECT_TIMEOUT</span> is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sock</td><td>The socket file descriptor that has already been created (using <span class="tt">socket()</span>). </td></tr>
    <tr><td class="paramname">hostname</td><td>The hostname or IP address of the server to connect to. </td></tr>
    <tr><td class="paramname">port</td><td>The port number to connect to. If 0 is specified, a default port range will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure, and <span class="tt">errno</span> is set to indicate the specific error. </dd></dl>

</div>
</div>
<a id="gac094b53ced87d3cbd617a66591f4282a" name="gac094b53ced87d3cbd617a66591f4282a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac094b53ced87d3cbd617a66591f4282a">&#9670;&#160;</a></span>create_clock_sync_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int create_clock_sync_thread </td>
          <td>(</td>
          <td class="paramtype">lf_thread_t *</td>          <td class="paramname"><span class="paramname"><em>thread_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="clock-sync_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/clock-sync.h</a>&gt;</code></p>

<p>Create the thread responsible for handling clock synchronization with the RTI if (runtime) clock synchronization is on. </p>
<p>Otherwise, do nothing and return 0.</p>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 0; On error, it returns an error number. </dd></dl>

</div>
</div>
<a id="ga10b0373c1cff0213b17cb7308949f0a2" name="ga10b0373c1cff0213b17cb7308949f0a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10b0373c1cff0213b17cb7308949f0a2">&#9670;&#160;</a></span>create_real_time_tcp_socket_errexit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int create_real_time_tcp_socket_errexit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="socket__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/socket_common.h</a>&gt;</code></p>

<p>Create an IPv4 TCP socket with Nagle's algorithm disabled. </p>
<p>This uses TCP_NODELAY and Delayed ACKs disabled with TCP_QUICKACK. It exits application on any error.</p>
<dl class="section return"><dt>Returns</dt><dd>The socket ID (a file descriptor). </dd></dl>

</div>
</div>
<a id="ga94aaee169c4c822e4c9e6a73f59a6952" name="ga94aaee169c4c822e4c9e6a73f59a6952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94aaee169c4c822e4c9e6a73f59a6952">&#9670;&#160;</a></span>create_server()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int create_server </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>final_socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *</td>          <td class="paramname"><span class="paramname"><em>final_port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga54c375e3893ff5969d20df65b90c8335">socket_type_t</a></td>          <td class="paramname"><span class="paramname"><em>sock_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>increment_port_on_retry</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="socket__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/socket_common.h</a>&gt;</code></p>

<p>Create a TCP server that listens for socket connections. </p>
<p>If the specified port number is greater than zero, this function will attempt to acquire that port. If the specified port number is zero, and the increment_port_on_retry is true, it will attempt to acquire DEFAULT_PORT. If it fails to acquire DEFAULT_PORT, then it will increment the port number from DEFAULT_PORT on each attempt until it has incremented MAX_NUM_PORT_ADDRESSES times, at which point it will cycle around and begin again with DEFAULT_PORT. If the port number is zero, and the increment_port_on_retry is false, it delegates to the operating system to provide an available port number. If acquiring the port fails, then this function will repeatedly attempt up to PORT_BIND_RETRY_LIMIT times with a delay of PORT_BIND_RETRY_INTERVAL in between each try.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port number to use or 0 to let the OS pick or 1 to start trying at DEFAULT_PORT. </td></tr>
    <tr><td class="paramname">final_socket</td><td>Pointer to the returned socket descriptor on which accepting connections will occur. </td></tr>
    <tr><td class="paramname">final_port</td><td>Pointer to the final port the server will use. </td></tr>
    <tr><td class="paramname">sock_type</td><td>Type of the socket, TCP or UDP. </td></tr>
    <tr><td class="paramname">increment_port_on_retry</td><td>Boolean to retry port increment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, -1 for failure. </dd></dl>

</div>
</div>
<a id="gafc6b3d0e0e777738422c11fa07b35e0f" name="gafc6b3d0e0e777738422c11fa07b35e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc6b3d0e0e777738422c11fa07b35e0f">&#9670;&#160;</a></span>encode_int32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void encode_int32 </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_util.h</a>&gt;</code></p>

<p>Write the specified data as a sequence of bytes starting at the specified address. </p>
<p>This encodes the data in little-endian order (lowest order byte first). This works for int32_t. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to write. </td></tr>
    <tr><td class="paramname">buffer</td><td>The location to start writing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae233fa02382ed619a78b1c32e14a8657" name="gae233fa02382ed619a78b1c32e14a8657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae233fa02382ed619a78b1c32e14a8657">&#9670;&#160;</a></span>encode_int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void encode_int64 </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_util.h</a>&gt;</code></p>

<p>Write the specified data as a sequence of bytes starting at the specified address. </p>
<p>This encodes the data in little-endian order (lowest order byte first). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to write. </td></tr>
    <tr><td class="paramname">buffer</td><td>The location to start writing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7b5ae6582f28e14a37d50a2d243613c5" name="ga7b5ae6582f28e14a37d50a2d243613c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b5ae6582f28e14a37d50a2d243613c5">&#9670;&#160;</a></span>encode_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void encode_tag </td>
          <td>(</td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_util.h</a>&gt;</code></p>

<p>Encode tag information into buffer. </p>
<p>Buffer must have been allocated externally. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to encode into. </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to encode into 'buffer'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafad4dadc9bbc06596be44e7ecc4c7281" name="gafad4dadc9bbc06596be44e7ecc4c7281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafad4dadc9bbc06596be44e7ecc4c7281">&#9670;&#160;</a></span>encode_uint16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void encode_uint16 </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_util.h</a>&gt;</code></p>

<p>Write the specified data as a sequence of bytes starting at the specified address. </p>
<p>This encodes the data in little-endian order (lowest order byte first). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to write. </td></tr>
    <tr><td class="paramname">buffer</td><td>The location to start writing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9b75c9d94d4f3d34d52f46c65cf950d4" name="ga9b75c9d94d4f3d34d52f46c65cf950d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b75c9d94d4f3d34d52f46c65cf950d4">&#9670;&#160;</a></span>encode_uint32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void encode_uint32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_util.h</a>&gt;</code></p>

<p>Write the specified data as a sequence of bytes starting at the specified address. </p>
<p>This encodes the data in little-endian order (lowest order byte first). This works for uint32_t. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to write. </td></tr>
    <tr><td class="paramname">buffer</td><td>The location to start writing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga82060dae45e1c3b922005e56829c9814" name="ga82060dae45e1c3b922005e56829c9814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82060dae45e1c3b922005e56829c9814">&#9670;&#160;</a></span>extract_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void extract_header </td>
          <td>(</td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *</td>          <td class="paramname"><span class="paramname"><em>port_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *</td>          <td class="paramname"><span class="paramname"><em>federate_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_util.h</a>&gt;</code></p>

<p>Extract the core header information that all messages between federates share. </p>
<p>The core header information is two bytes with the ID of the destination port, two bytes with the ID of the destination federate, and four bytes with the length of the message. </p><dl class="section note"><dt>Note</dt><dd>Only present when federated execution is enabled. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to read from. </td></tr>
    <tr><td class="paramname">port_id</td><td>The place to put the port ID. </td></tr>
    <tr><td class="paramname">federate_id</td><td>The place to put the federate ID. </td></tr>
    <tr><td class="paramname">length</td><td>The place to put the length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8f772b5761c6b74b4136db6ee021e6c5" name="ga8f772b5761c6b74b4136db6ee021e6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f772b5761c6b74b4136db6ee021e6c5">&#9670;&#160;</a></span>extract_int32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t extract_int32 </td>
          <td>(</td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>bytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_util.h</a>&gt;</code></p>

<p>This will swap the order of the bytes if this machine is big endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>The address of the start of the sequence of bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8decc0f4a38aa42fbc6ccfb029e3a061" name="ga8decc0f4a38aa42fbc6ccfb029e3a061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8decc0f4a38aa42fbc6ccfb029e3a061">&#9670;&#160;</a></span>extract_int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t extract_int64 </td>
          <td>(</td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>bytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_util.h</a>&gt;</code></p>

<p>This will swap the order of the bytes if this machine is big endian. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>The address of the start of the sequence of bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8ec38908b111a79943446bfbdec188f0" name="ga8ec38908b111a79943446bfbdec188f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ec38908b111a79943446bfbdec188f0">&#9670;&#160;</a></span>extract_match_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool extract_match_group </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>rti_addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regmatch_t</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>max_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>min_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>err_msg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_util.h</a>&gt;</code></p>

<p>Extract one match group from the rti_addr regex . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rti_addr</td><td>The rti_addr to extract from. </td></tr>
    <tr><td class="paramname">dest</td><td>The destination to store the match group. </td></tr>
    <tr><td class="paramname">group</td><td>The group to extract. </td></tr>
    <tr><td class="paramname">max_len</td><td>The maximum length of the match group. </td></tr>
    <tr><td class="paramname">min_len</td><td>The minimum length of the match group. </td></tr>
    <tr><td class="paramname">err_msg</td><td>The error message to return if there is an error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if SUCCESS, else false. </dd></dl>

</div>
</div>
<a id="ga50c7f94caa2a61bcba5f89535da07036" name="ga50c7f94caa2a61bcba5f89535da07036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50c7f94caa2a61bcba5f89535da07036">&#9670;&#160;</a></span>extract_match_groups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool extract_match_groups </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>rti_addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>rti_addr_strs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool **</td>          <td class="paramname"><span class="paramname"><em>rti_addr_flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">regmatch_t *</td>          <td class="paramname"><span class="paramname"><em>group_array</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>gids</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>max_lens</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>min_lens</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>err_msgs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_util.h</a>&gt;</code></p>

<p>Extract match groups from the rti_addr regex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rti_addr</td><td>The rti_addr to extract from. </td></tr>
    <tr><td class="paramname">rti_addr_strs</td><td>The array of rti_addr strings to store the match groups. </td></tr>
    <tr><td class="paramname">rti_addr_flags</td><td>The array of rti_addr flags to store the match groups. </td></tr>
    <tr><td class="paramname">group_array</td><td>The array of regmatch_t to store the match groups. </td></tr>
    <tr><td class="paramname">gids</td><td>The array of gids to store the match groups. </td></tr>
    <tr><td class="paramname">max_lens</td><td>The array of max_lens to store the match groups. </td></tr>
    <tr><td class="paramname">min_lens</td><td>The array of min_lens to store the match groups. </td></tr>
    <tr><td class="paramname">err_msgs</td><td>The array of error messages to store the match groups. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if success, else false. </dd></dl>

</div>
</div>
<a id="ga0737fc3d45aae606811f57a16ad87208" name="ga0737fc3d45aae606811f57a16ad87208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0737fc3d45aae606811f57a16ad87208">&#9670;&#160;</a></span>extract_rti_addr_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void extract_rti_addr_info </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>rti_addr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrti__addr__info__t.html">rti_addr_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>rti_addr_info</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_util.h</a>&gt;</code></p>

<p>Extract the host, port and user from rti_addr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rti_addr</td><td>The rti_addr to extract from. </td></tr>
    <tr><td class="paramname">rti_addr_info</td><td>The rti_addr_info into which to store the extracted information. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9cd95311c2c29ce5bed1c44d5336584d" name="ga9cd95311c2c29ce5bed1c44d5336584d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cd95311c2c29ce5bed1c44d5336584d">&#9670;&#160;</a></span>extract_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtag__t.html">tag_t</a> extract_tag </td>
          <td>(</td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_util.h</a>&gt;</code></p>

<p>Extract tag information from buffer. </p>
<p>The tag is transmitted as a 64-bit (8 byte) signed integer for time and a 32-bit (4 byte) unsigned integer for microstep. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted tag. </dd></dl>

</div>
</div>
<a id="ga8e2cc45fc8571af05bb05f4952d4cde5" name="ga8e2cc45fc8571af05bb05f4952d4cde5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e2cc45fc8571af05bb05f4952d4cde5">&#9670;&#160;</a></span>extract_timed_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void extract_timed_header </td>
          <td>(</td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *</td>          <td class="paramname"><span class="paramname"><em>port_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *</td>          <td class="paramname"><span class="paramname"><em>federate_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_util.h</a>&gt;</code></p>

<p>Extract the timed header information for timed messages between federates. </p>
<p>This is two bytes with the ID of the destination port, two bytes with the ID of the destination federate, four bytes with the length of the message, eight bytes with a timestamp, and four bytes with a microstep. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to read from. </td></tr>
    <tr><td class="paramname">port_id</td><td>The place to put the port ID. </td></tr>
    <tr><td class="paramname">federate_id</td><td>The place to put the federate ID. </td></tr>
    <tr><td class="paramname">length</td><td>The place to put the length. </td></tr>
    <tr><td class="paramname">tag</td><td>The place to put the tag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1686d838d49741a6ff2ee65bd766a987" name="ga1686d838d49741a6ff2ee65bd766a987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1686d838d49741a6ff2ee65bd766a987">&#9670;&#160;</a></span>extract_uint16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t extract_uint16 </td>
          <td>(</td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>bytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_util.h</a>&gt;</code></p>

<p>Extract an uint16_t from the specified byte sequence. </p>
<p>This will swap the order of the bytes if this machine is big endian. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>The address of the start of the sequence of bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gace14df89540b56b069c6c619e8f37493" name="gace14df89540b56b069c6c619e8f37493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace14df89540b56b069c6c619e8f37493">&#9670;&#160;</a></span>handle_T1_clock_sync_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int handle_T1_clock_sync_message </td>
          <td>(</td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a></td>          <td class="paramname"><span class="paramname"><em>t2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="clock-sync_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/clock-sync.h</a>&gt;</code></p>

<p>Handle a clock synchroninzation message T1 coming from the RTI. </p>
<p>T1 is the first message in a PTP exchange. This replies to the RTI with a T3 message. It also measures the time it takes between when the method is called and the reply has been sent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer containing the message, including the message type. </td></tr>
    <tr><td class="paramname">socket</td><td>The socket (either _lf_rti_socket_TCP or _lf_rti_socket_UDP). </td></tr>
    <tr><td class="paramname">t2</td><td>The physical time at which the T1 message was received. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if T3 reply is successfully sent, -1 otherwise. </dd></dl>

</div>
</div>
<a id="ga1b35d21eda090ea4bf8a79f401dbdad0" name="ga1b35d21eda090ea4bf8a79f401dbdad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b35d21eda090ea4bf8a79f401dbdad0">&#9670;&#160;</a></span>handle_T4_clock_sync_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_T4_clock_sync_message </td>
          <td>(</td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a></td>          <td class="paramname"><span class="paramname"><em>r4</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="clock-sync_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/clock-sync.h</a>&gt;</code></p>

<p>Handle a clock synchronization message T4 coming from the RTI. </p>
<p>If the socket is _lf_rti_socket_TCP, then assume we are in the initial clock synchronization phase and set the clock offset based on the estimated clock synchronization error. Otherwise, if the socket is _lf_rti_socket_UDP, then this looks also for a subsequent "coded probe" message on the socket. If the delay between the T4 and the coded probe message is not as expected, then reject this clock synchronization round. If it is not rejected, then make an adjustment to the clock offset based on the estimated error. This function does not acquire the socket_mutex lock. The caller should acquire it unless it is sure there is only one thread running. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer containing the message, including the message type. </td></tr>
    <tr><td class="paramname">socket</td><td>The socket (either _lf_rti_socket_TCP or _lf_rti_socket_UDP). </td></tr>
    <tr><td class="paramname">r4</td><td>The physical time at which this T4 message was received. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad791461950852eb074b90bc75156b413" name="gad791461950852eb074b90bc75156b413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad791461950852eb074b90bc75156b413">&#9670;&#160;</a></span>host_is_big_endian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int host_is_big_endian </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_util.h</a>&gt;</code></p>

<p>Return true (1) if the host is big endian. </p>
<p>Otherwise, return false. </p>

</div>
</div>
<a id="gadc2dc02aa0e242eab3574240e90984b4" name="gadc2dc02aa0e242eab3574240e90984b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc2dc02aa0e242eab3574240e90984b4">&#9670;&#160;</a></span>init_shutdown_mutex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_shutdown_mutex </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="socket__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/socket_common.h</a>&gt;</code></p>

<p>Initialize shutdown mutex. </p>
<p>This is used to synchronize the shutdown of the federate. </p>

</div>
</div>
<a id="ga26b7c3ab8c2a50f65e53997a6f26a0dc" name="ga26b7c3ab8c2a50f65e53997a6f26a0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26b7c3ab8c2a50f65e53997a6f26a0dc">&#9670;&#160;</a></span>lf_connect_to_federate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_connect_to_federate </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>remote_federate_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Connect to the federate with the specified id. </p>
<p>The established connection will then be used in functions such as <a class="el" href="#ga0931fe1bb9eac2a9beebe0c0ed03408e" title="Send a tagged message to the specified port of the specified federate.">lf_send_tagged_message()</a> to send messages directly to the specified federate. This function first sends an MSG_TYPE_ADDRESS_QUERY message to the RTI to obtain the IP address and port number of the specified federate. It then attempts to establish a socket connection to the specified federate. If this fails, the program exits. If it succeeds, it sets element [id] of the _fed.sockets_for_outbound_p2p_connections global array to refer to the socket for communicating directly with the federate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remote_federate_id</td><td>The ID of the remote federate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga92e8c30255091911a80601bf341cf0a2" name="ga92e8c30255091911a80601bf341cf0a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92e8c30255091911a80601bf341cf0a2">&#9670;&#160;</a></span>lf_connect_to_rti()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_connect_to_rti </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>hostname</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>port_number</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Connect to the RTI at the specified host and port. </p>
<p>This will return the socket descriptor for the connection. If port_number is 0, then start at DEFAULT_PORT and increment the port number on each attempt. If an attempt fails, wait CONNECT_RETRY_INTERVAL and try again. If it fails after CONNECT_TIMEOUT, the program exits. If it succeeds, it sets the _fed.socket_TCP_RTI global variable to refer to the socket for communicating with the RTI.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hostname</td><td>A hostname, such as "localhost". </td></tr>
    <tr><td class="paramname">port_number</td><td>A port number or 0 to start with the default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga926a4fb7f9b045acb13fee6c2b7192dd" name="ga926a4fb7f9b045acb13fee6c2b7192dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga926a4fb7f9b045acb13fee6c2b7192dd">&#9670;&#160;</a></span>lf_create_server()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_create_server </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>specified_port</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Create a server to listen to incoming P2P connections. </p>
<p>Such connections are used for physical connections or any connection if using decentralized coordination. This function only handles the creation of the server socket. The bound port for the server socket is then sent to the RTI by sending an MSG_TYPE_ADDRESS_ADVERTISEMENT message (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="net__common_8h.html" title="Common message types and definitions for federated Lingua Franca programs.">net_common.h</a>). This function expects no response from the <a class="el" href="group__RTI.html" title="Functions for the runtime infrastructure for federated execution.">RTI</a>.</dd></dl>
<p>If a port is specified by the user, that will be used. Otherwise, a random port will be assigned. If the bind fails, it will retry after PORT_BIND_RETRY_INTERVAL until it has tried PORT_BIND_RETRY_LIMIT times. Then it will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">specified_port</td><td>The port specified by the user or 0 to use a random port. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae427b4c0340dbe19d46c93708fb6151a" name="gae427b4c0340dbe19d46c93708fb6151a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae427b4c0340dbe19d46c93708fb6151a">&#9670;&#160;</a></span>lf_enqueue_port_absent_reactions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_enqueue_port_absent_reactions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Enqueue port absent reactions. </p>
<p>These reactions will send a MSG_TYPE_PORT_ABSENT message to downstream federates if a given network output port is not present.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment of the federate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab4b57d55b69a4864eb694ed080b84d0e" name="gab4b57d55b69a4864eb694ed080b84d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4b57d55b69a4864eb694ed080b84d0e">&#9670;&#160;</a></span>lf_get_fed_maxwait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> lf_get_fed_maxwait </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor.h</a>&gt;</code></p>

<p>Return the global maxwait for the current federate. </p>

</div>
</div>
<a id="gae03d197bf8d64f82be4a68c95a940195" name="gae03d197bf8d64f82be4a68c95a940195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae03d197bf8d64f82be4a68c95a940195">&#9670;&#160;</a></span>lf_get_sta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> lf_get_sta </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor.h</a>&gt;</code></p>

<p>Return the global STA (safe to advance) offset for federated execution. </p>

</div>
</div>
<a id="gaf7ba635fb6ffa82e4b05a51d4fc0020f" name="gaf7ba635fb6ffa82e4b05a51d4fc0020f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7ba635fb6ffa82e4b05a51d4fc0020f">&#9670;&#160;</a></span>lf_handle_p2p_connections_from_federates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * lf_handle_p2p_connections_from_federates </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ignored</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Thread to accept connections from other federates. </p>
<p>This thread accepts connections from federates that send messages directly to this one (not through the RTI). This thread starts a thread for each accepted socket connection to read messages and, once it has opened all expected sockets, exits. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ignored</td><td>No argument needed for this thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga80af1b6a9d7200df3d85c534edd8cbbc" name="ga80af1b6a9d7200df3d85c534edd8cbbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80af1b6a9d7200df3d85c534edd8cbbc">&#9670;&#160;</a></span>lf_latest_tag_confirmed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_latest_tag_confirmed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>tag_to_send</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Send a latest tag confirmed (LTC) signal to the RTI. </p>
<p>This avoids the send if an equal or later LTC has previously been sent.</p>
<p>This function assumes the caller holds the mutex lock on the top-level environment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag_to_send</td><td>The tag to send. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae612f180643d0436d4496738b957af68" name="gae612f180643d0436d4496738b957af68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae612f180643d0436d4496738b957af68">&#9670;&#160;</a></span>lf_parse_rti_addr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga9acb70e6b48452bd9d146e35bafc535c">parse_rti_code_t</a> lf_parse_rti_addr </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>rti_addr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Parse the address of the RTI and store them into the global federation_metadata struct. </p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="#ga9acb70e6b48452bd9d146e35bafc535c" title="Code returned by lf_parse_rti_addr().">parse_rti_code_t</a> indicating the result of the parse. </dd></dl>

</div>
</div>
<a id="gae3bc503fcbeaffe48f4500fddba4b21a" name="gae3bc503fcbeaffe48f4500fddba4b21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3bc503fcbeaffe48f4500fddba4b21a">&#9670;&#160;</a></span>lf_reset_status_fields_on_input_port_triggers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_reset_status_fields_on_input_port_triggers </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Reset the status fields on network input ports to unknown or absent. </p>
<p>This will reset to absent if the last_known_status_tag field of the port is greater than or equal to the current tag of the top-level environment. This should be overriden to present if an event gets scheduled. Otherwise, set the status to unknown. </p><dl class="section note"><dt>Note</dt><dd>This function must be called at the beginning of each logical time. </dd></dl>

</div>
</div>
<a id="ga2f330bfe2fdb03cbf49596bcc012bc58" name="ga2f330bfe2fdb03cbf49596bcc012bc58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f330bfe2fdb03cbf49596bcc012bc58">&#9670;&#160;</a></span>lf_send_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lf_send_message </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>message_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short</td>          <td class="paramname"><span class="paramname"><em>port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short</td>          <td class="paramname"><span class="paramname"><em>federate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>next_destination_str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>message</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Send a message to another federate. </p>
<p>This function is used for physical connections between federates. If the socket connection to the remote federate or the RTI has been broken, then this returns -1 without sending. Otherwise, it returns 0.</p>
<p>This method assumes that the caller does not hold the lf_outbound_socket_mutex lock, which it acquires to perform the send.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_type</td><td>The type of the message being sent (currently only MSG_TYPE_P2P_MESSAGE). </td></tr>
    <tr><td class="paramname">port</td><td>The ID of the destination port. </td></tr>
    <tr><td class="paramname">federate</td><td>The ID of the destination federate. </td></tr>
    <tr><td class="paramname">next_destination_str</td><td>The name of the next destination in string format (for reporting). </td></tr>
    <tr><td class="paramname">length</td><td>The message length. </td></tr>
    <tr><td class="paramname">message</td><td>The message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the message has been sent, -1 otherwise. </dd></dl>

</div>
</div>
<a id="ga131226459d7dacc6068c0a6d1d9ebde1" name="ga131226459d7dacc6068c0a6d1d9ebde1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga131226459d7dacc6068c0a6d1d9ebde1">&#9670;&#160;</a></span>lf_send_neighbor_structure_to_RTI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_send_neighbor_structure_to_RTI </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>socket_TCP_RTI</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Send information about connections to the RTI. </p>
<p>This is a generated function that sends information about connections between this federate and other federates where messages are routed through the RTI. Currently, this only includes logical connections when the coordination is centralized. This information is needed for the RTI to perform the centralized coordination. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga48ec489cb1543b161c262f4bee6c9598">MSG_TYPE_NEIGHBOR_STRUCTURE</a> in <a class="el" href="net__common_8h.html">net_common.h</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_TCP_RTI</td><td>The socket descriptor for the connection to the RTI. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga33d69f68b22b5143c029f463d6efba4f" name="ga33d69f68b22b5143c029f463d6efba4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33d69f68b22b5143c029f463d6efba4f">&#9670;&#160;</a></span>lf_send_next_event_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtag__t.html">tag_t</a> lf_send_next_event_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>wait_for_reply</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Send a next event tag (NET) signal. </p>
<p>If this federate depends on upstream federates or sends data to downstream federates, then send to the RTI a NET, which will give the tag of the earliest event on the event queue, or, if the queue is empty, the timeout time, or, if there is no timeout, FOREVER.</p>
<p>If there are network outputs that depend on physical actions, then insert a dummy event to ensure this federate advances its tag so that downstream federates can make progress.</p>
<p>A NET is a promise saying that, absent network inputs, this federate will not produce an output message with tag earlier than the NET value.</p>
<p>If there are upstream federates, then after sending a NET, this will block until either the RTI grants the advance to the requested time or the wait for the response from the RTI is interrupted by a change in the event queue (e.g., a physical action triggered or a network message arrived). If there are no upstream federates, then it will not wait for a TAG (which won't be forthcoming anyway) and returns the earliest tag on the event queue.</p>
<p>If the federate has neither upstream nor downstream federates, then this returns the specified tag immediately without sending anything to the RTI.</p>
<p>If there is at least one physical action somewhere in the federate that can trigger an output to a downstream federate, then the NET is required to be less than the current physical time. If physical time is less than the earliest event in the event queue (or the event queue is empty), then this function will insert a dummy event with a tag equal to the current physical time (and a microstep of 0). This will enforce advancement of tag for this federate and causes a NET message to be sent repeatedly as physical time advances with the time interval between messages controlled by the target parameter coordination-options: {advance-message-interval timevalue}. It will stop creating dummy events if and when its event queue has an event with a timestamp less than physical time.</p>
<p>If wait_for_reply is false, then this function will simply send the specified tag and return that tag immediately. This is useful when a federate is shutting down and will not be sending any more messages at all.</p>
<p>In all cases, this returns either the specified tag or another tag when it is safe to advance logical time to the returned tag. The returned tag may be less than the specified tag if there are upstream federates and either the RTI responds with a lesser tag or the wait for a response from the RTI is interrupted by a change in the event queue.</p>
<p>This function is used in centralized coordination only.</p>
<p>This function assumes the caller holds the mutex lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment of the federate </td></tr>
    <tr><td class="paramname">tag</td><td>The tag. </td></tr>
    <tr><td class="paramname">wait_for_reply</td><td>If true, wait for a reply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga527e8cd401ba68b503403706815ed1a0" name="ga527e8cd401ba68b503403706815ed1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga527e8cd401ba68b503403706815ed1a0">&#9670;&#160;</a></span>lf_send_port_absent_to_federate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_send_port_absent_to_federate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a></td>          <td class="paramname"><span class="paramname"><em>additional_delay</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short</td>          <td class="paramname"><span class="paramname"><em>port_ID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short</td>          <td class="paramname"><span class="paramname"><em>fed_ID</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Send a port absent message. </p>
<p>This informs the remote federate that it will not receive a message with tag less than the current tag of the specified environment delayed by the additional_delay.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment from which to get the current tag. </td></tr>
    <tr><td class="paramname">additional_delay</td><td>The after delay of the connection or NEVER if none. </td></tr>
    <tr><td class="paramname">port_ID</td><td>The ID of the receiving port. </td></tr>
    <tr><td class="paramname">fed_ID</td><td>The fed ID of the receiving federate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab4d7e691d4b52f2c0dac90e772d86dd5" name="gab4d7e691d4b52f2c0dac90e772d86dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4d7e691d4b52f2c0dac90e772d86dd5">&#9670;&#160;</a></span>lf_send_stop_request_to_rti()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lf_send_stop_request_to_rti </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>stop_tag</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Send a MSG_TYPE_STOP_REQUEST message to the RTI. </p>
<p>The payload is the specified tag plus one microstep. If this federate has previously received a stop request from the RTI, then do not send the message and return 1. Return -1 if the socket is disconnected. Otherwise, return 0. </p><dl class="section return"><dt>Returns</dt><dd>0 if the message is sent. </dd></dl>

</div>
</div>
<a id="ga0931fe1bb9eac2a9beebe0c0ed03408e" name="ga0931fe1bb9eac2a9beebe0c0ed03408e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0931fe1bb9eac2a9beebe0c0ed03408e">&#9670;&#160;</a></span>lf_send_tagged_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lf_send_tagged_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a></td>          <td class="paramname"><span class="paramname"><em>additional_delay</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>message_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short</td>          <td class="paramname"><span class="paramname"><em>port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short</td>          <td class="paramname"><span class="paramname"><em>federate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>next_destination_str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>message</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Send a tagged message to the specified port of the specified federate. </p>
<p>The tag will be the current tag of the specified environment delayed by the specified additional_delay. If the delayed tag falls after the timeout time, then the message is not sent and -1 is returned. The caller can reuse or free the memory storing the message after this returns.</p>
<p>If the message fails to send (e.g. the socket connection is broken), then the response depends on the message_type. For MSG_TYPE_TAGGED_MESSAGE, the message is supposed to go via the RTI, and failure to communicate with the RTI is a critical failure. In this case, the program will exit with an error message. If the message type is MSG_TYPE_P2P_TAGGED_MESSAGE, then the failure is not critical. It may be due to the remote federate having exited, for example, because its safe-to-process offset led it to believe that there were no messages forthcoming. In this case, on failure to send the message, this function returns -11.</p>
<p>This method assumes that the caller does not hold the lf_outbound_socket_mutex lock, which it acquires to perform the send.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment from which to get the current tag. </td></tr>
    <tr><td class="paramname">additional_delay</td><td>The after delay on the connection or NEVER is there is none. </td></tr>
    <tr><td class="paramname">message_type</td><td>The type of the message being sent. Currently can be MSG_TYPE_TAGGED_MESSAGE for messages sent via the RTI or MSG_TYPE_P2P_TAGGED_MESSAGE for messages sent directly between federates. </td></tr>
    <tr><td class="paramname">port</td><td>The ID of the destination port. </td></tr>
    <tr><td class="paramname">federate</td><td>The ID of the destination federate. </td></tr>
    <tr><td class="paramname">next_destination_str</td><td>The next destination in string format (RTI or federate) (used for reporting errors). </td></tr>
    <tr><td class="paramname">length</td><td>The message length. </td></tr>
    <tr><td class="paramname">message</td><td>The message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the message has been sent, 1 otherwise. </dd></dl>

</div>
</div>
<a id="ga952c8552f9e327a465f3db2f72d8415e" name="ga952c8552f9e327a465f3db2f72d8415e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga952c8552f9e327a465f3db2f72d8415e">&#9670;&#160;</a></span>lf_set_fed_maxwait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_set_fed_maxwait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor.h</a>&gt;</code></p>

<p>Set the global maxwait for the current federate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>A non-negative time value to be applied as the maxwait. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga032d945ee3fd6995a5f7bb15b57f2ddf" name="ga032d945ee3fd6995a5f7bb15b57f2ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga032d945ee3fd6995a5f7bb15b57f2ddf">&#9670;&#160;</a></span>lf_set_federation_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_set_federation_id </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>fid</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Set the federation_id of this federate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fid</td><td>The federation ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaccbc0981eff8f1f1726075d2ee4ba0ef" name="gaccbc0981eff8f1f1726075d2ee4ba0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccbc0981eff8f1f1726075d2ee4ba0ef">&#9670;&#160;</a></span>lf_set_sta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_set_sta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor.h</a>&gt;</code></p>

<p>Set the global STA (safe to advance) offset for federated execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>A non-negative time value to be applied as the STA offset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3aff644df1b85540aa6a3d2997f819c5" name="ga3aff644df1b85540aa6a3d2997f819c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3aff644df1b85540aa6a3d2997f819c5">&#9670;&#160;</a></span>lf_spawn_staa_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_spawn_staa_thread </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Spawn a thread to iterate through STAA structs. </p>
<p>This will set their associated ports absent at an offset if the port is not present with a value by a certain physical time. </p>

</div>
</div>
<a id="ga971322f63f26490a27bdd9006c05b8fe" name="ga971322f63f26490a27bdd9006c05b8fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga971322f63f26490a27bdd9006c05b8fe">&#9670;&#160;</a></span>lf_stall_advance_level_federation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_stall_advance_level_federation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>level</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Wait until inputs statuses are known up to and including the specified level. </p>
<p>Specifically, wait until the specified level is less that the max level allowed to advance (MLAA). This function does nothing if the environment is not the top-level environment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment (which should always be the top-level environment). </td></tr>
    <tr><td class="paramname">level</td><td>The level to which we would like to advance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab0f2188d27dfffa9fbbd417bed9305ea" name="gab0f2188d27dfffa9fbbd417bed9305ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0f2188d27dfffa9fbbd417bed9305ea">&#9670;&#160;</a></span>lf_stall_advance_level_federation_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_stall_advance_level_federation_locked </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>level</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Version of <a class="el" href="#ga971322f63f26490a27bdd9006c05b8fe" title="Wait until inputs statuses are known up to and including the specified level.">lf_stall_advance_level_federation()</a> that assumes the caller holds the mutex lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>The level to which we would like to advance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga36681c905141edace5d23ff8d5c8f205" name="ga36681c905141edace5d23ff8d5c8f205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36681c905141edace5d23ff8d5c8f205">&#9670;&#160;</a></span>lf_synchronize_with_other_federates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_synchronize_with_other_federates </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Synchronize the start with other federates via the RTI. </p>
<p>This assumes that a connection to the RTI is already made and _lf_rti_socket_TCP is valid. It then sends the current logical time to the RTI and waits for the RTI to respond with a specified time. It starts a thread to listen for messages from the RTI. </p>

</div>
</div>
<a id="ga84e5177d12e705274be1e6652b5d7c01" name="ga84e5177d12e705274be1e6652b5d7c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84e5177d12e705274be1e6652b5d7c01">&#9670;&#160;</a></span>lf_update_max_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lf_update_max_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>is_provisional</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Update the max level allowed to advance (MLAA). </p>
<p>If the specified tag is greater than the current_tag of the top-level environment (or equal and is_provisional is false), then set the MLAA to INT_MAX and return. This removes any barriers on execution at the current tag due to network inputs. Otherwise, set the MLAA to the minimum level over all (non-physical) network input ports where the status of the input port is not known at that current_tag.</p>
<p>This function assumes that the caller holds the mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>The latest TAG or PTAG received by this federate. </td></tr>
    <tr><td class="paramname">is_provisional</td><td>Whether the tag was provisional. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the MLAA changed. </dd></dl>

</div>
</div>
<a id="gaa0c8d0811c7faae11b9f1a7fcb30f917" name="gaa0c8d0811c7faae11b9f1a7fcb30f917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0c8d0811c7faae11b9f1a7fcb30f917">&#9670;&#160;</a></span>lf_wait_until_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a> lf_wait_until_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Return the physical time that we should wait until before advancing to the specified tag. </p>
<p>This function adds the STA offset (STP_offset parameter) to the time of the specified tag unless the tag is the starting tag (it is always safe to advance to the starting tag). It also avoids adding the STA offset if all network input ports are known at least up to one microstep earlier than the specified tag.</p>
<p>This function assumes that the caller holds the environment mutex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The specified time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7a568c79c856e633f5f181dd21700b74" name="ga7a568c79c856e633f5f181dd21700b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a568c79c856e633f5f181dd21700b74">&#9670;&#160;</a></span>match_regex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool match_regex </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>regex</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_util.h</a>&gt;</code></p>

<p>Check whether str matches regex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to check. </td></tr>
    <tr><td class="paramname">regex</td><td>The regex to check against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is a match, false otherwise. </dd></dl>

</div>
</div>
<a id="gae4ba6b1361cd7c47e8a0eb70729d9636" name="gae4ba6b1361cd7c47e8a0eb70729d9636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4ba6b1361cd7c47e8a0eb70729d9636">&#9670;&#160;</a></span>peek_from_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t peek_from_socket </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="socket__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/socket_common.h</a>&gt;</code></p>

<p>Without blocking, peek at the specified socket. </p>
<p>If there is anything on the queue, put its first byte at the specified address and return 1. If there is nothing on the queue, return 0, and if an error occurs, return -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">result</td><td>Pointer to where to put the first byte available on the socket. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa8f7af0d4004aa925499fecefa1ac6b8" name="gaa8f7af0d4004aa925499fecefa1ac6b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8f7af0d4004aa925499fecefa1ac6b8">&#9670;&#160;</a></span>read_from_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int read_from_socket </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num_bytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="socket__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/socket_common.h</a>&gt;</code></p>

<p>Read the specified number of bytes from the specified socket into the specified buffer. </p>
<p>If an error occurs during this reading, return -1 and set errno to indicate the cause of the error. If the read succeeds in reading the specified number of bytes, return 0. If an EOF occurs before reading the specified number of bytes, return 1. This function repeats the read attempt until the specified number of bytes have been read, an EOF is read, or an error occurs. Specifically, errors EAGAIN, EWOULDBLOCK, and EINTR are not considered errors and instead trigger another attempt. A delay between attempts is given by DELAY_BETWEEN_SOCKET_RETRIES. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">num_bytes</td><td>The number of bytes to read. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer into which to put the bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, 1 for EOF, and -1 for an error. </dd></dl>

</div>
</div>
<a id="ga941fd71700b7646e6edbbb76db4f7bd2" name="ga941fd71700b7646e6edbbb76db4f7bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga941fd71700b7646e6edbbb76db4f7bd2">&#9670;&#160;</a></span>read_from_socket_close_on_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int read_from_socket_close_on_error </td>
          <td>(</td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num_bytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="socket__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/socket_common.h</a>&gt;</code></p>

<p>Read the specified number of bytes from the specified socket into the specified buffer. </p>
<p>This uses <a class="el" href="#gaa8f7af0d4004aa925499fecefa1ac6b8">read_from_socket</a>, but if a failure occurs, it closes the socket using <a class="el" href="#ga365eba5b8b3f6445eeaffcb4435165c5">shutdown_socket</a> and returns -1. Otherwise, it returns 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Pointer to the socket ID. </td></tr>
    <tr><td class="paramname">num_bytes</td><td>The number of bytes to write. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer from which to get the bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, -1 for failure. </dd></dl>

</div>
</div>
<a id="ga46a44d92c24d3caadec0bc9e59a26361" name="ga46a44d92c24d3caadec0bc9e59a26361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46a44d92c24d3caadec0bc9e59a26361">&#9670;&#160;</a></span>read_from_socket_fail_on_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void read_from_socket_fail_on_error </td>
          <td>(</td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num_bytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="socket__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/socket_common.h</a>&gt;</code></p>

<p>Read the specified number of bytes from the specified socket into the specified buffer and close the socket if an error occurs. </p>
<p>If a disconnect or an EOF occurs during this reading, then if format is non-null, report an error and exit. If the mutex argument is non-NULL, release the mutex before exiting. If format is null, then report the error, but do not exit. This function takes a formatted string and additional optional arguments similar to printf(format, ...) that is appended to the error messages. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">num_bytes</td><td>The number of bytes to read. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer into which to put the bytes. </td></tr>
    <tr><td class="paramname">format</td><td>A printf-style format string, followed by arguments to fill the string, or NULL to not exit with an error message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae267d03a5f2263604459ca4c1aef2c2c" name="gae267d03a5f2263604459ca4c1aef2c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae267d03a5f2263604459ca4c1aef2c2c">&#9670;&#160;</a></span>reset_socket_stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reset_socket_stat </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structsocket__stat__t.html">socket_stat_t</a> *</td>          <td class="paramname"><span class="paramname"><em>socket_stat</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="clock-sync_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/clock-sync.h</a>&gt;</code></p>

<p>Reset statistics on the socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_stat</td><td>The <a class="el" href="structsocket__stat__t.html" title="Statistics and state for clock synchronization over a socket connection.">socket_stat_t</a> struct that keeps track of stats for a given connection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga834b31e00e677a23b6a86119b7a2fe59" name="ga834b31e00e677a23b6a86119b7a2fe59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga834b31e00e677a23b6a86119b7a2fe59">&#9670;&#160;</a></span>setup_clock_synchronization_with_rti()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t setup_clock_synchronization_with_rti </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="clock-sync_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/clock-sync.h</a>&gt;</code></p>

<p>Setup necessary functionalities to synchronize clock with the RTI. </p>
<dl class="section return"><dt>Returns</dt><dd>port number to be sent to the RTI. If clock synchronization is off compeltely, USHRT_MAX is returned. If clock synchronization is set to initial, 0 is sent. If clock synchronization is set to on, a reserved UDP port number will be sent. </dd></dl>

</div>
</div>
<a id="ga365eba5b8b3f6445eeaffcb4435165c5" name="ga365eba5b8b3f6445eeaffcb4435165c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga365eba5b8b3f6445eeaffcb4435165c5">&#9670;&#160;</a></span>shutdown_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int shutdown_socket </td>
          <td>(</td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>read_before_closing</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="socket__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/socket_common.h</a>&gt;</code></p>

<p>Shutdown and close the socket. </p>
<p>If <span class="tt">read_before_closing</span> is false, this calls <span class="tt">shutdown</span> with <span class="tt">SHUT_RDWR</span>, shutting down both directions. If this fails, then it calls <span class="tt">close</span>. If read_before_closing is true, this calls <span class="tt">shutdown</span> with <span class="tt">SHUT_WR</span>, only disallowing further writing. If this succeeds, then it calls <span class="tt">read</span> until an <span class="tt">EOF</span> is received and discards all received bytes, otherwise it calls <span class="tt">close</span>. In all cases, the socket ID pointed to by the <span class="tt">socket</span> argument is set to -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Pointer to the socket descriptor to shutdown and close. </td></tr>
    <tr><td class="paramname">read_before_closing</td><td>If true, read until EOF before closing the socket. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0 for success and -1 if either <span class="tt">shutdown</span> or <span class="tt">close</span> returns an error. </dd></dl>

</div>
</div>
<a id="gaeaff8773e0cba7d0f8a6d03b8f0f7766" name="gaeaff8773e0cba7d0f8a6d03b8f0f7766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaff8773e0cba7d0f8a6d03b8f0f7766">&#9670;&#160;</a></span>swap_bytes_if_big_endian_int32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t swap_bytes_if_big_endian_int32 </td>
          <td>(</td>
          <td class="paramtype">int32_t</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_util.h</a>&gt;</code></p>

<p>If this host is little endian, then reverse the order of the bytes of the argument. </p>
<p>Otherwise, return the argument unchanged. This can be used to convert the argument to network order (big endian) and then back again. Network transmissions, by convention, are big endian, meaning that the high-order byte is sent first. But many platforms, including my Mac, are little endian, meaning that the low-order byte is first in memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The argument to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa548ffc52c264f564127b80f63170c33" name="gaa548ffc52c264f564127b80f63170c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa548ffc52c264f564127b80f63170c33">&#9670;&#160;</a></span>swap_bytes_if_big_endian_int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t swap_bytes_if_big_endian_int64 </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_util.h</a>&gt;</code></p>

<p>If this host is little endian, then reverse the order of the bytes of the argument. </p>
<p>Otherwise, return the argument unchanged. This can be used to convert the argument to network order (big endian) and then back again. Network transmissions, by convention, are big endian, meaning that the high-order byte is sent first. But many platforms, including my Mac, are little endian, meaning that the low-order byte is first in memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The argument to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga48fa075b3a868790da8fb303a397cd60" name="ga48fa075b3a868790da8fb303a397cd60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48fa075b3a868790da8fb303a397cd60">&#9670;&#160;</a></span>swap_bytes_if_big_endian_uint16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t swap_bytes_if_big_endian_uint16 </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_util.h</a>&gt;</code></p>

<p>If this host is little endian, then reverse the order of the bytes of the argument. </p>
<p>Otherwise, return the argument unchanged. This can be used to convert the argument to network order (big endian) and then back again. Network transmissions, by convention, are big endian, meaning that the high-order byte is sent first. But many platforms, including my Mac, are little endian, meaning that the low-order byte is first in memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The argument to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3eba5f95a19f86a70d9d11fd2c736dd1" name="ga3eba5f95a19f86a70d9d11fd2c736dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3eba5f95a19f86a70d9d11fd2c736dd1">&#9670;&#160;</a></span>synchronize_initial_physical_clock_with_rti()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void synchronize_initial_physical_clock_with_rti </td>
          <td>(</td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>rti_socket_TCP</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="clock-sync_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/clock-sync.h</a>&gt;</code></p>

<p>Synchronize the initial physical clock with the RTI. </p>
<p>A call to this function is inserted into the startup sequence by the code generator if initial clock synchronization is required.</p>
<p>This is a blocking function that expects to read a MSG_TYPE_CLOCK_SYNC_T1 from the RTI TCP socket. It will then follow the PTP protocol to synchronize the local physical clock with the RTI. Failing to complete this protocol is treated as a catastrophic error that causes the federate to exit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rti_socket_TCP</td><td>Pointer to the RTI's socket </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga43868b9ea442f34eedbfe7052247f0a3" name="ga43868b9ea442f34eedbfe7052247f0a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43868b9ea442f34eedbfe7052247f0a3">&#9670;&#160;</a></span>tracepoint_federate_from_federate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tracepoint_federate_from_federate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Tracing.html#gab02e9e69539d60297cedb38c2193a453">trace_event_t</a></td>          <td class="paramname"><span class="paramname"><em>event_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fed_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>partner_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tracepoint_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/tracepoint.h</a>&gt;</code></p>

<p>Trace federate receiving a message from another federate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_type</td><td>The type of event. Possible values are:</td></tr>
    <tr><td class="paramname">fed_id</td><td>The federate identifier. </td></tr>
    <tr><td class="paramname">partner_id</td><td>The partner federate identifier. </td></tr>
    <tr><td class="paramname">tag</td><td>Pointer to the tag that has been received, or NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab1bd5a0184ea0773425733fe1d9faa1c" name="gab1bd5a0184ea0773425733fe1d9faa1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1bd5a0184ea0773425733fe1d9faa1c">&#9670;&#160;</a></span>tracepoint_federate_from_rti()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tracepoint_federate_from_rti </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Tracing.html#gab02e9e69539d60297cedb38c2193a453">trace_event_t</a></td>          <td class="paramname"><span class="paramname"><em>event_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fed_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tracepoint_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/tracepoint.h</a>&gt;</code></p>

<p>Trace federate receiving a message from the RTI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_type</td><td>The type of event. Possible values are:</td></tr>
    <tr><td class="paramname">fed_id</td><td>The federate identifier. </td></tr>
    <tr><td class="paramname">tag</td><td>Pointer to the tag that has been received, or NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1307585fa1ca4dc4506f0398842115ee" name="ga1307585fa1ca4dc4506f0398842115ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1307585fa1ca4dc4506f0398842115ee">&#9670;&#160;</a></span>tracepoint_federate_to_federate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tracepoint_federate_to_federate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Tracing.html#gab02e9e69539d60297cedb38c2193a453">trace_event_t</a></td>          <td class="paramname"><span class="paramname"><em>event_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fed_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>partner_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tracepoint_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/tracepoint.h</a>&gt;</code></p>

<p>Trace federate sending a message to another federate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_type</td><td>The type of event. Possible values are:</td></tr>
    <tr><td class="paramname">fed_id</td><td>The federate identifier. </td></tr>
    <tr><td class="paramname">partner_id</td><td>The partner federate identifier. </td></tr>
    <tr><td class="paramname">tag</td><td>Pointer to the tag that has been sent, or NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa074cf1f2690197f9edfd7a115381d6a" name="gaa074cf1f2690197f9edfd7a115381d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa074cf1f2690197f9edfd7a115381d6a">&#9670;&#160;</a></span>tracepoint_federate_to_rti()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tracepoint_federate_to_rti </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Tracing.html#gab02e9e69539d60297cedb38c2193a453">trace_event_t</a></td>          <td class="paramname"><span class="paramname"><em>event_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fed_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tracepoint_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/tracepoint.h</a>&gt;</code></p>

<p>Trace federate sending a message to the RTI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_type</td><td>The type of event. Possible values are:</td></tr>
    <tr><td class="paramname">fed_id</td><td>The federate identifier. </td></tr>
    <tr><td class="paramname">tag</td><td>Pointer to the tag that has been sent, or NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f6ec1479ffe28cc089fe6b13e675f0e" name="ga0f6ec1479ffe28cc089fe6b13e675f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f6ec1479ffe28cc089fe6b13e675f0e">&#9670;&#160;</a></span>validate_host()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool validate_host </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>host</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_util.h</a>&gt;</code></p>

<p>Check whether host is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The host to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid, false otherwise. </dd></dl>

</div>
</div>
<a id="ga841bec9ddc3fb61c2b615f5d512dc3f0" name="ga841bec9ddc3fb61c2b615f5d512dc3f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga841bec9ddc3fb61c2b615f5d512dc3f0">&#9670;&#160;</a></span>validate_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool validate_port </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>port</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_util.h</a>&gt;</code></p>

<p>Check whether port is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid, false otherwise. </dd></dl>

</div>
</div>
<a id="ga1285f4b0283c8e0c020e12e76a4426c2" name="ga1285f4b0283c8e0c020e12e76a4426c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1285f4b0283c8e0c020e12e76a4426c2">&#9670;&#160;</a></span>validate_user()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool validate_user </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>user</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="net__util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/net_util.h</a>&gt;</code></p>

<p>Check whether user is valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>The user to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if valid, false otherwise. </dd></dl>

</div>
</div>
<a id="gae8d4b83faeac37f665666429742813f9" name="gae8d4b83faeac37f665666429742813f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8d4b83faeac37f665666429742813f9">&#9670;&#160;</a></span>write_to_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int write_to_socket </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num_bytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="socket__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/socket_common.h</a>&gt;</code></p>

<p>Write the specified number of bytes to the specified socket from the specified buffer. </p>
<p>If an error occurs, return -1 and set errno to indicate the cause of the error. If the write succeeds, return 0. This function repeats the attempt until the specified number of bytes have been written or an error occurs. Specifically, errors EAGAIN, EWOULDBLOCK, and EINTR are not considered errors and instead trigger another attempt. A delay between attempts is given by DELAY_BETWEEN_SOCKET_RETRIES. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">num_bytes</td><td>The number of bytes to write. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer from which to get the bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, -1 for failure. </dd></dl>

</div>
</div>
<a id="gaf88884c303b81143ef5ab7af4683a66c" name="gaf88884c303b81143ef5ab7af4683a66c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf88884c303b81143ef5ab7af4683a66c">&#9670;&#160;</a></span>write_to_socket_close_on_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int write_to_socket_close_on_error </td>
          <td>(</td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num_bytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="socket__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/socket_common.h</a>&gt;</code></p>

<p>Write the specified number of bytes to the specified socket. </p>
<p>This uses <a class="el" href="#gae8d4b83faeac37f665666429742813f9">write_to_socket</a> and closes the socket if an error occurs. If an error occurs, this will change the socket ID pointed to by the first argument to -1 and will return -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Pointer to the socket ID. </td></tr>
    <tr><td class="paramname">num_bytes</td><td>The number of bytes to write. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer from which to get the bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, -1 for failure. </dd></dl>

</div>
</div>
<a id="gada8d9360bdf4e9d7f36bbfc7e682f06e" name="gada8d9360bdf4e9d7f36bbfc7e682f06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada8d9360bdf4e9d7f36bbfc7e682f06e">&#9670;&#160;</a></span>write_to_socket_fail_on_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void write_to_socket_fail_on_error </td>
          <td>(</td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>socket</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num_bytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lf_mutex_t *</td>          <td class="paramname"><span class="paramname"><em>mutex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>...</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="socket__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/network/socket_common.h</a>&gt;</code></p>

<p>Write the specified number of bytes to the specified socket. </p>
<p>This uses <a class="el" href="#gaf88884c303b81143ef5ab7af4683a66c">write_to_socket_close_on_error</a> and exits with an error code if an error occurs. If the mutex argument is non-NULL, release the mutex before exiting. If the format argument is non-null, then use it an any additional arguments to form the error message using printf conventions. Otherwise, print a generic error message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>Pointer to the socket ID. </td></tr>
    <tr><td class="paramname">num_bytes</td><td>The number of bytes to write. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer from which to get the bytes. </td></tr>
    <tr><td class="paramname">mutex</td><td>If non-NULL, the mutex to unlock before exiting. </td></tr>
    <tr><td class="paramname">format</td><td>A format string for error messages, followed by any number of fields that will be used to fill the format string as in printf, or NULL to print a generic error message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="ga1881fdaaffead81a8d2993121d9cd78f" name="ga1881fdaaffead81a8d2993121d9cd78f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1881fdaaffead81a8d2993121d9cd78f">&#9670;&#160;</a></span>lf_outbound_socket_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lf_mutex_t lf_outbound_socket_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Mutex lock held while performing outbound socket write and close operations. </p>

</div>
</div>
<a id="ga4ea10c9ed824595585d91f37dbfd4364" name="ga4ea10c9ed824595585d91f37dbfd4364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ea10c9ed824595585d91f37dbfd4364">&#9670;&#160;</a></span>lf_port_status_changed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">lf_cond_t lf_port_status_changed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="federate_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/federated/federate.h</a>&gt;</code></p>

<p>Condition variable for blocking on unkonwn federate input ports. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on <span class="timestamp"></span> for reactor-c by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
