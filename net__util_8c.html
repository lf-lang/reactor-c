<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>reactor-c: core/federated/net_util.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">reactor-c
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_4270bfced15e0e73154b13468c7c9ad9.html">core</a></li><li class="navelem"><a class="el" href="dir_da79f73d8cf16fc09c9e3a52dcc440a7.html">federated</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">net_util.c File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="util_8h_source.html">../util.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="net__util_8h_source.html">net_util.h</a>&quot;</code><br />
<code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;stdarg.h&gt;</code><br />
<code>#include &lt;time.h&gt;</code><br />
<code>#include &lt;math.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:af58c457e08491f7cfd5a0a46940e11ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#af58c457e08491f7cfd5a0a46940e11ad">NUMBER_OF_FEDERATES</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:af58c457e08491f7cfd5a0a46940e11ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065f1f00e4a82d34116e1cd8734fabde"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a065f1f00e4a82d34116e1cd8734fabde">SOCKET_READ_RETRY_INTERVAL</a>&#160;&#160;&#160;1000000</td></tr>
<tr class="separator:a065f1f00e4a82d34116e1cd8734fabde"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a04dd5e3e7b7ee262b58476c4611d7b23"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a04dd5e3e7b7ee262b58476c4611d7b23">host_is_big_endian</a> ()</td></tr>
<tr class="separator:a04dd5e3e7b7ee262b58476c4611d7b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ccf34bcfb6d0eaef7262b60f96eb92d"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a5ccf34bcfb6d0eaef7262b60f96eb92d">read_from_socket_errexit</a> (int socket, size_t num_bytes, unsigned char *buffer, char *format,...)</td></tr>
<tr class="separator:a5ccf34bcfb6d0eaef7262b60f96eb92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544d5db6c22bd15939900f9ba60a743a"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a544d5db6c22bd15939900f9ba60a743a">read_from_socket</a> (int socket, size_t num_bytes, unsigned char *buffer)</td></tr>
<tr class="separator:a544d5db6c22bd15939900f9ba60a743a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5fdba6f80b9b0c6516c8400920da702"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#ab5fdba6f80b9b0c6516c8400920da702">write_to_socket_errexit_with_mutex</a> (int socket, size_t num_bytes, unsigned char *buffer, lf_mutex_t *<a class="el" href="reactor__threaded_8c.html#ab491fbef9a883a7cee19e074dba32661">mutex</a>, char *format,...)</td></tr>
<tr class="separator:ab5fdba6f80b9b0c6516c8400920da702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac7abf648593901711cc145d2ec986c"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#adac7abf648593901711cc145d2ec986c">write_to_socket_errexit</a> (int socket, size_t num_bytes, unsigned char *buffer, char *format,...)</td></tr>
<tr class="separator:adac7abf648593901711cc145d2ec986c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488ccf63c642ede4308d8f7face533f3"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a488ccf63c642ede4308d8f7face533f3">write_to_socket</a> (int socket, size_t num_bytes, unsigned char *buffer)</td></tr>
<tr class="separator:a488ccf63c642ede4308d8f7face533f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae233fa02382ed619a78b1c32e14a8657"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#ae233fa02382ed619a78b1c32e14a8657">encode_int64</a> (int64_t data, unsigned char *buffer)</td></tr>
<tr class="separator:ae233fa02382ed619a78b1c32e14a8657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6b3d0e0e777738422c11fa07b35e0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#afc6b3d0e0e777738422c11fa07b35e0f">encode_int32</a> (int32_t data, unsigned char *buffer)</td></tr>
<tr class="separator:afc6b3d0e0e777738422c11fa07b35e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b75c9d94d4f3d34d52f46c65cf950d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a9b75c9d94d4f3d34d52f46c65cf950d4">encode_uint32</a> (uint32_t data, unsigned char *buffer)</td></tr>
<tr class="separator:a9b75c9d94d4f3d34d52f46c65cf950d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad4dadc9bbc06596be44e7ecc4c7281"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#afad4dadc9bbc06596be44e7ecc4c7281">encode_uint16</a> (uint16_t data, unsigned char *buffer)</td></tr>
<tr class="separator:afad4dadc9bbc06596be44e7ecc4c7281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaff8773e0cba7d0f8a6d03b8f0f7766"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#aeaff8773e0cba7d0f8a6d03b8f0f7766">swap_bytes_if_big_endian_int32</a> (int32_t src)</td></tr>
<tr class="separator:aeaff8773e0cba7d0f8a6d03b8f0f7766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e111b75bf4f756a638135654c527ea"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a80e111b75bf4f756a638135654c527ea">swap_bytes_if_big_endian_uint32</a> (uint32_t src)</td></tr>
<tr class="separator:a80e111b75bf4f756a638135654c527ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa548ffc52c264f564127b80f63170c33"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#aa548ffc52c264f564127b80f63170c33">swap_bytes_if_big_endian_int64</a> (int64_t src)</td></tr>
<tr class="separator:aa548ffc52c264f564127b80f63170c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fa075b3a868790da8fb303a397cd60"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a48fa075b3a868790da8fb303a397cd60">swap_bytes_if_big_endian_uint16</a> (uint16_t src)</td></tr>
<tr class="separator:a48fa075b3a868790da8fb303a397cd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f772b5761c6b74b4136db6ee021e6c5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a8f772b5761c6b74b4136db6ee021e6c5">extract_int32</a> (unsigned char *bytes)</td></tr>
<tr class="separator:a8f772b5761c6b74b4136db6ee021e6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302786f5408f75c3e2be8580783e0af9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a302786f5408f75c3e2be8580783e0af9">extract_uint32</a> (unsigned char *bytes)</td></tr>
<tr class="separator:a302786f5408f75c3e2be8580783e0af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8decc0f4a38aa42fbc6ccfb029e3a061"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a8decc0f4a38aa42fbc6ccfb029e3a061">extract_int64</a> (unsigned char *bytes)</td></tr>
<tr class="separator:a8decc0f4a38aa42fbc6ccfb029e3a061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1686d838d49741a6ff2ee65bd766a987"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a1686d838d49741a6ff2ee65bd766a987">extract_uint16</a> (unsigned char *bytes)</td></tr>
<tr class="separator:a1686d838d49741a6ff2ee65bd766a987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82060dae45e1c3b922005e56829c9814"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a82060dae45e1c3b922005e56829c9814">extract_header</a> (unsigned char *buffer, uint16_t *port_id, uint16_t *federate_id, size_t *length)</td></tr>
<tr class="separator:a82060dae45e1c3b922005e56829c9814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2cc45fc8571af05bb05f4952d4cde5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a8e2cc45fc8571af05bb05f4952d4cde5">extract_timed_header</a> (unsigned char *buffer, uint16_t *port_id, uint16_t *federate_id, size_t *length, <a class="el" href="structtag__t.html">tag_t</a> *tag)</td></tr>
<tr class="separator:a8e2cc45fc8571af05bb05f4952d4cde5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd95311c2c29ce5bed1c44d5336584d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a9cd95311c2c29ce5bed1c44d5336584d">extract_tag</a> (unsigned char *buffer)</td></tr>
<tr class="separator:a9cd95311c2c29ce5bed1c44d5336584d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5ae6582f28e14a37d50a2d243613c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="net__util_8c.html#a7b5ae6582f28e14a37d50a2d243613c5">encode_tag</a> (unsigned char *buffer, <a class="el" href="structtag__t.html">tag_t</a> tag)</td></tr>
<tr class="separator:a7b5ae6582f28e14a37d50a2d243613c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Edward A. Lee (<a href="#" onclick="location.href='mai'+'lto:'+'eal'+'@b'+'erk'+'el'+'ey.'+'ed'+'u'; return false;">eal@b<span style="display: none;">.nosp@m.</span>erke<span style="display: none;">.nosp@m.</span>ley.e<span style="display: none;">.nosp@m.</span>du</a>) </dd>
<dd>
Soroush Bateni (<a href="#" onclick="location.href='mai'+'lto:'+'sor'+'ou'+'sh@'+'ut'+'dal'+'la'+'s.e'+'du'; return false;">sorou<span style="display: none;">.nosp@m.</span>sh@u<span style="display: none;">.nosp@m.</span>tdall<span style="display: none;">.nosp@m.</span>as.e<span style="display: none;">.nosp@m.</span>du</a>)</dd></dl>
<h1><a class="anchor" id="LICENSE"></a>
LICENSE</h1>
<p >Copyright (c) 2020, The University of California at Berkeley.</p>
<p >Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ol type="1">
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
</ol>
<p >THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<h1><a class="anchor" id="DESCRIPTION"></a>
DESCRIPTION</h1>
<p >Utility functions for a federate in a federated execution. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="af58c457e08491f7cfd5a0a46940e11ad" name="af58c457e08491f7cfd5a0a46940e11ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58c457e08491f7cfd5a0a46940e11ad">&#9670;&nbsp;</a></span>NUMBER_OF_FEDERATES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUMBER_OF_FEDERATES&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a065f1f00e4a82d34116e1cd8734fabde" name="a065f1f00e4a82d34116e1cd8734fabde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a065f1f00e4a82d34116e1cd8734fabde">&#9670;&nbsp;</a></span>SOCKET_READ_RETRY_INTERVAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOCKET_READ_RETRY_INTERVAL&#160;&#160;&#160;1000000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Number of nanoseconds to sleep before retrying a socket read. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="afc6b3d0e0e777738422c11fa07b35e0f" name="afc6b3d0e0e777738422c11fa07b35e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6b3d0e0e777738422c11fa07b35e0f">&#9670;&nbsp;</a></span>encode_int32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void encode_int32 </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Write the specified data as a sequence of bytes starting at the specified address. This encodes the data in little-endian order (lowest order byte first). This works for int32_t. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to write. </td></tr>
    <tr><td class="paramname">buffer</td><td>The location to start writing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae233fa02382ed619a78b1c32e14a8657" name="ae233fa02382ed619a78b1c32e14a8657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae233fa02382ed619a78b1c32e14a8657">&#9670;&nbsp;</a></span>encode_int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void encode_int64 </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Write the specified data as a sequence of bytes starting at the specified address. This encodes the data in little-endian order (lowest order byte first). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to write. </td></tr>
    <tr><td class="paramname">buffer</td><td>The location to start writing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b5ae6582f28e14a37d50a2d243613c5" name="a7b5ae6582f28e14a37d50a2d243613c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5ae6582f28e14a37d50a2d243613c5">&#9670;&nbsp;</a></span>encode_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void encode_tag </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Encode tag information into buffer.</p>
<p >Buffer must have been allocated externally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to encode into. </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to encode into 'buffer'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afad4dadc9bbc06596be44e7ecc4c7281" name="afad4dadc9bbc06596be44e7ecc4c7281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad4dadc9bbc06596be44e7ecc4c7281">&#9670;&nbsp;</a></span>encode_uint16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void encode_uint16 </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Write the specified data as a sequence of bytes starting at the specified address. This encodes the data in little-endian order (lowest order byte first). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to write. </td></tr>
    <tr><td class="paramname">buffer</td><td>The location to start writing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b75c9d94d4f3d34d52f46c65cf950d4" name="a9b75c9d94d4f3d34d52f46c65cf950d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b75c9d94d4f3d34d52f46c65cf950d4">&#9670;&nbsp;</a></span>encode_uint32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void encode_uint32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Write the specified data as a sequence of bytes starting at the specified address. This encodes the data in little-endian order (lowest order byte first). This works for uint32_t. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to write. </td></tr>
    <tr><td class="paramname">buffer</td><td>The location to start writing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82060dae45e1c3b922005e56829c9814" name="a82060dae45e1c3b922005e56829c9814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82060dae45e1c3b922005e56829c9814">&#9670;&nbsp;</a></span>extract_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void extract_header </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>federate_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Extract the core header information that all messages between federates share. The core header information is two bytes with the ID of the destination port, two bytes with the ID of the destination federate, and four bytes with the length of the message. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to read from. </td></tr>
    <tr><td class="paramname">port_id</td><td>The place to put the port ID. </td></tr>
    <tr><td class="paramname">federate_id</td><td>The place to put the federate ID. </td></tr>
    <tr><td class="paramname">length</td><td>The place to put the length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f772b5761c6b74b4136db6ee021e6c5" name="a8f772b5761c6b74b4136db6ee021e6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f772b5761c6b74b4136db6ee021e6c5">&#9670;&nbsp;</a></span>extract_int32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t extract_int32 </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Extract an int32_t from the specified byte sequence. This will swap the order of the bytes if this machine is big endian. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>The address of the start of the sequence of bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8decc0f4a38aa42fbc6ccfb029e3a061" name="a8decc0f4a38aa42fbc6ccfb029e3a061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8decc0f4a38aa42fbc6ccfb029e3a061">&#9670;&nbsp;</a></span>extract_int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t extract_int64 </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Extract a int64_t from the specified byte sequence. This will swap the order of the bytes if this machine is big endian. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>The address of the start of the sequence of bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cd95311c2c29ce5bed1c44d5336584d" name="a9cd95311c2c29ce5bed1c44d5336584d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd95311c2c29ce5bed1c44d5336584d">&#9670;&nbsp;</a></span>extract_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtag__t.html">tag_t</a> extract_tag </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Extract tag information from buffer.</p>
<p >The tag is transmitted as a 64-bit (8 byte) signed integer for time and a 32-bit (4 byte) unsigned integer for microstep.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted tag. </dd></dl>

</div>
</div>
<a id="a8e2cc45fc8571af05bb05f4952d4cde5" name="a8e2cc45fc8571af05bb05f4952d4cde5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2cc45fc8571af05bb05f4952d4cde5">&#9670;&nbsp;</a></span>extract_timed_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void extract_timed_header </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>federate_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a> *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Extract the timed header information for timed messages between federates. This is two bytes with the ID of the destination port, two bytes with the ID of the destination federate, four bytes with the length of the message, eight bytes with a timestamp, and four bytes with a microstep. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to read from. </td></tr>
    <tr><td class="paramname">port_id</td><td>The place to put the port ID. </td></tr>
    <tr><td class="paramname">federate_id</td><td>The place to put the federate ID. </td></tr>
    <tr><td class="paramname">length</td><td>The place to put the length. </td></tr>
    <tr><td class="paramname">tag</td><td>The place to put the tag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1686d838d49741a6ff2ee65bd766a987" name="a1686d838d49741a6ff2ee65bd766a987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1686d838d49741a6ff2ee65bd766a987">&#9670;&nbsp;</a></span>extract_uint16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t extract_uint16 </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Extract an uint16_t from the specified byte sequence. This will swap the order of the bytes if this machine is big endian. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>The address of the start of the sequence of bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a302786f5408f75c3e2be8580783e0af9" name="a302786f5408f75c3e2be8580783e0af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302786f5408f75c3e2be8580783e0af9">&#9670;&nbsp;</a></span>extract_uint32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t extract_uint32 </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Extract a uint32_t from the specified byte sequence. This will swap the order of the bytes if this machine is big endian. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>The address of the start of the sequence of bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04dd5e3e7b7ee262b58476c4611d7b23" name="a04dd5e3e7b7ee262b58476c4611d7b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04dd5e3e7b7ee262b58476c4611d7b23">&#9670;&nbsp;</a></span>host_is_big_endian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int host_is_big_endian </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Return true (1) if the host is big endian. Otherwise, return false. </p>

</div>
</div>
<a id="a544d5db6c22bd15939900f9ba60a743a" name="a544d5db6c22bd15939900f9ba60a743a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544d5db6c22bd15939900f9ba60a743a">&#9670;&nbsp;</a></span>read_from_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t read_from_socket </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read the specified number of bytes from the specified socket into the specified buffer. If a disconnect occurs during this reading, return a negative number. If an EOF occurs during this reading, return 0. Otherwise, return the number of bytes read. This is a version of <a class="el" href="net__util_8c.html#a5ccf34bcfb6d0eaef7262b60f96eb92d">read_from_socket_errexit()</a> that neither closes the socket nor errors out.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">num_bytes</td><td>The number of bytes to read. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer into which to put the bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read or 0 when EOF is received or negative for an error. </dd></dl>

</div>
</div>
<a id="a5ccf34bcfb6d0eaef7262b60f96eb92d" name="a5ccf34bcfb6d0eaef7262b60f96eb92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ccf34bcfb6d0eaef7262b60f96eb92d">&#9670;&nbsp;</a></span>read_from_socket_errexit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t read_from_socket_errexit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read the specified number of bytes from the specified socket into the specified buffer. If an error or an EOF occurs during this reading, then if format is non-null, close the socket, report an error and exit. If format is NULL, then just return 0 for EOF and a negative number for any other error.</p>
<p >This function takes a formatted string and additional optional arguments similar to printf(format, ...) that is appended to the error messages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">num_bytes</td><td>The number of bytes to read. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer into which to put the bytes. </td></tr>
    <tr><td class="paramname">format</td><td>A printf-style format string, followed by arguments to fill the string, or NULL to not exit with an error message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read, or 0 if an EOF is received, or a negative number for an error. </dd></dl>

</div>
</div>
<a id="aeaff8773e0cba7d0f8a6d03b8f0f7766" name="aeaff8773e0cba7d0f8a6d03b8f0f7766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaff8773e0cba7d0f8a6d03b8f0f7766">&#9670;&nbsp;</a></span>swap_bytes_if_big_endian_int32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t swap_bytes_if_big_endian_int32 </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >If this host is little endian, then reverse the order of the bytes of the argument. Otherwise, return the argument unchanged. This can be used to convert the argument to network order (big endian) and then back again. Network transmissions, by convention, are big endian, meaning that the high-order byte is sent first. But many platforms, including my Mac, are little endian, meaning that the low-order byte is first in memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The argument to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa548ffc52c264f564127b80f63170c33" name="aa548ffc52c264f564127b80f63170c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa548ffc52c264f564127b80f63170c33">&#9670;&nbsp;</a></span>swap_bytes_if_big_endian_int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t swap_bytes_if_big_endian_int64 </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >If this host is little endian, then reverse the order of the bytes of the argument. Otherwise, return the argument unchanged. This can be used to convert the argument to network order (big endian) and then back again. Network transmissions, by convention, are big endian, meaning that the high-order byte is sent first. But many platforms, including my Mac, are little endian, meaning that the low-order byte is first in memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The argument to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48fa075b3a868790da8fb303a397cd60" name="a48fa075b3a868790da8fb303a397cd60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48fa075b3a868790da8fb303a397cd60">&#9670;&nbsp;</a></span>swap_bytes_if_big_endian_uint16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t swap_bytes_if_big_endian_uint16 </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >If this host is little endian, then reverse the order of the bytes of the argument. Otherwise, return the argument unchanged. This can be used to convert the argument to network order (big endian) and then back again. Network transmissions, by convention, are big endian, meaning that the high-order byte is sent first. But many platforms, including my Mac, are little endian, meaning that the low-order byte is first in memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The argument to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80e111b75bf4f756a638135654c527ea" name="a80e111b75bf4f756a638135654c527ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e111b75bf4f756a638135654c527ea">&#9670;&nbsp;</a></span>swap_bytes_if_big_endian_uint32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t swap_bytes_if_big_endian_uint32 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >If this host is little endian, then reverse the order of the bytes of the argument. Otherwise, return the argument unchanged. This can be used to convert the argument to network order (big endian) and then back again. Network transmissions, by convention, are big endian, meaning that the high-order byte is sent first. But many platforms, including my Mac, are little endian, meaning that the low-order byte is first in memory. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The argument to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a488ccf63c642ede4308d8f7face533f3" name="a488ccf63c642ede4308d8f7face533f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488ccf63c642ede4308d8f7face533f3">&#9670;&nbsp;</a></span>write_to_socket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t write_to_socket </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Write the specified number of bytes to the specified socket from the specified buffer. If a disconnect or an EOF occurs during this reading, return a negative number or 0 respectively. Otherwise, return the number of bytes written. This is a version of <a class="el" href="net__util_8c.html#adac7abf648593901711cc145d2ec986c">write_to_socket_errexit()</a> that neither closes the socket nor errors out.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">num_bytes</td><td>The number of bytes to write. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer from which to get the bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written, or 0 if an EOF was received, or a negative number if an error occurred. </dd></dl>

</div>
</div>
<a id="adac7abf648593901711cc145d2ec986c" name="adac7abf648593901711cc145d2ec986c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac7abf648593901711cc145d2ec986c">&#9670;&nbsp;</a></span>write_to_socket_errexit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t write_to_socket_errexit </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Write the specified number of bytes to the specified socket from the specified buffer. If an error or an EOF occurs during this reading, then if the format string is non-null, close the socket, report an error, and exit. If the format string is null, report an error or EOF and return.</p>
<p >This function takes a formatted string and additional optional arguments similar to printf(format, ...) that is appended to the error messages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">num_bytes</td><td>The number of bytes to write. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer from which to get the bytes. </td></tr>
    <tr><td class="paramname">format</td><td>A format string for error messages, followed by any number of fields that will be used to fill the format string as in printf, or NULL to prevent exit on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written, or 0 if an EOF was received, or a negative number if an error occurred. </dd></dl>

</div>
</div>
<a id="ab5fdba6f80b9b0c6516c8400920da702" name="ab5fdba6f80b9b0c6516c8400920da702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5fdba6f80b9b0c6516c8400920da702">&#9670;&nbsp;</a></span>write_to_socket_errexit_with_mutex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t write_to_socket_errexit_with_mutex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lf_mutex_t *&#160;</td>
          <td class="paramname"><em>mutex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Write the specified number of bytes to the specified socket from the specified buffer. If an error or an EOF occurs during this reading, then if the format string is non-null, close the socket, report an error, and exit. If the format string is null, report an error or EOF and return.</p>
<p >This function takes a formatted string and additional optional arguments similar to printf(format, ...) that is appended to the error messages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket</td><td>The socket ID. </td></tr>
    <tr><td class="paramname">num_bytes</td><td>The number of bytes to write. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer from which to get the bytes. </td></tr>
    <tr><td class="paramname">mutex</td><td>If non-NULL, the mutex to unlock before exiting. </td></tr>
    <tr><td class="paramname">format</td><td>A format string for error messages, followed by any number of fields that will be used to fill the format string as in printf, or NULL to prevent exit on error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written, or 0 if an EOF was received, or a negative number if an error occurred. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
