<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>reactor-c: Internal</title>
<link rel="icon" href="favicon.ico" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">reactor-c<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">C Runtime for Lingua Franca</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__Internal.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">Internal </div></div>
</div><!--header-->
<div class="contents">

<p>API mainly used internally, but occasionally useful for users.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-files" class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:environment_2Eh" id="r_environment_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="environment_8h.html">environment.h</a></td></tr>
<tr class="memdesc:environment_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">API for the environment data structure. <br /></td></tr>
<tr class="memitem:lf_5Fsemaphore_2Eh" id="r_lf_5Fsemaphore_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lf__semaphore_8h.html">lf_semaphore.h</a></td></tr>
<tr class="memdesc:lf__semaphore_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Semaphore utility for reactor C. <br /></td></tr>
<tr class="memitem:lf_5Ftoken_2Eh" id="r_lf_5Ftoken_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lf__token_8h.html">lf_token.h</a></td></tr>
<tr class="memdesc:lf__token_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions for token objects, reference-counted wrappers around dynamically-allocated messages. <br /></td></tr>
<tr class="memitem:lf_5Ftypes_2Eh" id="r_lf_5Ftypes_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lf__types_8h.html">lf_types.h</a></td></tr>
<tr class="memdesc:lf__types_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definitions that are widely used across different parts of the runtime. <br /></td></tr>
<tr class="memitem:logging_5Fmacros_2Eh" id="r_logging_5Fmacros_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="logging__macros_8h.html">logging_macros.h</a></td></tr>
<tr class="memdesc:logging__macros_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logging macros for the logging API. <br /></td></tr>
<tr class="memitem:mixed_5Fradix_2Eh" id="r_mixed_5Fradix_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mixed__radix_8h.html">mixed_radix.h</a></td></tr>
<tr class="memdesc:mixed__radix_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Header file for permuted mixed-radix numbers used in Lingua Franca programs. <br /></td></tr>
<tr class="memitem:pqueue_2Eh" id="r_pqueue_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pqueue_8h.html">pqueue.h</a></td></tr>
<tr class="memdesc:pqueue_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Priority queue definitions for queues where the priority is a number that can be compared with ordinary numerical comparisons. <br /></td></tr>
<tr class="memitem:pqueue_5Fbase_2Eh" id="r_pqueue_5Fbase_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pqueue__base_8h.html">pqueue_base.h</a></td></tr>
<tr class="memdesc:pqueue__base_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Priority Queue function declarations used as a base for Lingua Franca priority queues. <br /></td></tr>
<tr class="memitem:pqueue_5Ftag_2Eh" id="r_pqueue_5Ftag_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pqueue__tag_8h.html">pqueue_tag.h</a></td></tr>
<tr class="memdesc:pqueue__tag_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Priority queue that uses tags for sorting. <br /></td></tr>
<tr class="memitem:reactor_5Fcommon_2Eh" id="r_reactor_5Fcommon_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__common_8h.html">reactor_common.h</a></td></tr>
<tr class="memdesc:reactor__common_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declarations of functions with implementations in reactor.c and reactor_threaded.c. <br /></td></tr>
<tr class="memitem:reactor_5Fthreaded_2Eh" id="r_reactor_5Fthreaded_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="reactor__threaded_8h.html">reactor_threaded.h</a></td></tr>
<tr class="memdesc:reactor__threaded_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runtime infrastructure for the threaded version of the C target of Lingua Franca. <br /></td></tr>
<tr class="memitem:scheduler_2Eh" id="r_scheduler_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="scheduler_8h.html">scheduler.h</a></td></tr>
<tr class="memdesc:scheduler_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scheduler API for the threaded C runtime. <br /></td></tr>
<tr class="memitem:scheduler_5Finstance_2Eh" id="r_scheduler_5Finstance_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="scheduler__instance_8h.html">scheduler_instance.h</a></td></tr>
<tr class="memdesc:scheduler__instance_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common scheduler parameters. <br /></td></tr>
<tr class="memitem:scheduler_5Fsync_5Ftag_5Fadvance_2Eh" id="r_scheduler_5Fsync_5Ftag_5Fadvance_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="scheduler__sync__tag__advance_8h.html">scheduler_sync_tag_advance.h</a></td></tr>
<tr class="memdesc:scheduler__sync__tag__advance_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">API used to advance tag globally. <br /></td></tr>
<tr class="memitem:tracepoint_2Eh" id="r_tracepoint_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tracepoint_8h.html">tracepoint.h</a></td></tr>
<tr class="memdesc:tracepoint_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definitions of tracepoint functions for use with the C code generator and any other code generator that uses the C infrastructure (such as the Python code generator). <br /></td></tr>
<tr class="memitem:util_2Eh" id="r_util_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="util_8h.html">util.h</a></td></tr>
<tr class="memdesc:util_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core utility functions for Lingua Franca. <br /></td></tr>
<tr class="memitem:watchdog_2Eh" id="r_watchdog_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="watchdog_8h.html">watchdog.h</a></td></tr>
<tr class="memdesc:watchdog_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declarations for watchdogs. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:allocation_5Frecord_5Ft" id="r_allocation_5Frecord_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structallocation__record__t.html">allocation_record_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocation record to keep track of dynamically-allocated memory.  <a href="structallocation__record__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:environment_5Ft" id="r_environment_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenvironment__t.html">environment_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution environment.  <a href="structenvironment__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:event_5Ft" id="r_event_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevent__t.html">event_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event activation record to push onto the event queue.  <a href="structevent__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:lf_5Faction_5Fbase_5Ft" id="r_lf_5Faction_5Fbase_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlf__action__base__t.html">lf_action_base_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for actions.  <a href="structlf__action__base__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:lf_5Fport_5Fbase_5Ft" id="r_lf_5Fport_5Fbase_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlf__port__base__t.html">lf_port_base_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for ports.  <a href="structlf__port__base__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:lf_5Fscheduler_5Ft" id="r_lf_5Fscheduler_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlf__scheduler__t.html">lf_scheduler_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters used in schedulers of the threaded reactor C runtime.  <a href="structlf__scheduler__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:lf_5Fsemaphore_5Ft" id="r_lf_5Fsemaphore_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlf__semaphore__t.html">lf_semaphore_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A semaphore.  <a href="structlf__semaphore__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:lf_5Fsparse_5Fio_5Frecord_5Ft" id="r_lf_5Fsparse_5Fio_5Frecord_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlf__sparse__io__record__t.html">lf_sparse_io_record_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A record of the subset of channels of a multiport that have present inputs.  <a href="structlf__sparse__io__record__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:lf_5Ftag_5Fadvancement_5Fbarrier_5Ft" id="r_lf_5Ftag_5Fadvancement_5Fbarrier_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlf__tag__advancement__barrier__t.html">lf_tag_advancement_barrier_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct representing a barrier in threaded LF programs.  <a href="structlf__tag__advancement__barrier__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:mixed_5Fradix_5Fint_5Ft" id="r_mixed_5Fradix_5Fint_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmixed__radix__int__t.html">mixed_radix_int_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a permuted mixed radix integer.  <a href="structmixed__radix__int__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:pqueue_5Ft" id="r_pqueue_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpqueue__t.html">pqueue_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The priority queue struct.  <a href="structpqueue__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:reaction_5Ft" id="r_reaction_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreaction__t.html">reaction_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reaction activation record to push onto the reaction queue.  <a href="structreaction__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:sched_5Fparams_5Ft" id="r_sched_5Fparams_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsched__params__t.html">sched_params_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct representing the most common scheduler parameters.  <a href="structsched__params__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:self_5Fbase_5Ft" id="r_self_5Fbase_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structself__base__t.html">self_base_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base type for all reactor self structs.  <a href="structself__base__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:token_5Ftemplate_5Ft" id="r_token_5Ftemplate_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtoken__template__t.html">token_template_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for ports (<a class="el" href="structlf__port__base__t.html" title="Base type for ports.">lf_port_base_t</a>) and actions (<a class="el" href="structtrigger__t.html" title="Trigger struct representing an output, timer, action, or input.">trigger_t</a>), which can carry tokens.  <a href="structtoken__template__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:token_5Ftype_5Ft" id="r_token_5Ftype_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtoken__type__t.html">token_type_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type information for tokens.  <a href="structtoken__type__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:trace_5Frecord_5Ft" id="r_trace_5Frecord_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrace__record__t.html">trace_record_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trace record that gets written in binary to the trace file in the default implementation.  <a href="structtrace__record__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:trigger_5Ft" id="r_trigger_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtrigger__t.html">trigger_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger struct representing an output, timer, action, or input.  <a href="structtrigger__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:watchdog_5Ft" id="r_watchdog_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwatchdog__t.html">watchdog_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typdef for <a class="el" href="structwatchdog__t.html" title="Typdef for watchdog_t struct, used to call watchdog handler.">watchdog_t</a> struct, used to call watchdog handler.  <a href="structwatchdog__t.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga8d8698026252ae104cc2405d8bb13f0e" id="r_ga8d8698026252ae104cc2405d8bb13f0e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8d8698026252ae104cc2405d8bb13f0e">CONCATENATE_THREE_STRINGS</a>(__string1,  __string2,  __string3)</td></tr>
<tr class="memdesc:ga8d8698026252ae104cc2405d8bb13f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handy macro that can concatenate three strings.  <br /></td></tr>
<tr class="memitem:gafaff13b938d14da158c3fa1424358353" id="r_gafaff13b938d14da158c3fa1424358353"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafaff13b938d14da158c3fa1424358353">GLOBAL_ENVIRONMENT</a>&#160;&#160;&#160;NULL</td></tr>
<tr class="memdesc:gafaff13b938d14da158c3fa1424358353"><td class="mdescLeft">&#160;</td><td class="mdescRight">The global environment.  <br /></td></tr>
<tr class="memitem:ga8ffb41cff660cdf632693c5bf5a17f52" id="r_ga8ffb41cff660cdf632693c5bf5a17f52"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8ffb41cff660cdf632693c5bf5a17f52">LF_COND_BROADCAST</a>(cond)</td></tr>
<tr class="memdesc:ga8ffb41cff660cdf632693c5bf5a17f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast a condition variable with error checking.  <br /></td></tr>
<tr class="memitem:ga47d73a5ec6fa7ebc7838312cb93c2bb8" id="r_ga47d73a5ec6fa7ebc7838312cb93c2bb8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga47d73a5ec6fa7ebc7838312cb93c2bb8">LF_COND_INIT</a>(cond,  mutex)</td></tr>
<tr class="memdesc:ga47d73a5ec6fa7ebc7838312cb93c2bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize condition variable with error checking.  <br /></td></tr>
<tr class="memitem:gabd8bd827c1d0d4b9f108da9098e10e51" id="r_gabd8bd827c1d0d4b9f108da9098e10e51"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabd8bd827c1d0d4b9f108da9098e10e51">LF_COND_SIGNAL</a>(cond)</td></tr>
<tr class="memdesc:gabd8bd827c1d0d4b9f108da9098e10e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal a condition variable with error checking.  <br /></td></tr>
<tr class="memitem:ga8b24bfd4605a8726dbfc2cee30c27e08" id="r_ga8b24bfd4605a8726dbfc2cee30c27e08"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8b24bfd4605a8726dbfc2cee30c27e08">LF_COND_WAIT</a>(cond)</td></tr>
<tr class="memdesc:ga8b24bfd4605a8726dbfc2cee30c27e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on a condition variable with error checking.  <br /></td></tr>
<tr class="memitem:ga912847660fb8b04317fc270125d6b1f3" id="r_ga912847660fb8b04317fc270125d6b1f3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga912847660fb8b04317fc270125d6b1f3">LF_CRITICAL_SECTION_ENTER</a>(env)</td></tr>
<tr class="memdesc:ga912847660fb8b04317fc270125d6b1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter critical section with error checking.  <br /></td></tr>
<tr class="memitem:ga687e881099481d8efe446ad8a17d72e5" id="r_ga687e881099481d8efe446ad8a17d72e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga687e881099481d8efe446ad8a17d72e5">LF_CRITICAL_SECTION_EXIT</a>(env)</td></tr>
<tr class="memdesc:ga687e881099481d8efe446ad8a17d72e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exit critical section with error checking.  <br /></td></tr>
<tr class="memitem:gad5a08658dc3e13eab4cddafd94734794" id="r_gad5a08658dc3e13eab4cddafd94734794"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad5a08658dc3e13eab4cddafd94734794">LF_LEVEL</a>(index)</td></tr>
<tr class="memdesc:gad5a08658dc3e13eab4cddafd94734794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for extracting the level from the index of a reaction.  <br /></td></tr>
<tr class="memitem:gaac9240f79bd758e00ed7bbf75dafc4fa" id="r_gaac9240f79bd758e00ed7bbf75dafc4fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaac9240f79bd758e00ed7bbf75dafc4fa">LF_MAX</a>(X,  Y)</td></tr>
<tr class="memdesc:gaac9240f79bd758e00ed7bbf75dafc4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for finding the maximum of two values.  <br /></td></tr>
<tr class="memitem:ga4359466e7fdb68dcf8116c469946cd92" id="r_ga4359466e7fdb68dcf8116c469946cd92"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4359466e7fdb68dcf8116c469946cd92">LF_MIN</a>(X,  Y)</td></tr>
<tr class="memdesc:ga4359466e7fdb68dcf8116c469946cd92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility for finding the minimum of two values.  <br /></td></tr>
<tr class="memitem:gadab0b8f13f8462ec0eddc7257ddb5394" id="r_gadab0b8f13f8462ec0eddc7257ddb5394"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadab0b8f13f8462ec0eddc7257ddb5394">LF_MUTEX_INIT</a>(mutex)</td></tr>
<tr class="memdesc:gadab0b8f13f8462ec0eddc7257ddb5394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize mutex with error checking.  <br /></td></tr>
<tr class="memitem:gab907d4c8d53c26fdbcbaa8d02e6a8810" id="r_gab907d4c8d53c26fdbcbaa8d02e6a8810"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab907d4c8d53c26fdbcbaa8d02e6a8810">LF_MUTEX_LOCK</a>(mutex)</td></tr>
<tr class="memdesc:gab907d4c8d53c26fdbcbaa8d02e6a8810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock mutex with error checking.  <br /></td></tr>
<tr class="memitem:ga2bb9c8d2b589a6eb4f72f6750a1133fc" id="r_ga2bb9c8d2b589a6eb4f72f6750a1133fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2bb9c8d2b589a6eb4f72f6750a1133fc">LF_MUTEX_UNLOCK</a>(mutex)</td></tr>
<tr class="memdesc:ga2bb9c8d2b589a6eb4f72f6750a1133fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock mutex with error checking.  <br /></td></tr>
<tr class="memitem:ga3b755b6f58cb9ea64ae2f1ba9a382c86" id="r_ga3b755b6f58cb9ea64ae2f1ba9a382c86"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3b755b6f58cb9ea64ae2f1ba9a382c86">MIN_SLEEP_DURATION</a>&#160;&#160;&#160;<a class="el" href="group__Constants.html#gaa2aeaab0c2033d1db412c8021bff93fc">USEC</a>(10)</td></tr>
<tr class="memdesc:ga3b755b6f58cb9ea64ae2f1ba9a382c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant giving the minimum amount of time to sleep to wait for physical time to reach a logical time.  <br /></td></tr>
<tr class="memitem:ga7516169f705d99222725e6970f0ec703" id="r_ga7516169f705d99222725e6970f0ec703"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7516169f705d99222725e6970f0ec703">SCHED_ADAPTIVE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga7516169f705d99222725e6970f0ec703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Experimental adaptive scheduler.  <br /></td></tr>
<tr class="memitem:ga0238f536f81a61c0d568b36eac9b9a00" id="r_ga0238f536f81a61c0d568b36eac9b9a00"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0238f536f81a61c0d568b36eac9b9a00">SCHED_GEDF_NP</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ga0238f536f81a61c0d568b36eac9b9a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Experimental GEDF-NP scheduler.  <br /></td></tr>
<tr class="memitem:gacc410134875d15b02634fb0aa8163a00" id="r_gacc410134875d15b02634fb0aa8163a00"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacc410134875d15b02634fb0aa8163a00">SCHED_NP</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:gacc410134875d15b02634fb0aa8163a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default non-preemptive scheduler.  <br /></td></tr>
<tr class="memitem:gaaf1dece34c4fcc135c2bd4feaf44e095" id="r_gaaf1dece34c4fcc135c2bd4feaf44e095"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaf1dece34c4fcc135c2bd4feaf44e095">tracepoint_reaction_deadline_missed</a>(env,  reaction,  worker)</td></tr>
<tr class="memdesc:gaaf1dece34c4fcc135c2bd4feaf44e095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace the occurrence of a deadline miss.  <br /></td></tr>
<tr class="memitem:gaebbdf64d4b017a879c69fcda11e74efe" id="r_gaebbdf64d4b017a879c69fcda11e74efe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaebbdf64d4b017a879c69fcda11e74efe">tracepoint_reaction_ends</a>(env,  reaction,  worker)</td></tr>
<tr class="memdesc:gaebbdf64d4b017a879c69fcda11e74efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace the end of a reaction execution.  <br /></td></tr>
<tr class="memitem:ga8c90883c30c8d773cde2df65f9f95e59" id="r_ga8c90883c30c8d773cde2df65f9f95e59"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8c90883c30c8d773cde2df65f9f95e59">tracepoint_reaction_starts</a>(env,  reaction,  worker)</td></tr>
<tr class="memdesc:ga8c90883c30c8d773cde2df65f9f95e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace the start of a reaction execution.  <br /></td></tr>
<tr class="memitem:ga77931b6e1d5a6c7f462902e78db801ba" id="r_ga77931b6e1d5a6c7f462902e78db801ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga77931b6e1d5a6c7f462902e78db801ba">tracepoint_scheduler_advancing_time_ends</a>(env)</td></tr>
<tr class="memdesc:ga77931b6e1d5a6c7f462902e78db801ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace the end of the scheduler waiting for logical time to advance or an event to appear on the event queue.  <br /></td></tr>
<tr class="memitem:ga65f95d31a900f5cde73f152c36f116bf" id="r_ga65f95d31a900f5cde73f152c36f116bf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga65f95d31a900f5cde73f152c36f116bf">tracepoint_scheduler_advancing_time_starts</a>(env)</td></tr>
<tr class="memdesc:ga65f95d31a900f5cde73f152c36f116bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace the start of the scheduler waiting for logical time to advance or an event to appear on the event queue.  <br /></td></tr>
<tr class="memitem:ga4ea3c33342ac48ed332eb540a14ea53f" id="r_ga4ea3c33342ac48ed332eb540a14ea53f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4ea3c33342ac48ed332eb540a14ea53f">tracepoint_worker_wait_ends</a>(env,  worker)</td></tr>
<tr class="memdesc:ga4ea3c33342ac48ed332eb540a14ea53f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace the end of a worker waiting for something to change on the event or reaction queue.  <br /></td></tr>
<tr class="memitem:ga5d07ee55d71cbd545ad4bb577c2dc6b9" id="r_ga5d07ee55d71cbd545ad4bb577c2dc6b9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5d07ee55d71cbd545ad4bb577c2dc6b9">tracepoint_worker_wait_starts</a>(env,  worker)</td></tr>
<tr class="memdesc:ga5d07ee55d71cbd545ad4bb577c2dc6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace the start of a worker waiting for something to change on the reaction queue.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga416845ec4469b3186de047c32402f5e8" id="r_ga416845ec4469b3186de047c32402f5e8"><td class="memItemLeft" align="right" valign="top">typedef struct allocation_record_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga416845ec4469b3186de047c32402f5e8">allocation_record_t</a></td></tr>
<tr class="memdesc:ga416845ec4469b3186de047c32402f5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocation record to keep track of dynamically-allocated memory.  <br /></td></tr>
<tr class="memitem:gaa47b54e9e041dfe1b75fffceb1051466" id="r_gaa47b54e9e041dfe1b75fffceb1051466"><td class="memItemLeft" align="right" valign="top">typedef struct environment_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa47b54e9e041dfe1b75fffceb1051466">environment_t</a></td></tr>
<tr class="memdesc:gaa47b54e9e041dfe1b75fffceb1051466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execution environment.  <br /></td></tr>
<tr class="memitem:ga59f5f6b9c6023baebf9c49c328b639a1" id="r_ga59f5f6b9c6023baebf9c49c328b639a1"><td class="memItemLeft" align="right" valign="top">typedef struct event_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga59f5f6b9c6023baebf9c49c328b639a1">event_t</a></td></tr>
<tr class="memdesc:ga59f5f6b9c6023baebf9c49c328b639a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event activation record for storing event queue entries.  <br /></td></tr>
<tr class="memitem:ga4448d06be794d3f5412d0edb412dc00e" id="r_ga4448d06be794d3f5412d0edb412dc00e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="#gad8239ddc32134716f57e54bb972f6bf0">pqueue_pri_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4448d06be794d3f5412d0edb412dc00e">index_t</a></td></tr>
<tr class="memdesc:ga4448d06be794d3f5412d0edb412dc00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topological order index for reactions.  <br /></td></tr>
<tr class="memitem:ga91b17c088cd50ce69df73f1470a18799" id="r_ga91b17c088cd50ce69df73f1470a18799"><td class="memItemLeft" align="right" valign="top">typedef struct lf_port_base_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga91b17c088cd50ce69df73f1470a18799">lf_port_base_t</a></td></tr>
<tr class="memdesc:ga91b17c088cd50ce69df73f1470a18799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for ports.  <br /></td></tr>
<tr class="memitem:ga0199f9b027e13cf08095d91fe798c663" id="r_ga0199f9b027e13cf08095d91fe798c663"><td class="memItemLeft" align="right" valign="top">typedef struct lf_scheduler_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0199f9b027e13cf08095d91fe798c663">lf_scheduler_t</a></td></tr>
<tr class="memdesc:ga0199f9b027e13cf08095d91fe798c663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters used in schedulers of the threaded reactor C runtime.  <br /></td></tr>
<tr class="memitem:gaa6696d69bef6bb4bdd52ef9ab9d2c614" id="r_gaa6696d69bef6bb4bdd52ef9ab9d2c614"><td class="memItemLeft" align="right" valign="top">typedef struct lf_sparse_io_record_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa6696d69bef6bb4bdd52ef9ab9d2c614">lf_sparse_io_record_t</a></td></tr>
<tr class="memdesc:gaa6696d69bef6bb4bdd52ef9ab9d2c614"><td class="mdescLeft">&#160;</td><td class="mdescRight">A record of the subset of channels of a multiport that have present inputs.  <br /></td></tr>
<tr class="memitem:ga18d624d162daca00e24d1d528ec3c18f" id="r_ga18d624d162daca00e24d1d528ec3c18f"><td class="memItemLeft" align="right" valign="top">typedef struct lf_tag_advancement_barrier_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga18d624d162daca00e24d1d528ec3c18f">lf_tag_advancement_barrier_t</a></td></tr>
<tr class="memdesc:ga18d624d162daca00e24d1d528ec3c18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct representing a barrier in threaded LF programs.  <br /></td></tr>
<tr class="memitem:ga7d95374fb5368705263c2f1ac2579183" id="r_ga7d95374fb5368705263c2f1ac2579183"><td class="memItemLeft" align="right" valign="top">typedef struct mixed_radix_int_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7d95374fb5368705263c2f1ac2579183">mixed_radix_int_t</a></td></tr>
<tr class="memdesc:ga7d95374fb5368705263c2f1ac2579183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a permuted mixed radix integer.  <br /></td></tr>
<tr class="memitem:ga1c3f02694b2a0ec19584c395a88bb6f9" id="r_ga1c3f02694b2a0ec19584c395a88bb6f9"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1c3f02694b2a0ec19584c395a88bb6f9">pqueue_cmp_pri_f</a>) (<a class="el" href="#gad8239ddc32134716f57e54bb972f6bf0">pqueue_pri_t</a> next, <a class="el" href="#gad8239ddc32134716f57e54bb972f6bf0">pqueue_pri_t</a> curr)</td></tr>
<tr class="memdesc:ga1c3f02694b2a0ec19584c395a88bb6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to compare two priorities.  <br /></td></tr>
<tr class="memitem:ga664f0abcd86c8089468869aa3dc6e535" id="r_ga664f0abcd86c8089468869aa3dc6e535"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga664f0abcd86c8089468869aa3dc6e535">pqueue_eq_elem_f</a>) (void *next, void *curr)</td></tr>
<tr class="memdesc:ga664f0abcd86c8089468869aa3dc6e535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to determine whether two elements are equivalent.  <br /></td></tr>
<tr class="memitem:ga31ca7927983005bd7866021819ad7037" id="r_ga31ca7927983005bd7866021819ad7037"><td class="memItemLeft" align="right" valign="top">typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga31ca7927983005bd7866021819ad7037">pqueue_get_pos_f</a>) (void *a)</td></tr>
<tr class="memdesc:ga31ca7927983005bd7866021819ad7037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback functions to get the position of an element.  <br /></td></tr>
<tr class="memitem:gaa84f0100faf971295df5aed226c390a6" id="r_gaa84f0100faf971295df5aed226c390a6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="#gad8239ddc32134716f57e54bb972f6bf0">pqueue_pri_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa84f0100faf971295df5aed226c390a6">pqueue_get_pri_f</a>) (void *a)</td></tr>
<tr class="memdesc:gaa84f0100faf971295df5aed226c390a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to get the priority of an element.  <br /></td></tr>
<tr class="memitem:gad8239ddc32134716f57e54bb972f6bf0" id="r_gad8239ddc32134716f57e54bb972f6bf0"><td class="memItemLeft" align="right" valign="top">typedef unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad8239ddc32134716f57e54bb972f6bf0">pqueue_pri_t</a></td></tr>
<tr class="memdesc:gad8239ddc32134716f57e54bb972f6bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Priority data type.  <br /></td></tr>
<tr class="memitem:ga884902da135214a6167f1536ad4ed4bc" id="r_ga884902da135214a6167f1536ad4ed4bc"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga884902da135214a6167f1536ad4ed4bc">pqueue_print_entry_f</a>) (void *a)</td></tr>
<tr class="memdesc:ga884902da135214a6167f1536ad4ed4bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug callback function to print a entry.  <br /></td></tr>
<tr class="memitem:gafdc8f52cbc45181ef375df22917bc4f9" id="r_gafdc8f52cbc45181ef375df22917bc4f9"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafdc8f52cbc45181ef375df22917bc4f9">pqueue_set_pos_f</a>) (void *a, size_t pos)</td></tr>
<tr class="memdesc:gafdc8f52cbc45181ef375df22917bc4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback functions to set the position of an element.  <br /></td></tr>
<tr class="memitem:ga05e211b59fd9be5939218e11d1132167" id="r_ga05e211b59fd9be5939218e11d1132167"><td class="memItemLeft" align="right" valign="top">typedef struct pqueue_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga05e211b59fd9be5939218e11d1132167">pqueue_t</a></td></tr>
<tr class="memdesc:ga05e211b59fd9be5939218e11d1132167"><td class="mdescLeft">&#160;</td><td class="mdescRight">The priority queue struct.  <br /></td></tr>
<tr class="memitem:gac52d056c47d9595f94d37e95484b3acd" id="r_gac52d056c47d9595f94d37e95484b3acd"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structpqueue__t.html">pqueue_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a></td></tr>
<tr class="memdesc:gac52d056c47d9595f94d37e95484b3acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a priority queue sorted by tags.  <br /></td></tr>
<tr class="memitem:ga149e5fee1c1841bcc96c72f200601d90" id="r_ga149e5fee1c1841bcc96c72f200601d90"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga149e5fee1c1841bcc96c72f200601d90">reaction_function_t</a>) (void *)</td></tr>
<tr class="memdesc:ga149e5fee1c1841bcc96c72f200601d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reaction function type.  <br /></td></tr>
<tr class="memitem:ga6202eb05c29c30bfd6a8fc203de6422f" id="r_ga6202eb05c29c30bfd6a8fc203de6422f"><td class="memItemLeft" align="right" valign="top">typedef struct self_base_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6202eb05c29c30bfd6a8fc203de6422f">self_base_t</a></td></tr>
<tr class="memdesc:ga6202eb05c29c30bfd6a8fc203de6422f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base type for all reactor self structs.  <br /></td></tr>
<tr class="memitem:ga0cb4f0fedba2f1e1fd3893440ab53647" id="r_ga0cb4f0fedba2f1e1fd3893440ab53647"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="#gabe23a36a87d2f0c076da417eb0114c7e">token_freed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0cb4f0fedba2f1e1fd3893440ab53647">token_freed</a></td></tr>
<tr class="memdesc:ga0cb4f0fedba2f1e1fd3893440ab53647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible return values for <a class="el" href="#ga88c890be1f8d45461a6985cbfe6faa99">_lf_done_using</a> and <a class="el" href="#ga2798a92c59a1d46b602298cdbd187ab1">_lf_free_token</a>.  <br /></td></tr>
<tr class="memitem:gad0befcbc6fe23c8dd0b6f483d4067e45" id="r_gad0befcbc6fe23c8dd0b6f483d4067e45"><td class="memItemLeft" align="right" valign="top">typedef struct token_template_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad0befcbc6fe23c8dd0b6f483d4067e45">token_template_t</a></td></tr>
<tr class="memdesc:gad0befcbc6fe23c8dd0b6f483d4067e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for ports (<a class="el" href="structlf__port__base__t.html" title="Base type for ports.">lf_port_base_t</a>) and actions (<a class="el" href="structtrigger__t.html" title="Trigger struct representing an output, timer, action, or input.">trigger_t</a>), which can carry tokens.  <br /></td></tr>
<tr class="memitem:ga58dc2f4a624d2f3030b7e5f3596e58d6" id="r_ga58dc2f4a624d2f3030b7e5f3596e58d6"><td class="memItemLeft" align="right" valign="top">typedef struct token_type_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga58dc2f4a624d2f3030b7e5f3596e58d6">token_type_t</a></td></tr>
<tr class="memdesc:ga58dc2f4a624d2f3030b7e5f3596e58d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type information for tokens.  <br /></td></tr>
<tr class="memitem:ga7804d825257e1eb4296de7da8fec62f6" id="r_ga7804d825257e1eb4296de7da8fec62f6"><td class="memItemLeft" align="right" valign="top">typedef INTERNAL struct trace_record_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7804d825257e1eb4296de7da8fec62f6">trace_record_t</a></td></tr>
<tr class="memdesc:ga7804d825257e1eb4296de7da8fec62f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trace record that gets written in binary to the trace file in the default implementation.  <br /></td></tr>
<tr class="memitem:ga3608c2ed78ba97535f8d82a489846305" id="r_ga3608c2ed78ba97535f8d82a489846305"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a></td></tr>
<tr class="memdesc:ga3608c2ed78ba97535f8d82a489846305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles for scheduled triggers.  <br /></td></tr>
<tr class="memitem:ga3fa7784c89589b49764048e9909d0e07" id="r_ga3fa7784c89589b49764048e9909d0e07"><td class="memItemLeft" align="right" valign="top">typedef unsigned short int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3fa7784c89589b49764048e9909d0e07">ushort</a></td></tr>
<tr class="memdesc:ga3fa7784c89589b49764048e9909d0e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsigned short type.  <br /></td></tr>
<tr class="memitem:ga4caef7fcd0476a936700512d28a23aa8" id="r_ga4caef7fcd0476a936700512d28a23aa8"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4caef7fcd0476a936700512d28a23aa8">watchdog_function_t</a>) (void *)</td></tr>
<tr class="memdesc:ga4caef7fcd0476a936700512d28a23aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Watchdog function type.  <br /></td></tr>
<tr class="memitem:gaee1cd2bc521f76fa428cc659474d9570" id="r_gaee1cd2bc521f76fa428cc659474d9570"><td class="memItemLeft" align="right" valign="top">typedef struct watchdog_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaee1cd2bc521f76fa428cc659474d9570">watchdog_t</a></td></tr>
<tr class="memdesc:gaee1cd2bc521f76fa428cc659474d9570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typdef for <a class="el" href="structwatchdog__t.html" title="Typdef for watchdog_t struct, used to call watchdog handler.">watchdog_t</a> struct, used to call watchdog handler.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga0183c0b43037a172a1cd9aa6ed6b3822" id="r_ga0183c0b43037a172a1cd9aa6ed6b3822"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0183c0b43037a172a1cd9aa6ed6b3822">lf_spacing_policy_t</a> { <a class="el" href="#gga0183c0b43037a172a1cd9aa6ed6b3822a893b1cf0de04eaf44a009fecabd16b90">defer</a>
, <a class="el" href="#gga0183c0b43037a172a1cd9aa6ed6b3822a1e34755950041e469ca91ff2b7d1c019">drop</a>
, <a class="el" href="#gga0183c0b43037a172a1cd9aa6ed6b3822a8a4df390c6f816287b90cb2b33ab4323">replace</a>
, <a class="el" href="#gga0183c0b43037a172a1cd9aa6ed6b3822a15edc24cdf7dea17a43c6c50580eba2b">update</a>
 }</td></tr>
<tr class="memdesc:ga0183c0b43037a172a1cd9aa6ed6b3822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy for handling scheduled events that violate the specified minimum interarrival time.  <a href="#ga0183c0b43037a172a1cd9aa6ed6b3822">More...</a><br /></td></tr>
<tr class="memitem:ga759ba374f75ea0025b9af1bb35f14d7e" id="r_ga759ba374f75ea0025b9af1bb35f14d7e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga759ba374f75ea0025b9af1bb35f14d7e">port_status_t</a> { <a class="el" href="#gga759ba374f75ea0025b9af1bb35f14d7ea1a8fae68a24a59c5629c241401fabb08">absent</a> = false
, <a class="el" href="#gga759ba374f75ea0025b9af1bb35f14d7eaaeb73d7cb56b19bff3d9f80426ed3267">present</a> = true
, <a class="el" href="#gga759ba374f75ea0025b9af1bb35f14d7ea5b9f6d065e6e98483b3d3ed01f4f6cbe">unknown</a>
 }</td></tr>
<tr class="memdesc:ga759ba374f75ea0025b9af1bb35f14d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status of a given port at a given logical time.  <a href="#ga759ba374f75ea0025b9af1bb35f14d7e">More...</a><br /></td></tr>
<tr class="memitem:ga6e496c05213aa4bcbc0055ceee7808fa" id="r_ga6e496c05213aa4bcbc0055ceee7808fa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6e496c05213aa4bcbc0055ceee7808fa">reaction_status_t</a> { <a class="el" href="#gga6e496c05213aa4bcbc0055ceee7808faa76c1253bb97844abbdf89af6dfc3c7d6">inactive</a> = 0
, <a class="el" href="#gga6e496c05213aa4bcbc0055ceee7808faa8ff224790af0c8a18f259da89dfb2225">queued</a>
, <a class="el" href="#gga6e496c05213aa4bcbc0055ceee7808faab514bba77fe136c3a3b6f56b818f7b0c">running</a>
 }</td></tr>
<tr class="memdesc:ga6e496c05213aa4bcbc0055ceee7808fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status of a given reaction at a given logical time.  <a href="#ga6e496c05213aa4bcbc0055ceee7808fa">More...</a><br /></td></tr>
<tr class="memitem:gabe23a36a87d2f0c076da417eb0114c7e" id="r_gabe23a36a87d2f0c076da417eb0114c7e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabe23a36a87d2f0c076da417eb0114c7e">token_freed</a> { <a class="el" href="#ggabe23a36a87d2f0c076da417eb0114c7ea3d7522b54086645e077eb70e78731c5c">NOT_FREED</a> = 0
, <a class="el" href="#ggabe23a36a87d2f0c076da417eb0114c7ea417a0268666423fd955fea6f38cde238">VALUE_FREED</a>
, <a class="el" href="#ggabe23a36a87d2f0c076da417eb0114c7ea0a6094445d7a54e61aa3a43f6d017e2b">TOKEN_FREED</a>
, <a class="el" href="#ggabe23a36a87d2f0c076da417eb0114c7ea02ef194d373714ee3ac62226729e0cb0">TOKEN_AND_VALUE_FREED</a>
 }</td></tr>
<tr class="memdesc:gabe23a36a87d2f0c076da417eb0114c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible return values for <a class="el" href="#ga88c890be1f8d45461a6985cbfe6faa99">_lf_done_using</a> and <a class="el" href="#ga2798a92c59a1d46b602298cdbd187ab1">_lf_free_token</a>.  <a href="#gabe23a36a87d2f0c076da417eb0114c7e">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4659db62370c837baa55484134b3bfb7" id="r_ga4659db62370c837baa55484134b3bfb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4659db62370c837baa55484134b3bfb7">_lf_advance_tag</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env, <a class="el" href="structtag__t.html">tag_t</a> next_tag)</td></tr>
<tr class="memdesc:ga4659db62370c837baa55484134b3bfb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance from the current tag to the next.  <br /></td></tr>
<tr class="memitem:ga6396bfcdac50ddb71b6b29fa33a3cc5d" id="r_ga6396bfcdac50ddb71b6b29fa33a3cc5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structevent__t.html">event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6396bfcdac50ddb71b6b29fa33a3cc5d">_lf_create_dummy_events</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env, <a class="el" href="structtag__t.html">tag_t</a> tag)</td></tr>
<tr class="memdesc:ga6396bfcdac50ddb71b6b29fa33a3cc5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a dummy event with the specified tag.  <br /></td></tr>
<tr class="memitem:ga5a0540790dfc6d954fb443da3336ce27" id="r_ga5a0540790dfc6d954fb443da3336ce27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5a0540790dfc6d954fb443da3336ce27">_lf_decrement_tag_barrier_locked</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env)</td></tr>
<tr class="memdesc:ga5a0540790dfc6d954fb443da3336ce27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the total number of pending barrier requests for the environment tag barrier.  <br /></td></tr>
<tr class="memitem:ga88c890be1f8d45461a6985cbfe6faa99" id="r_ga88c890be1f8d45461a6985cbfe6faa99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#gabe23a36a87d2f0c076da417eb0114c7e">token_freed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga88c890be1f8d45461a6985cbfe6faa99">_lf_done_using</a> (<a class="el" href="structlf__token__t.html">lf_token_t</a> *token)</td></tr>
<tr class="memdesc:ga88c890be1f8d45461a6985cbfe6faa99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the reference count of the specified token.  <br /></td></tr>
<tr class="memitem:gafd97c46ee623b1ae34a70088ee9b5020" id="r_gafd97c46ee623b1ae34a70088ee9b5020"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafd97c46ee623b1ae34a70088ee9b5020">_lf_free_all_tokens</a> ()</td></tr>
<tr class="memdesc:gafd97c46ee623b1ae34a70088ee9b5020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all tokens.  <br /></td></tr>
<tr class="memitem:ga2798a92c59a1d46b602298cdbd187ab1" id="r_ga2798a92c59a1d46b602298cdbd187ab1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#gabe23a36a87d2f0c076da417eb0114c7e">token_freed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2798a92c59a1d46b602298cdbd187ab1">_lf_free_token</a> (<a class="el" href="structlf__token__t.html">lf_token_t</a> *token)</td></tr>
<tr class="memdesc:ga2798a92c59a1d46b602298cdbd187ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the specified token, if appropriate.  <br /></td></tr>
<tr class="memitem:gab1efa737bf70317f885c1dc772c4f23b" id="r_gab1efa737bf70317f885c1dc772c4f23b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab1efa737bf70317f885c1dc772c4f23b">_lf_free_token_copies</a> (void)</td></tr>
<tr class="memdesc:gab1efa737bf70317f885c1dc772c4f23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free token copies made for mutable inputs.  <br /></td></tr>
<tr class="memitem:gac109cd752121228507a95495a1eb6d8f" id="r_gac109cd752121228507a95495a1eb6d8f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac109cd752121228507a95495a1eb6d8f">_lf_get_environments</a> (<a class="el" href="structenvironment__t.html">environment_t</a> **envs)</td></tr>
<tr class="memdesc:gac109cd752121228507a95495a1eb6d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the argument to point to the beginning of the array of environments in this program.  <br /></td></tr>
<tr class="memitem:ga8f2f9c98968a10bf4d37077fd363ac48" id="r_ga8f2f9c98968a10bf4d37077fd363ac48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8f2f9c98968a10bf4d37077fd363ac48">_lf_get_token</a> (<a class="el" href="structtoken__template__t.html">token_template_t</a> *tmplt)</td></tr>
<tr class="memdesc:ga8f2f9c98968a10bf4d37077fd363ac48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a token for the specified template.  <br /></td></tr>
<tr class="memitem:gaa8e97abcbd89bb371d396da44ff4becb" id="r_gaa8e97abcbd89bb371d396da44ff4becb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa8e97abcbd89bb371d396da44ff4becb">_lf_increment_tag_barrier</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env, <a class="el" href="structtag__t.html">tag_t</a> future_tag)</td></tr>
<tr class="memdesc:gaa8e97abcbd89bb371d396da44ff4becb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise a barrier to prevent the current tag for the specified environment from advancing to or beyond the value of the future_tag argument, if possible.  <br /></td></tr>
<tr class="memitem:ga01d3c6cadb7930c096ffe1f794173f5c" id="r_ga01d3c6cadb7930c096ffe1f794173f5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga01d3c6cadb7930c096ffe1f794173f5c">_lf_increment_tag_barrier_locked</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env, <a class="el" href="structtag__t.html">tag_t</a> future_tag)</td></tr>
<tr class="memdesc:ga01d3c6cadb7930c096ffe1f794173f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of _lf_increment_tag_barrier to call when the caller holds the mutex.  <br /></td></tr>
<tr class="memitem:ga5d1a2996844350bc1e29de47e3b56644" id="r_ga5d1a2996844350bc1e29de47e3b56644"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5d1a2996844350bc1e29de47e3b56644">_lf_initialize_template</a> (<a class="el" href="structtoken__template__t.html">token_template_t</a> *tmplt, size_t element_size)</td></tr>
<tr class="memdesc:ga5d1a2996844350bc1e29de47e3b56644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the specified template to contain a token that is an.  <br /></td></tr>
<tr class="memitem:ga61a2c70695093f8a38b1e922fb36547f" id="r_ga61a2c70695093f8a38b1e922fb36547f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga61a2c70695093f8a38b1e922fb36547f">_lf_initialize_timer</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env, <a class="el" href="structtrigger__t.html">trigger_t</a> *timer)</td></tr>
<tr class="memdesc:ga61a2c70695093f8a38b1e922fb36547f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the given timer.  <br /></td></tr>
<tr class="memitem:ga37bdd5c8fe3428b85eff05f0629da411" id="r_ga37bdd5c8fe3428b85eff05f0629da411"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga37bdd5c8fe3428b85eff05f0629da411">_lf_initialize_timers</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env)</td></tr>
<tr class="memdesc:ga37bdd5c8fe3428b85eff05f0629da411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize all the timers in the environment.  <br /></td></tr>
<tr class="memitem:ga6e2c7940f2e59f5ff57807df6b41f5fe" id="r_ga6e2c7940f2e59f5ff57807df6b41f5fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6e2c7940f2e59f5ff57807df6b41f5fe">_lf_initialize_token</a> (<a class="el" href="structtoken__template__t.html">token_template_t</a> *tmplt, size_t length)</td></tr>
<tr class="memdesc:ga6e2c7940f2e59f5ff57807df6b41f5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a token for storing an array of the specified length with new memory allocated (using calloc, so initialize to zero) for storing that array.  <br /></td></tr>
<tr class="memitem:gac171b72d59f37653f012d30cad72a2d2" id="r_gac171b72d59f37653f012d30cad72a2d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac171b72d59f37653f012d30cad72a2d2">_lf_initialize_token_with_value</a> (<a class="el" href="structtoken__template__t.html">token_template_t</a> *tmplt, void *value, size_t length)</td></tr>
<tr class="memdesc:gac171b72d59f37653f012d30cad72a2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a token storing the specified value, which is assumed to be either a scalar (if length is 1) or an array of the specified length.  <br /></td></tr>
<tr class="memitem:ga52ffa06ff177dc19d33713beb2ff344e" id="r_ga52ffa06ff177dc19d33713beb2ff344e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga52ffa06ff177dc19d33713beb2ff344e">_lf_initialize_trigger_objects</a> ()</td></tr>
<tr class="memdesc:ga52ffa06ff177dc19d33713beb2ff344e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generated function that produces a table containing all triggers (i.e., inputs, timers, and actions).  <br /></td></tr>
<tr class="memitem:gaa6a016400f119168b48505e51baaaa55" id="r_gaa6a016400f119168b48505e51baaaa55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa6a016400f119168b48505e51baaaa55">_lf_initialize_watchdogs</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env)</td></tr>
<tr class="memdesc:gaa6a016400f119168b48505e51baaaa55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to initialize mutexes for watchdogs.  <br /></td></tr>
<tr class="memitem:gaeac3f6a2d15f30e3adecc9f431162bef" id="r_gaeac3f6a2d15f30e3adecc9f431162bef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaeac3f6a2d15f30e3adecc9f431162bef">_lf_insert_reactions_for_trigger</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env, <a class="el" href="structtrigger__t.html">trigger_t</a> *trigger, <a class="el" href="structlf__token__t.html">lf_token_t</a> *token)</td></tr>
<tr class="memdesc:gaeac3f6a2d15f30e3adecc9f431162bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert reactions triggered by trigger to the reaction queue.  <br /></td></tr>
<tr class="memitem:ga7fe988f0eee005defaa2ad2c9f1f2fd8" id="r_ga7fe988f0eee005defaa2ad2c9f1f2fd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7fe988f0eee005defaa2ad2c9f1f2fd8">_lf_invoke_reaction</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env, <a class="el" href="structreaction__t.html">reaction_t</a> *reaction, int worker)</td></tr>
<tr class="memdesc:ga7fe988f0eee005defaa2ad2c9f1f2fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the specified reaction on the specified worker in the specified environment.  <br /></td></tr>
<tr class="memitem:ga23e88870b9a699d1a067ff5b397e0887" id="r_ga23e88870b9a699d1a067ff5b397e0887"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlf__multiport__iterator__t.html">lf_multiport_iterator_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga23e88870b9a699d1a067ff5b397e0887">_lf_multiport_iterator_impl</a> (<a class="el" href="structlf__port__base__t.html">lf_port_base_t</a> **port, int width)</td></tr>
<tr class="memdesc:ga23e88870b9a699d1a067ff5b397e0887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an array of pointers to port structs, return an iterator that can be used to iterate over the present channels.  <br /></td></tr>
<tr class="memitem:ga4616dad8eeb4cbe04a4f9697d3de9b16" id="r_ga4616dad8eeb4cbe04a4f9697d3de9b16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlf__token__t.html">lf_token_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4616dad8eeb4cbe04a4f9697d3de9b16">_lf_new_token</a> (<a class="el" href="structtoken__type__t.html">token_type_t</a> *type, void *value, size_t length)</td></tr>
<tr class="memdesc:ga4616dad8eeb4cbe04a4f9697d3de9b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a new token with the specified type, value, and length.  <br /></td></tr>
<tr class="memitem:gab9e357a21e338cd3719cdec409b9f7a6" id="r_gab9e357a21e338cd3719cdec409b9f7a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab9e357a21e338cd3719cdec409b9f7a6">_lf_next_locked</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env)</td></tr>
<tr class="memdesc:gab9e357a21e338cd3719cdec409b9f7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the logical time.  <br /></td></tr>
<tr class="memitem:ga41e1c14ed7c1ab5ab19b8b98d84006b6" id="r_ga41e1c14ed7c1ab5ab19b8b98d84006b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga41e1c14ed7c1ab5ab19b8b98d84006b6">_lf_pop_events</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env)</td></tr>
<tr class="memdesc:ga41e1c14ed7c1ab5ab19b8b98d84006b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop all events from event_q with tag equal to current tag.  <br /></td></tr>
<tr class="memitem:ga292c73e4f09daa50330b53079df620a9" id="r_ga292c73e4f09daa50330b53079df620a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga292c73e4f09daa50330b53079df620a9">_lf_register_trace_event</a> (void *pointer1, void *pointer2, <a class="el" href="group__Tracing.html#gaeec3d6d67240b942f12f5d8770698ae3">_lf_trace_object_t</a> type, char *description)</td></tr>
<tr class="memdesc:ga292c73e4f09daa50330b53079df620a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a trace object.  <br /></td></tr>
<tr class="memitem:gabeff98dcfb6b5715aac8e1438c5a6e77" id="r_gabeff98dcfb6b5715aac8e1438c5a6e77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabeff98dcfb6b5715aac8e1438c5a6e77">_lf_replace_template_token</a> (<a class="el" href="structtoken__template__t.html">token_template_t</a> *tmplt, <a class="el" href="structlf__token__t.html">lf_token_t</a> *newtoken)</td></tr>
<tr class="memdesc:gabeff98dcfb6b5715aac8e1438c5a6e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the token in the specified template, if there is one, with a new one.  <br /></td></tr>
<tr class="memitem:gaf2c6b4fac0a87c3cc914c713714e1fca" id="r_gaf2c6b4fac0a87c3cc914c713714e1fca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf2c6b4fac0a87c3cc914c713714e1fca">_lf_sched_advance_tag_locked</a> (<a class="el" href="structlf__scheduler__t.html">lf_scheduler_t</a> *sched)</td></tr>
<tr class="memdesc:gaf2c6b4fac0a87c3cc914c713714e1fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the tag to the next tag on the event queue.  <br /></td></tr>
<tr class="memitem:ga9d2634d70492498740984f320dffe8f0" id="r_ga9d2634d70492498740984f320dffe8f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9d2634d70492498740984f320dffe8f0">_lf_schedule_at_tag</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env, <a class="el" href="structtrigger__t.html">trigger_t</a> *trigger, <a class="el" href="structtag__t.html">tag_t</a> tag, <a class="el" href="structlf__token__t.html">lf_token_t</a> *token)</td></tr>
<tr class="memdesc:ga9d2634d70492498740984f320dffe8f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an event at a specific tag (time, microstep).  <br /></td></tr>
<tr class="memitem:gaf31c25686db5996e9f3493745e63856a" id="r_gaf31c25686db5996e9f3493745e63856a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf31c25686db5996e9f3493745e63856a">_lf_schedule_copy</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env, void *action, <a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> offset, void *value, size_t length)</td></tr>
<tr class="memdesc:gaf31c25686db5996e9f3493745e63856a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule an action to occur with the specified value and time offset with a copy of the specified value.  <br /></td></tr>
<tr class="memitem:ga6d8b49ac9cf089b35a5d2df6a9209255" id="r_ga6d8b49ac9cf089b35a5d2df6a9209255"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6d8b49ac9cf089b35a5d2df6a9209255">_lf_schedule_token</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env, void *action, <a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> extra_delay, <a class="el" href="structlf__token__t.html">lf_token_t</a> *token)</td></tr>
<tr class="memdesc:ga6d8b49ac9cf089b35a5d2df6a9209255"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule the specified action at a later tag with the specified token as a payload.  <br /></td></tr>
<tr class="memitem:gab5d69d8631d56d64fb90547a8d6b10cd" id="r_gab5d69d8631d56d64fb90547a8d6b10cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab5d69d8631d56d64fb90547a8d6b10cd">_lf_start_time_step</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env)</td></tr>
<tr class="memdesc:gab5d69d8631d56d64fb90547a8d6b10cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform whatever is needed to start a time step.  <br /></td></tr>
<tr class="memitem:gaf31f8aca1b004a6e5e0e695063de1b47" id="r_gaf31f8aca1b004a6e5e0e695063de1b47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf31f8aca1b004a6e5e0e695063de1b47">_lf_trigger_reaction</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env, <a class="el" href="structreaction__t.html">reaction_t</a> *reaction, int worker_number)</td></tr>
<tr class="memdesc:gaf31f8aca1b004a6e5e0e695063de1b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger the specified reaction on the specified worker in the specified environment.  <br /></td></tr>
<tr class="memitem:ga282a342efac4fc3e198fb9656f0a9adc" id="r_ga282a342efac4fc3e198fb9656f0a9adc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga282a342efac4fc3e198fb9656f0a9adc">_lf_trigger_shutdown_reactions</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env)</td></tr>
<tr class="memdesc:ga282a342efac4fc3e198fb9656f0a9adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger all the shutdown reactions in the specified environment.  <br /></td></tr>
<tr class="memitem:gafd3a0abded3adbc25ab7dbc261e7b16c" id="r_gafd3a0abded3adbc25ab7dbc261e7b16c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafd3a0abded3adbc25ab7dbc261e7b16c">_lf_trigger_startup_reactions</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env)</td></tr>
<tr class="memdesc:gafd3a0abded3adbc25ab7dbc261e7b16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger all the startup reactions in the specified environment.  <br /></td></tr>
<tr class="memitem:ga3d1cd5263a79c14e62a5fb34530a0a93" id="r_ga3d1cd5263a79c14e62a5fb34530a0a93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3d1cd5263a79c14e62a5fb34530a0a93">_lf_wait_on_tag_barrier</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env, <a class="el" href="structtag__t.html">tag_t</a> proposed_tag)</td></tr>
<tr class="memdesc:ga3d1cd5263a79c14e62a5fb34530a0a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on the tag barrier for the environment.  <br /></td></tr>
<tr class="memitem:gab3957d31bade9b6ebcbc27aae6be3f14" id="r_gab3957d31bade9b6ebcbc27aae6be3f14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab3957d31bade9b6ebcbc27aae6be3f14">_lf_watchdog_terminate_all</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env)</td></tr>
<tr class="memdesc:gab3957d31bade9b6ebcbc27aae6be3f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates all watchdogs inside the environment.  <br /></td></tr>
<tr class="memitem:gad0ae74c1c8d1935b3fb92e546988503c" id="r_gad0ae74c1c8d1935b3fb92e546988503c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad0ae74c1c8d1935b3fb92e546988503c">call_tracepoint</a> (int event_type, void *reactor, <a class="el" href="structtag__t.html">tag_t</a> tag, int worker, int src_id, int dst_id, <a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a> *physical_time, <a class="el" href="structtrigger__t.html">trigger_t</a> *trigger, <a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> extra_delay)</td></tr>
<tr class="memdesc:gad0ae74c1c8d1935b3fb92e546988503c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass the provided info to the tracing module.  <br /></td></tr>
<tr class="memitem:gaf73b90f735c070d534171f3e92730ac8" id="r_gaf73b90f735c070d534171f3e92730ac8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf73b90f735c070d534171f3e92730ac8">environment_free</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env)</td></tr>
<tr class="memdesc:gaf73b90f735c070d534171f3e92730ac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the dynamically allocated memory on the environment struct.  <br /></td></tr>
<tr class="memitem:gab49da5954eb69f3d126162da44c25b36" id="r_gab49da5954eb69f3d126162da44c25b36"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab49da5954eb69f3d126162da44c25b36">environment_init</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env, const char *name, int id, int num_workers, int num_timers, int num_startup_reactions, int num_shutdown_reactions, int num_reset_reactions, int num_is_present_fields, int num_modes, int num_state_resets, int num_watchdogs, const char *trace_file_name)</td></tr>
<tr class="memdesc:gab49da5954eb69f3d126162da44c25b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an environment struct with parameters given in the arguments.  <br /></td></tr>
<tr class="memitem:gaf23dde6465214cc92114e0c49bccdc72" id="r_gaf23dde6465214cc92114e0c49bccdc72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf23dde6465214cc92114e0c49bccdc72">environment_init_tags</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env, <a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a> <a class="el" href="trace__util_8h.html#a20b56e8fb05c017508f1c4fa2e311a87">start_time</a>, <a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> <a class="el" href="reactor__common_8h.html#a8079fdfadf07cba8a660c9c25cb9dc77">duration</a>)</td></tr>
<tr class="memdesc:gaf23dde6465214cc92114e0c49bccdc72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the start and stop tags on the environment struct.  <br /></td></tr>
<tr class="memitem:gaeb51302599cae953b2b8942088879e2f" id="r_gaeb51302599cae953b2b8942088879e2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaeb51302599cae953b2b8942088879e2f">environment_verify</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env)</td></tr>
<tr class="memdesc:gaeb51302599cae953b2b8942088879e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify that the environment is correctly set up.  <br /></td></tr>
<tr class="memitem:ga8db9f1cd3ea7eb70e6958e732b26e61d" id="r_ga8db9f1cd3ea7eb70e6958e732b26e61d"><td class="memItemLeft" align="right" valign="top">void void void void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8db9f1cd3ea7eb70e6958e732b26e61d">error</a> (const char *msg)</td></tr>
<tr class="memdesc:ga8db9f1cd3ea7eb70e6958e732b26e61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the error defined by the errno variable with the specified message as a prefix, then exit with error code 1.  <br /></td></tr>
<tr class="memitem:ga9b50c51a9046dfb8814b2f609020d0a4" id="r_ga9b50c51a9046dfb8814b2f609020d0a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9b50c51a9046dfb8814b2f609020d0a4">get_next_event_tag</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env)</td></tr>
<tr class="memdesc:ga9b50c51a9046dfb8814b2f609020d0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tag of the next event on the event queue.  <br /></td></tr>
<tr class="memitem:gacd6d67f4e05f2780b23aef72f92468f5" id="r_gacd6d67f4e05f2780b23aef72f92468f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#gad8239ddc32134716f57e54bb972f6bf0">pqueue_pri_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacd6d67f4e05f2780b23aef72f92468f5">get_reaction_index</a> (void *reaction)</td></tr>
<tr class="memdesc:gacd6d67f4e05f2780b23aef72f92468f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report a priority equal to the index of the given reaction.  <br /></td></tr>
<tr class="memitem:ga051ae6a8bc2b547818e06cb0c72b14a2" id="r_ga051ae6a8bc2b547818e06cb0c72b14a2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga051ae6a8bc2b547818e06cb0c72b14a2">get_reaction_position</a> (void *reaction)</td></tr>
<tr class="memdesc:ga051ae6a8bc2b547818e06cb0c72b14a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the given reaction's position in the queue.  <br /></td></tr>
<tr class="memitem:ga987e40d356a70d4799d6fe56920d3b8f" id="r_ga987e40d356a70d4799d6fe56920d3b8f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga987e40d356a70d4799d6fe56920d3b8f">in_no_particular_order</a> (<a class="el" href="#gad8239ddc32134716f57e54bb972f6bf0">pqueue_pri_t</a> thiz, <a class="el" href="#gad8239ddc32134716f57e54bb972f6bf0">pqueue_pri_t</a> that)</td></tr>
<tr class="memdesc:ga987e40d356a70d4799d6fe56920d3b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 0 regardless of argument order.  <br /></td></tr>
<tr class="memitem:ga19d650d18c331602f44c642bce2456e8" id="r_ga19d650d18c331602f44c642bce2456e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga19d650d18c331602f44c642bce2456e8">in_reverse_order</a> (<a class="el" href="#gad8239ddc32134716f57e54bb972f6bf0">pqueue_pri_t</a> thiz, <a class="el" href="#gad8239ddc32134716f57e54bb972f6bf0">pqueue_pri_t</a> that)</td></tr>
<tr class="memdesc:ga19d650d18c331602f44c642bce2456e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is greater than the second and zero otherwise.  <br /></td></tr>
<tr class="memitem:ga42d0bf55641d6ff4390081175de65496" id="r_ga42d0bf55641d6ff4390081175de65496"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga42d0bf55641d6ff4390081175de65496">initialize_global</a> ()</td></tr>
<tr class="memdesc:ga42d0bf55641d6ff4390081175de65496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize global variables and start tracing before calling the <a class="el" href="#ga52ffa06ff177dc19d33713beb2ff344e">_lf_initialize_trigger_objects()</a> function.  <br /></td></tr>
<tr class="memitem:ga1a5fdb69bc112879d4014bb0790e843c" id="r_ga1a5fdb69bc112879d4014bb0790e843c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1a5fdb69bc112879d4014bb0790e843c">lf_allocate</a> (size_t count, size_t size, struct <a class="el" href="structallocation__record__t.html">allocation_record_t</a> **head)</td></tr>
<tr class="memdesc:ga1a5fdb69bc112879d4014bb0790e843c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory and record on the specified allocation record (a self struct).  <br /></td></tr>
<tr class="memitem:ga6876ddf559d9ecf14ae78f76e6ff2045" id="r_ga6876ddf559d9ecf14ae78f76e6ff2045"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga4448d06be794d3f5412d0edb412dc00e">index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6876ddf559d9ecf14ae78f76e6ff2045">lf_combine_deadline_and_level</a> (<a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> deadline, int level)</td></tr>
<tr class="memdesc:ga6876ddf559d9ecf14ae78f76e6ff2045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine a deadline and a level into a single index for sorting in the reaction queue.  <br /></td></tr>
<tr class="memitem:gaf2a6b2663dca116472afc45b50040a3d" id="r_gaf2a6b2663dca116472afc45b50040a3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf2a6b2663dca116472afc45b50040a3d">lf_create_environments</a> (void)</td></tr>
<tr class="memdesc:gaf2a6b2663dca116472afc45b50040a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and initialize the required number of environments for the program.  <br /></td></tr>
<tr class="memitem:gaf61e1a6183ff7d40b1b998c08447130e" id="r_gaf61e1a6183ff7d40b1b998c08447130e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf61e1a6183ff7d40b1b998c08447130e">lf_delay_strict</a> (<a class="el" href="structtag__t.html">tag_t</a> tag, <a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> interval)</td></tr>
<tr class="memdesc:gaf61e1a6183ff7d40b1b998c08447130e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the latest tag strictly less than the specified tag plus the interval, unless tag is NEVER or interval is negative (including NEVER),.  <br /></td></tr>
<tr class="memitem:ga6e9c2ed60ca5adec5ba3f43d4410dc75" id="r_ga6e9c2ed60ca5adec5ba3f43d4410dc75"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6e9c2ed60ca5adec5ba3f43d4410dc75">lf_fed_id</a> (void)</td></tr>
<tr class="memdesc:ga6e9c2ed60ca5adec5ba3f43d4410dc75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the federate ID or -1 if this program is not part of a federation.  <br /></td></tr>
<tr class="memitem:gaa028b6b458854278bb2a2de486e40268" id="r_gaa028b6b458854278bb2a2de486e40268"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa028b6b458854278bb2a2de486e40268">lf_free</a> (struct <a class="el" href="structallocation__record__t.html">allocation_record_t</a> **head)</td></tr>
<tr class="memdesc:gaa028b6b458854278bb2a2de486e40268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory on the specified allocation record (a self struct).  <br /></td></tr>
<tr class="memitem:gadf76c4fc43b07691236fa6a483762481" id="r_gadf76c4fc43b07691236fa6a483762481"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadf76c4fc43b07691236fa6a483762481">lf_free_all_reactors</a> (void)</td></tr>
<tr class="memdesc:gadf76c4fc43b07691236fa6a483762481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all the reactors that are allocated with <code><a class="el" href="#ga129c6df527165b2378d1dc4852411c35">lf_new_reactor(size_t)</a></code>.  <br /></td></tr>
<tr class="memitem:ga2f0b7c8d624c2da93012538bd93568ad" id="r_ga2f0b7c8d624c2da93012538bd93568ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2f0b7c8d624c2da93012538bd93568ad">lf_free_reactor</a> (<a class="el" href="structself__base__t.html">self_base_t</a> *self)</td></tr>
<tr class="memdesc:ga2f0b7c8d624c2da93012538bd93568ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the specified reactor.  <br /></td></tr>
<tr class="memitem:gaeb163964110b0029fc4c460b2478ea4d" id="r_gaeb163964110b0029fc4c460b2478ea4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structevent__t.html">event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaeb163964110b0029fc4c460b2478ea4d">lf_get_new_event</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env)</td></tr>
<tr class="memdesc:gaeb163964110b0029fc4c460b2478ea4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a new event.  <br /></td></tr>
<tr class="memitem:ga129c6df527165b2378d1dc4852411c35" id="r_ga129c6df527165b2378d1dc4852411c35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structself__base__t.html">self_base_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga129c6df527165b2378d1dc4852411c35">lf_new_reactor</a> (size_t size)</td></tr>
<tr class="memdesc:ga129c6df527165b2378d1dc4852411c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for a new runtime instance of a reactor.  <br /></td></tr>
<tr class="memitem:gaae4a4a9ce970c18bff7785cf7863777c" id="r_gaae4a4a9ce970c18bff7785cf7863777c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaae4a4a9ce970c18bff7785cf7863777c">lf_print_snapshot</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env)</td></tr>
<tr class="memdesc:gaae4a4a9ce970c18bff7785cf7863777c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a snapshot of the priority queues used during execution (for debugging).  <br /></td></tr>
<tr class="memitem:ga0dbdf3a0cb8b0075acfc45437f4c7e27" id="r_ga0dbdf3a0cb8b0075acfc45437f4c7e27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0dbdf3a0cb8b0075acfc45437f4c7e27">lf_recycle_event</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env, <a class="el" href="structevent__t.html">event_t</a> *e)</td></tr>
<tr class="memdesc:ga0dbdf3a0cb8b0075acfc45437f4c7e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recycle the given event.  <br /></td></tr>
<tr class="memitem:ga3c0888056123fd1ef7c2fdd7a8081ddf" id="r_ga3c0888056123fd1ef7c2fdd7a8081ddf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3c0888056123fd1ef7c2fdd7a8081ddf">lf_replace_token</a> (<a class="el" href="structevent__t.html">event_t</a> *event, <a class="el" href="structlf__token__t.html">lf_token_t</a> *token)</td></tr>
<tr class="memdesc:ga3c0888056123fd1ef7c2fdd7a8081ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the token on the specified event with the specified token and free the old token.  <br /></td></tr>
<tr class="memitem:ga485e4339d95d23ae5bcbb06c244e7145" id="r_ga485e4339d95d23ae5bcbb06c244e7145"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga485e4339d95d23ae5bcbb06c244e7145">lf_sched_done_with_reaction</a> (size_t worker_number, <a class="el" href="structreaction__t.html">reaction_t</a> *done_reaction)</td></tr>
<tr class="memdesc:ga485e4339d95d23ae5bcbb06c244e7145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inform the scheduler that worker thread 'worker_number' is done executing the 'done_reaction'.  <br /></td></tr>
<tr class="memitem:ga2139bc60dc5be91d750d5e877af07843" id="r_ga2139bc60dc5be91d750d5e877af07843"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2139bc60dc5be91d750d5e877af07843">lf_sched_free</a> (<a class="el" href="structlf__scheduler__t.html">lf_scheduler_t</a> *scheduler)</td></tr>
<tr class="memdesc:ga2139bc60dc5be91d750d5e877af07843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the memory used by the scheduler.  <br /></td></tr>
<tr class="memitem:ga95107b668caa59d5bca9fff1af21e7fb" id="r_ga95107b668caa59d5bca9fff1af21e7fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structreaction__t.html">reaction_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga95107b668caa59d5bca9fff1af21e7fb">lf_sched_get_ready_reaction</a> (<a class="el" href="structlf__scheduler__t.html">lf_scheduler_t</a> *scheduler, int worker_number)</td></tr>
<tr class="memdesc:ga95107b668caa59d5bca9fff1af21e7fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the scheduler for one more reaction.  <br /></td></tr>
<tr class="memitem:ga0ebe8d7670a73a6572c7152d31e1fb62" id="r_ga0ebe8d7670a73a6572c7152d31e1fb62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0ebe8d7670a73a6572c7152d31e1fb62">lf_sched_init</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env, size_t number_of_workers, <a class="el" href="structsched__params__t.html">sched_params_t</a> *parameters)</td></tr>
<tr class="memdesc:ga0ebe8d7670a73a6572c7152d31e1fb62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the scheduler.  <br /></td></tr>
<tr class="memitem:ga28927b8a184fe101ad414ed866c49148" id="r_ga28927b8a184fe101ad414ed866c49148"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ga3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga28927b8a184fe101ad414ed866c49148">lf_schedule_trigger</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env, <a class="el" href="structtrigger__t.html">trigger_t</a> *trigger, <a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> delay, <a class="el" href="structlf__token__t.html">lf_token_t</a> *token)</td></tr>
<tr class="memdesc:ga28927b8a184fe101ad414ed866c49148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule the specified trigger to execute in the specified environment with given delay and token.  <br /></td></tr>
<tr class="memitem:gae47f6c04336244e4739c05f5c38e730e" id="r_gae47f6c04336244e4739c05f5c38e730e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae47f6c04336244e4739c05f5c38e730e">lf_scheduler_trigger_reaction</a> (<a class="el" href="structlf__scheduler__t.html">lf_scheduler_t</a> *scheduler, <a class="el" href="structreaction__t.html">reaction_t</a> *reaction, int worker_number)</td></tr>
<tr class="memdesc:gae47f6c04336244e4739c05f5c38e730e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inform the scheduler that worker thread 'worker_number' would like to trigger 'reaction' at the current tag.  <br /></td></tr>
<tr class="memitem:ga7bafb933f1e301b37b5d5164229f386d" id="r_ga7bafb933f1e301b37b5d5164229f386d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7bafb933f1e301b37b5d5164229f386d">lf_semaphore_acquire</a> (<a class="el" href="structlf__semaphore__t.html">lf_semaphore_t</a> *semaphore)</td></tr>
<tr class="memdesc:ga7bafb933f1e301b37b5d5164229f386d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire the 'semaphore'.  <br /></td></tr>
<tr class="memitem:ga1207a7db6221cb49ccf260c31e57a5ac" id="r_ga1207a7db6221cb49ccf260c31e57a5ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1207a7db6221cb49ccf260c31e57a5ac">lf_semaphore_destroy</a> (<a class="el" href="structlf__semaphore__t.html">lf_semaphore_t</a> *semaphore)</td></tr>
<tr class="memdesc:ga1207a7db6221cb49ccf260c31e57a5ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the 'semaphore'.  <br /></td></tr>
<tr class="memitem:ga4f13b40eede6275ac98d4ea1e2802e00" id="r_ga4f13b40eede6275ac98d4ea1e2802e00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlf__semaphore__t.html">lf_semaphore_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4f13b40eede6275ac98d4ea1e2802e00">lf_semaphore_new</a> (size_t count)</td></tr>
<tr class="memdesc:ga4f13b40eede6275ac98d4ea1e2802e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new semaphore.  <br /></td></tr>
<tr class="memitem:gae924daa1634a8e574b5b8966d54158dd" id="r_gae924daa1634a8e574b5b8966d54158dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae924daa1634a8e574b5b8966d54158dd">lf_semaphore_release</a> (<a class="el" href="structlf__semaphore__t.html">lf_semaphore_t</a> *semaphore, size_t i)</td></tr>
<tr class="memdesc:gae924daa1634a8e574b5b8966d54158dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the 'semaphore' and add 'i' to its count.  <br /></td></tr>
<tr class="memitem:ga2e816883471b300567e207c16471502e" id="r_ga2e816883471b300567e207c16471502e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2e816883471b300567e207c16471502e">lf_semaphore_wait</a> (<a class="el" href="structlf__semaphore__t.html">lf_semaphore_t</a> *semaphore)</td></tr>
<tr class="memdesc:ga2e816883471b300567e207c16471502e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait on the 'semaphore' if count is 0.  <br /></td></tr>
<tr class="memitem:ga2dce2075be67995107b9d8f2d5e20551" id="r_ga2dce2075be67995107b9d8f2d5e20551"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2dce2075be67995107b9d8f2d5e20551">lf_set_default_command_line_options</a> (void)</td></tr>
<tr class="memdesc:ga2dce2075be67995107b9d8f2d5e20551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generated function that optionally sets default command-line options.  <br /></td></tr>
<tr class="memitem:ga07b2e94bcac5d7bcfd47d4eaf35a4977" id="r_ga07b2e94bcac5d7bcfd47d4eaf35a4977"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga07b2e94bcac5d7bcfd47d4eaf35a4977">lf_set_stop_tag</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env, <a class="el" href="structtag__t.html">tag_t</a> tag)</td></tr>
<tr class="memdesc:ga07b2e94bcac5d7bcfd47d4eaf35a4977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stop tag if it is less than the stop tag of the specified environment.  <br /></td></tr>
<tr class="memitem:ga1e92870e0258c83da4c541e4ec48169b" id="r_ga1e92870e0258c83da4c541e4ec48169b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1e92870e0258c83da4c541e4ec48169b">lf_tag_latest_earlier</a> (<a class="el" href="structtag__t.html">tag_t</a> tag)</td></tr>
<tr class="memdesc:ga1e92870e0258c83da4c541e4ec48169b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greatest tag earlier than the given tag.  <br /></td></tr>
<tr class="memitem:gad149603053631bf4d6236426ddae2bde" id="r_gad149603053631bf4d6236426ddae2bde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad149603053631bf4d6236426ddae2bde">lf_terminate_execution</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env)</td></tr>
<tr class="memdesc:gad149603053631bf4d6236426ddae2bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that is called when the program is about to exit.  <br /></td></tr>
<tr class="memitem:ga751c9fce12510f5bb98d862f57077396" id="r_ga751c9fce12510f5bb98d862f57077396"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga751c9fce12510f5bb98d862f57077396">lf_time_logical</a> (void *env)</td></tr>
<tr class="memdesc:ga751c9fce12510f5bb98d862f57077396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current logical time in nanoseconds.  <br /></td></tr>
<tr class="memitem:ga6faad0d905f7135352f511bc235425e1" id="r_ga6faad0d905f7135352f511bc235425e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6faad0d905f7135352f511bc235425e1">lf_time_logical_elapsed</a> (void *env)</td></tr>
<tr class="memdesc:ga6faad0d905f7135352f511bc235425e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elapsed logical time in nanoseconds since the start of execution.  <br /></td></tr>
<tr class="memitem:ga5a16cb75bd134d91bbb002b5d1ddc45c" id="r_ga5a16cb75bd134d91bbb002b5d1ddc45c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5a16cb75bd134d91bbb002b5d1ddc45c">lf_tracing_check_version</a> ()</td></tr>
<tr class="memdesc:ga5a16cb75bd134d91bbb002b5d1ddc45c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the tracing library is compatible with the current version of the runtime.  <br /></td></tr>
<tr class="memitem:ga1b64e4e645fbebb1a3b132280b2c5b35" id="r_ga1b64e4e645fbebb1a3b132280b2c5b35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1b64e4e645fbebb1a3b132280b2c5b35">lf_vprint</a> (const char *format, va_list args) ATTRIBUTE_FORMAT_PRINTF(1</td></tr>
<tr class="memdesc:ga1b64e4e645fbebb1a3b132280b2c5b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">varargs alternative of "lf_print"  <br /></td></tr>
<tr class="memitem:ga334870b12bd4bc49b9da219e31225477" id="r_ga334870b12bd4bc49b9da219e31225477"><td class="memItemLeft" align="right" valign="top">void void void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga334870b12bd4bc49b9da219e31225477">lf_vprint_debug</a> (const char *format, va_list args) ATTRIBUTE_FORMAT_PRINTF(1</td></tr>
<tr class="memdesc:ga334870b12bd4bc49b9da219e31225477"><td class="mdescLeft">&#160;</td><td class="mdescRight">varargs alternative of "lf_print_debug"  <br /></td></tr>
<tr class="memitem:ga3d1b4e46f0394bbf2e74c4eabfd8923f" id="r_ga3d1b4e46f0394bbf2e74c4eabfd8923f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3d1b4e46f0394bbf2e74c4eabfd8923f">lf_vprint_error</a> (const char *format, va_list args) ATTRIBUTE_FORMAT_PRINTF(1</td></tr>
<tr class="memdesc:ga3d1b4e46f0394bbf2e74c4eabfd8923f"><td class="mdescLeft">&#160;</td><td class="mdescRight">varargs alternative of "lf_print_error"  <br /></td></tr>
<tr class="memitem:ga698eb7c2ecf514b4afa1ab7ab598eea2" id="r_ga698eb7c2ecf514b4afa1ab7ab598eea2"><td class="memItemLeft" align="right" valign="top">void void void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga698eb7c2ecf514b4afa1ab7ab598eea2">lf_vprint_error_and_exit</a> (const char *format, va_list args) ATTRIBUTE_FORMAT_PRINTF(1</td></tr>
<tr class="memdesc:ga698eb7c2ecf514b4afa1ab7ab598eea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">varargs alternative of "lf_print_error_and_exit"  <br /></td></tr>
<tr class="memitem:ga8432a03751d354b69ffe2f5b8c664654" id="r_ga8432a03751d354b69ffe2f5b8c664654"><td class="memItemLeft" align="right" valign="top">void void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8432a03751d354b69ffe2f5b8c664654">lf_vprint_log</a> (const char *format, va_list args) ATTRIBUTE_FORMAT_PRINTF(1</td></tr>
<tr class="memdesc:ga8432a03751d354b69ffe2f5b8c664654"><td class="mdescLeft">&#160;</td><td class="mdescRight">varargs alternative of "lf_print_log"  <br /></td></tr>
<tr class="memitem:ga47f8c72c1407daae89508da09273d655" id="r_ga47f8c72c1407daae89508da09273d655"><td class="memItemLeft" align="right" valign="top">void void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga47f8c72c1407daae89508da09273d655">lf_vprint_warning</a> (const char *format, va_list args) ATTRIBUTE_FORMAT_PRINTF(1</td></tr>
<tr class="memdesc:ga47f8c72c1407daae89508da09273d655"><td class="mdescLeft">&#160;</td><td class="mdescRight">varargs alternative of "lf_print_warning"  <br /></td></tr>
<tr class="memitem:gad96dd94446ff66184dcf0f8f65cdb4f0" id="r_gad96dd94446ff66184dcf0f8f65cdb4f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad96dd94446ff66184dcf0f8f65cdb4f0">logical_tag_complete</a> (<a class="el" href="structtag__t.html">tag_t</a> tag_to_send)</td></tr>
<tr class="memdesc:gad96dd94446ff66184dcf0f8f65cdb4f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder for code-generated function that will, in a federated execution, be used to coordinate the advancement of tag.  <br /></td></tr>
<tr class="memitem:gaab4b6c3ec9d416bc0965f81ff9194736" id="r_gaab4b6c3ec9d416bc0965f81ff9194736"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaab4b6c3ec9d416bc0965f81ff9194736">mixed_radix_incr</a> (<a class="el" href="structmixed__radix__int__t.html">mixed_radix_int_t</a> *mixed)</td></tr>
<tr class="memdesc:gaab4b6c3ec9d416bc0965f81ff9194736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the mixed radix number by one according to the permutation matrix.  <br /></td></tr>
<tr class="memitem:ga9405e2b2a5f79663f57c7933a2cec2b8" id="r_ga9405e2b2a5f79663f57c7933a2cec2b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9405e2b2a5f79663f57c7933a2cec2b8">mixed_radix_parent</a> (<a class="el" href="structmixed__radix__int__t.html">mixed_radix_int_t</a> *mixed, int n)</td></tr>
<tr class="memdesc:ga9405e2b2a5f79663f57c7933a2cec2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the int value of a mixed-radix number after dropping the first n digits.  <br /></td></tr>
<tr class="memitem:ga0402727c71049a3b200c1f9fbfdfcb41" id="r_ga0402727c71049a3b200c1f9fbfdfcb41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0402727c71049a3b200c1f9fbfdfcb41">mixed_radix_to_int</a> (<a class="el" href="structmixed__radix__int__t.html">mixed_radix_int_t</a> *mixed)</td></tr>
<tr class="memdesc:ga0402727c71049a3b200c1f9fbfdfcb41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the int value of a mixed-radix number.  <br /></td></tr>
<tr class="memitem:gaa0f5e3d63138880461b1f04dc2d4f48a" id="r_gaa0f5e3d63138880461b1f04dc2d4f48a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa0f5e3d63138880461b1f04dc2d4f48a">pqueue_empty_into</a> (<a class="el" href="structpqueue__t.html">pqueue_t</a> **dest, <a class="el" href="structpqueue__t.html">pqueue_t</a> **src)</td></tr>
<tr class="memdesc:gaa0f5e3d63138880461b1f04dc2d4f48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty 'src' into 'dest'.  <br /></td></tr>
<tr class="memitem:ga9bb9cb0e5f41746db17b7581f5fe0559" id="r_ga9bb9cb0e5f41746db17b7581f5fe0559"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9bb9cb0e5f41746db17b7581f5fe0559">pqueue_find_equal_same_priority</a> (<a class="el" href="structpqueue__t.html">pqueue_t</a> *q, void *e)</td></tr>
<tr class="memdesc:ga9bb9cb0e5f41746db17b7581f5fe0559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an entry with the same priority (determined by <span class="tt">cmppri</span>) that matches the supplied entry (determined by <span class="tt">eqelem</span>) or <span class="tt">NULL</span> if there is no such entry.  <br /></td></tr>
<tr class="memitem:ga23a8f91001427f237232082b8d25e81a" id="r_ga23a8f91001427f237232082b8d25e81a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga23a8f91001427f237232082b8d25e81a">pqueue_find_same_priority</a> (<a class="el" href="structpqueue__t.html">pqueue_t</a> *q, void *e)</td></tr>
<tr class="memdesc:ga23a8f91001427f237232082b8d25e81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an entry with the same priority as the specified entry or NULL if there is no such entry.  <br /></td></tr>
<tr class="memitem:gacceacc4429dd9cd31d5af09f3f473cb0" id="r_gacceacc4429dd9cd31d5af09f3f473cb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacceacc4429dd9cd31d5af09f3f473cb0">pqueue_free</a> (<a class="el" href="structpqueue__t.html">pqueue_t</a> *q)</td></tr>
<tr class="memdesc:gacceacc4429dd9cd31d5af09f3f473cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all memory used by the queue.  <br /></td></tr>
<tr class="memitem:ga5a4c8b51b16189ab4a687f562733b1a5" id="r_ga5a4c8b51b16189ab4a687f562733b1a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpqueue__t.html">pqueue_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5a4c8b51b16189ab4a687f562733b1a5">pqueue_init</a> (size_t n, <a class="el" href="#ga1c3f02694b2a0ec19584c395a88bb6f9">pqueue_cmp_pri_f</a> cmppri, <a class="el" href="#gaa84f0100faf971295df5aed226c390a6">pqueue_get_pri_f</a> getpri, <a class="el" href="#ga31ca7927983005bd7866021819ad7037">pqueue_get_pos_f</a> getpos, <a class="el" href="#gafdc8f52cbc45181ef375df22917bc4f9">pqueue_set_pos_f</a> setpos, <a class="el" href="#ga664f0abcd86c8089468869aa3dc6e535">pqueue_eq_elem_f</a> eqelem, <a class="el" href="#ga884902da135214a6167f1536ad4ed4bc">pqueue_print_entry_f</a> prt)</td></tr>
<tr class="memdesc:ga5a4c8b51b16189ab4a687f562733b1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a priority queue.  <br /></td></tr>
<tr class="memitem:gaddd8cdfbc8c47b8cdd7eb4c4560de7aa" id="r_gaddd8cdfbc8c47b8cdd7eb4c4560de7aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaddd8cdfbc8c47b8cdd7eb4c4560de7aa">pqueue_insert</a> (<a class="el" href="structpqueue__t.html">pqueue_t</a> *q, void *d)</td></tr>
<tr class="memdesc:gaddd8cdfbc8c47b8cdd7eb4c4560de7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element into the queue.  <br /></td></tr>
<tr class="memitem:ga9ec5c03203b587dbb92f8d2a977aa7e4" id="r_ga9ec5c03203b587dbb92f8d2a977aa7e4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9ec5c03203b587dbb92f8d2a977aa7e4">pqueue_peek</a> (<a class="el" href="structpqueue__t.html">pqueue_t</a> *q)</td></tr>
<tr class="memdesc:ga9ec5c03203b587dbb92f8d2a977aa7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access highest-ranking item without removing it.  <br /></td></tr>
<tr class="memitem:ga66bce8cd2c2afa804405005798498823" id="r_ga66bce8cd2c2afa804405005798498823"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga66bce8cd2c2afa804405005798498823">pqueue_pop</a> (<a class="el" href="structpqueue__t.html">pqueue_t</a> *q)</td></tr>
<tr class="memdesc:ga66bce8cd2c2afa804405005798498823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the highest-ranking item from the queue.  <br /></td></tr>
<tr class="memitem:ga1bc71ac57e101d48d91c75ecbf8fc278" id="r_ga1bc71ac57e101d48d91c75ecbf8fc278"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1bc71ac57e101d48d91c75ecbf8fc278">pqueue_print</a> (<a class="el" href="structpqueue__t.html">pqueue_t</a> *q, <a class="el" href="#ga884902da135214a6167f1536ad4ed4bc">pqueue_print_entry_f</a> print)</td></tr>
<tr class="memdesc:ga1bc71ac57e101d48d91c75ecbf8fc278"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the contents of the queue.  <br /></td></tr>
<tr class="memitem:ga921be3b49e4021888c595188438fdf7a" id="r_ga921be3b49e4021888c595188438fdf7a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga921be3b49e4021888c595188438fdf7a">pqueue_remove</a> (<a class="el" href="structpqueue__t.html">pqueue_t</a> *q, void *e)</td></tr>
<tr class="memdesc:ga921be3b49e4021888c595188438fdf7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an item from the queue.  <br /></td></tr>
<tr class="memitem:gae0cf88c8360a5f08ada81feaaeb40505" id="r_gae0cf88c8360a5f08ada81feaaeb40505"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae0cf88c8360a5f08ada81feaaeb40505">pqueue_size</a> (<a class="el" href="structpqueue__t.html">pqueue_t</a> *q)</td></tr>
<tr class="memdesc:gae0cf88c8360a5f08ada81feaaeb40505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the queue.  <br /></td></tr>
<tr class="memitem:gac6870c37fb36dcb65dbfcceff317cab4" id="r_gac6870c37fb36dcb65dbfcceff317cab4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac6870c37fb36dcb65dbfcceff317cab4">pqueue_tag_compare</a> (<a class="el" href="#gad8239ddc32134716f57e54bb972f6bf0">pqueue_pri_t</a> priority1, <a class="el" href="#gad8239ddc32134716f57e54bb972f6bf0">pqueue_pri_t</a> priority2)</td></tr>
<tr class="memdesc:gac6870c37fb36dcb65dbfcceff317cab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback comparison function for the tag-based priority queue.  <br /></td></tr>
<tr class="memitem:gafe428033cb2f6915828e75efb90edc44" id="r_gafe428033cb2f6915828e75efb90edc44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpqueue__tag__element__t.html">pqueue_tag_element_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafe428033cb2f6915828e75efb90edc44">pqueue_tag_find_equal_same_tag</a> (<a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *q, <a class="el" href="structpqueue__tag__element__t.html">pqueue_tag_element_t</a> *e)</td></tr>
<tr class="memdesc:gafe428033cb2f6915828e75efb90edc44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an item with the same tag (<span class="tt">cmppri</span> returns 0) that matches the supplied element (<span class="tt">eqelem</span> returns non-zero) or NULL if there is none.  <br /></td></tr>
<tr class="memitem:ga91d0568eb488ec1255fc1146163934fa" id="r_ga91d0568eb488ec1255fc1146163934fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpqueue__tag__element__t.html">pqueue_tag_element_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga91d0568eb488ec1255fc1146163934fa">pqueue_tag_find_with_tag</a> (<a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *q, <a class="el" href="structtag__t.html">tag_t</a> t)</td></tr>
<tr class="memdesc:ga91d0568eb488ec1255fc1146163934fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first item with the specified tag or NULL if there is none.  <br /></td></tr>
<tr class="memitem:ga7eee6edbbb90d5a0bb072a728dd3c7f2" id="r_ga7eee6edbbb90d5a0bb072a728dd3c7f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7eee6edbbb90d5a0bb072a728dd3c7f2">pqueue_tag_free</a> (<a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *q)</td></tr>
<tr class="memdesc:ga7eee6edbbb90d5a0bb072a728dd3c7f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free all memory used by the queue including elements that are marked dynamic.  <br /></td></tr>
<tr class="memitem:ga30b038fea77adb97ee6e0ab13af55ede" id="r_ga30b038fea77adb97ee6e0ab13af55ede"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga30b038fea77adb97ee6e0ab13af55ede">pqueue_tag_init</a> (size_t initial_size)</td></tr>
<tr class="memdesc:ga30b038fea77adb97ee6e0ab13af55ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a priority queue sorted by tags.  <br /></td></tr>
<tr class="memitem:ga7194e0ba9a3cd659f5e94f5a46c3d1f1" id="r_ga7194e0ba9a3cd659f5e94f5a46c3d1f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7194e0ba9a3cd659f5e94f5a46c3d1f1">pqueue_tag_init_customize</a> (size_t initial_size, <a class="el" href="#ga1c3f02694b2a0ec19584c395a88bb6f9">pqueue_cmp_pri_f</a> cmppri, <a class="el" href="#ga664f0abcd86c8089468869aa3dc6e535">pqueue_eq_elem_f</a> eqelem, <a class="el" href="#ga884902da135214a6167f1536ad4ed4bc">pqueue_print_entry_f</a> prt)</td></tr>
<tr class="memdesc:ga7194e0ba9a3cd659f5e94f5a46c3d1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a priority queue that stores elements with a particular payload.  <br /></td></tr>
<tr class="memitem:ga7db3de28c457287e689dedc3a6dc20da" id="r_ga7db3de28c457287e689dedc3a6dc20da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7db3de28c457287e689dedc3a6dc20da">pqueue_tag_insert</a> (<a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *q, <a class="el" href="structpqueue__tag__element__t.html">pqueue_tag_element_t</a> *d)</td></tr>
<tr class="memdesc:ga7db3de28c457287e689dedc3a6dc20da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an element into the queue.  <br /></td></tr>
<tr class="memitem:ga067e8fdd88be6f660e79744350a74128" id="r_ga067e8fdd88be6f660e79744350a74128"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga067e8fdd88be6f660e79744350a74128">pqueue_tag_insert_if_no_match</a> (<a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *q, <a class="el" href="structtag__t.html">tag_t</a> t)</td></tr>
<tr class="memdesc:ga067e8fdd88be6f660e79744350a74128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a tag into the queue if the tag is not already in the queue.  <br /></td></tr>
<tr class="memitem:ga89084b69d8049630eebb8df759c666d0" id="r_ga89084b69d8049630eebb8df759c666d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga89084b69d8049630eebb8df759c666d0">pqueue_tag_insert_tag</a> (<a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *q, <a class="el" href="structtag__t.html">tag_t</a> t)</td></tr>
<tr class="memdesc:ga89084b69d8049630eebb8df759c666d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a tag into the queue.  <br /></td></tr>
<tr class="memitem:ga16cbdbb45d26bd5373e258de819cfdd3" id="r_ga16cbdbb45d26bd5373e258de819cfdd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpqueue__tag__element__t.html">pqueue_tag_element_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga16cbdbb45d26bd5373e258de819cfdd3">pqueue_tag_peek</a> (<a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *q)</td></tr>
<tr class="memdesc:ga16cbdbb45d26bd5373e258de819cfdd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return highest-ranking item (the one with the least tag) without removing it.  <br /></td></tr>
<tr class="memitem:ga9bcecb00b894ad00b07f84940fe7af95" id="r_ga9bcecb00b894ad00b07f84940fe7af95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9bcecb00b894ad00b07f84940fe7af95">pqueue_tag_peek_tag</a> (<a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *q)</td></tr>
<tr class="memdesc:ga9bcecb00b894ad00b07f84940fe7af95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the least tag in the queue or FOREVER if the queue is empty.  <br /></td></tr>
<tr class="memitem:gaf6709c3c3756e65205762a4cf33848be" id="r_gaf6709c3c3756e65205762a4cf33848be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpqueue__tag__element__t.html">pqueue_tag_element_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf6709c3c3756e65205762a4cf33848be">pqueue_tag_pop</a> (<a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *q)</td></tr>
<tr class="memdesc:gaf6709c3c3756e65205762a4cf33848be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the least-tag element from the queue.  <br /></td></tr>
<tr class="memitem:gaa2144411e9b6d74af078d51078526fe3" id="r_gaa2144411e9b6d74af078d51078526fe3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa2144411e9b6d74af078d51078526fe3">pqueue_tag_pop_tag</a> (<a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *q)</td></tr>
<tr class="memdesc:gaa2144411e9b6d74af078d51078526fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop the least-tag element from the queue and return its tag.  <br /></td></tr>
<tr class="memitem:gac5612f277391c7129183d2826021c3e3" id="r_gac5612f277391c7129183d2826021c3e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac5612f277391c7129183d2826021c3e3">pqueue_tag_remove</a> (<a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *q, <a class="el" href="structpqueue__tag__element__t.html">pqueue_tag_element_t</a> *e)</td></tr>
<tr class="memdesc:gac5612f277391c7129183d2826021c3e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an item from the queue.  <br /></td></tr>
<tr class="memitem:ga135a225e2361b815a415607bc1f71e3b" id="r_ga135a225e2361b815a415607bc1f71e3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga135a225e2361b815a415607bc1f71e3b">pqueue_tag_remove_up_to</a> (<a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *q, <a class="el" href="structtag__t.html">tag_t</a> t)</td></tr>
<tr class="memdesc:ga135a225e2361b815a415607bc1f71e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove items from the queue with tags up to and including the specified tag.  <br /></td></tr>
<tr class="memitem:ga0679a4db1f4d970d9f1048e253b79562" id="r_ga0679a4db1f4d970d9f1048e253b79562"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0679a4db1f4d970d9f1048e253b79562">pqueue_tag_size</a> (<a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *q)</td></tr>
<tr class="memdesc:ga0679a4db1f4d970d9f1048e253b79562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the queue.  <br /></td></tr>
<tr class="memitem:ga26e33f5180dc5951b3d26094959913b7" id="r_ga26e33f5180dc5951b3d26094959913b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga26e33f5180dc5951b3d26094959913b7">print_reaction</a> (void *reaction)</td></tr>
<tr class="memdesc:ga26e33f5180dc5951b3d26094959913b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print some information about the given reaction.  <br /></td></tr>
<tr class="memitem:ga80aaf4eeed3e2902f8fe9de80b45777d" id="r_ga80aaf4eeed3e2902f8fe9de80b45777d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga80aaf4eeed3e2902f8fe9de80b45777d">process_args</a> (int argc, const char *argv[])</td></tr>
<tr class="memdesc:ga80aaf4eeed3e2902f8fe9de80b45777d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process the command-line arguments.  <br /></td></tr>
<tr class="memitem:ga648da83816bb67aedeeaa8c10a99ec7a" id="r_ga648da83816bb67aedeeaa8c10a99ec7a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga648da83816bb67aedeeaa8c10a99ec7a">reaction_matches</a> (void *a, void *b)</td></tr>
<tr class="memdesc:ga648da83816bb67aedeeaa8c10a99ec7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the two arguments are identical pointers.  <br /></td></tr>
<tr class="memitem:gaeaaa76aeb7d93efc4e0f0c484548af70" id="r_gaeaaa76aeb7d93efc4e0f0c484548af70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaeaaa76aeb7d93efc4e0f0c484548af70">schedule_output_reactions</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env, <a class="el" href="structreaction__t.html">reaction_t</a> *reaction, int worker)</td></tr>
<tr class="memdesc:gaeaaa76aeb7d93efc4e0f0c484548af70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule the output reactions for the specified reaction in the specified environment.  <br /></td></tr>
<tr class="memitem:ga6f9a4a14de3aa9e560935a57093eb122" id="r_ga6f9a4a14de3aa9e560935a57093eb122"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6f9a4a14de3aa9e560935a57093eb122">send_next_event_tag</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env, <a class="el" href="structtag__t.html">tag_t</a> tag, bool wait_for_reply)</td></tr>
<tr class="memdesc:ga6f9a4a14de3aa9e560935a57093eb122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send the next event tag.  <br /></td></tr>
<tr class="memitem:ga463f89e588c57a76b4cd6a0e633a94b4" id="r_ga463f89e588c57a76b4cd6a0e633a94b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga463f89e588c57a76b4cd6a0e633a94b4">set_reaction_position</a> (void *reaction, size_t pos)</td></tr>
<tr class="memdesc:ga463f89e588c57a76b4cd6a0e633a94b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the given reaction's position in the queue.  <br /></td></tr>
<tr class="memitem:ga5ee7c21a8b90bb09784f221c1de4d9c9" id="r_ga5ee7c21a8b90bb09784f221c1de4d9c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5ee7c21a8b90bb09784f221c1de4d9c9">should_stop_locked</a> (<a class="el" href="structlf__scheduler__t.html">lf_scheduler_t</a> *sched)</td></tr>
<tr class="memdesc:ga5ee7c21a8b90bb09784f221c1de4d9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the worker should stop now; false otherwise.  <br /></td></tr>
<tr class="memitem:gaa329f59a16f5617b5195f2c05872c9e9" id="r_gaa329f59a16f5617b5195f2c05872c9e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa329f59a16f5617b5195f2c05872c9e9">termination</a> (void)</td></tr>
<tr class="memdesc:gaa329f59a16f5617b5195f2c05872c9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform final wrap-up on exit.  <br /></td></tr>
<tr class="memitem:ga896f27619ab0582d5a70d8f613567671" id="r_ga896f27619ab0582d5a70d8f613567671"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga896f27619ab0582d5a70d8f613567671">tracepoint_schedule</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *env, <a class="el" href="structtrigger__t.html">trigger_t</a> *trigger, <a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> extra_delay)</td></tr>
<tr class="memdesc:ga896f27619ab0582d5a70d8f613567671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace a call to schedule.  <br /></td></tr>
<tr class="memitem:ga70c4ab92f00f9bcc31e4d696db1c0526" id="r_ga70c4ab92f00f9bcc31e4d696db1c0526"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga70c4ab92f00f9bcc31e4d696db1c0526">wait_until</a> (<a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a> wait_until_time, lf_cond_t *condition)</td></tr>
<tr class="memdesc:ga70c4ab92f00f9bcc31e4d696db1c0526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until physical time matches or exceeds the time of the specified tag.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaf4657205de7da8f0bf7b346985a983fc" id="r_gaf4657205de7da8f0bf7b346985a983fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf4657205de7da8f0bf7b346985a983fc">_lf_count_token_allocations</a></td></tr>
<tr class="memdesc:gaf4657205de7da8f0bf7b346985a983fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter used to issue a warning if memory is allocated for tokens and never freed.  <br /></td></tr>
<tr class="memitem:ga3c7bddddb86913975950acdcf8bfef2a" id="r_ga3c7bddddb86913975950acdcf8bfef2a"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3c7bddddb86913975950acdcf8bfef2a">_lf_my_fed_id</a></td></tr>
<tr class="memdesc:ga3c7bddddb86913975950acdcf8bfef2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ID of this federate.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<p>API mainly used internally, but occasionally useful for users. </p>
<p>These functions and types are not meant to be used directly by users, but are useful for developers. </p>
<a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="ga8d8698026252ae104cc2405d8bb13f0e" name="ga8d8698026252ae104cc2405d8bb13f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d8698026252ae104cc2405d8bb13f0e">&#9670;&#160;</a></span>CONCATENATE_THREE_STRINGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CONCATENATE_THREE_STRINGS</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>__string1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>__string2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>__string3</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/util.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">__string1 __string2 __string3</div>
</div><!-- fragment -->
<p>A handy macro that can concatenate three strings. </p>
<p>Useful in the LF_PRINT_DEBUG macro and lf_print_error functions that want to concatenate a "DEBUG: " or "ERROR: " to the beginning of the message and a new line format <br  />
 at the end. </p>

</div>
</div>
<a id="gafaff13b938d14da158c3fa1424358353" name="gafaff13b938d14da158c3fa1424358353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafaff13b938d14da158c3fa1424358353">&#9670;&#160;</a></span>GLOBAL_ENVIRONMENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GLOBAL_ENVIRONMENT&#160;&#160;&#160;NULL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="environment_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/environment.h</a>&gt;</code></p>

<p>The global environment. </p>
<p>Some operations are not specific to a particular scheduling enclave and therefore have no associated environment. When invoking a function such as lf_critical_section_enter, which requires an environment argument, it may be possible to pass this GLOBAL_ENVIRONMENT. For <a class="el" href="group__Platform.html#gae0fda178667bc6cd94890a13316c285c">lf_critical_section_enter</a>, for example, this may acquire a global mutex instead of a mutex specific to a particular scheduling enclave. Most functions that take environment arguments, however, cannot accept the GLOBAL_ENVIRONMENT argument, and passing it will result in an assertion violation. </p>

</div>
</div>
<a id="ga8ffb41cff660cdf632693c5bf5a17f52" name="ga8ffb41cff660cdf632693c5bf5a17f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ffb41cff660cdf632693c5bf5a17f52">&#9670;&#160;</a></span>LF_COND_BROADCAST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LF_COND_BROADCAST</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>cond</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/util.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="group__API.html#ga1c464cee8cabb65eebf454fc016d47b1">LF_ASSERTN</a>(<a class="code hl_function" href="group__Platform.html#ga9ed434626733537f71c9b85e981109c7">lf_cond_broadcast</a>(cond), <span class="stringliteral">&quot;Condition variable broadcast failed.&quot;</span>)</div>
<div class="ttc" id="agroup__API_html_ga1c464cee8cabb65eebf454fc016d47b1"><div class="ttname"><a href="group__API.html#ga1c464cee8cabb65eebf454fc016d47b1">LF_ASSERTN</a></div><div class="ttdeci">#define LF_ASSERTN(condition, format,...)</div><div class="ttdoc">Assert that a condition is false.</div><div class="ttdef"><b>Definition</b> logging_macros.h:124</div></div>
<div class="ttc" id="agroup__Platform_html_ga9ed434626733537f71c9b85e981109c7"><div class="ttname"><a href="group__Platform.html#ga9ed434626733537f71c9b85e981109c7">lf_cond_broadcast</a></div><div class="ttdeci">int lf_cond_broadcast(lf_cond_t *cond)</div><div class="ttdoc">Wake up all threads waiting for condition variable cond.</div></div>
</div><!-- fragment -->
<p>Broadcast a condition variable with error checking. </p>
<p>This is optimized away if the NDEBUG flag is defined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Pointer to the condition variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga47d73a5ec6fa7ebc7838312cb93c2bb8" name="ga47d73a5ec6fa7ebc7838312cb93c2bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47d73a5ec6fa7ebc7838312cb93c2bb8">&#9670;&#160;</a></span>LF_COND_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LF_COND_INIT</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>cond</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mutex</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/util.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="group__API.html#ga1c464cee8cabb65eebf454fc016d47b1">LF_ASSERTN</a>(<a class="code hl_function" href="group__Platform.html#gab32dc7869dd4cf48bda70663f2591ae1">lf_cond_init</a>(cond, mutex), <span class="stringliteral">&quot;Condition variable init failed.&quot;</span>)</div>
<div class="ttc" id="agroup__Platform_html_gab32dc7869dd4cf48bda70663f2591ae1"><div class="ttname"><a href="group__Platform.html#gab32dc7869dd4cf48bda70663f2591ae1">lf_cond_init</a></div><div class="ttdeci">int lf_cond_init(lf_cond_t *cond, lf_mutex_t *mutex)</div><div class="ttdoc">Initialize a conditional variable.</div></div>
</div><!-- fragment -->
<p>Initialize condition variable with error checking. </p>
<p>This is optimized away if the NDEBUG flag is defined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Pointer to the condition variable to initialize. </td></tr>
    <tr><td class="paramname">mutex</td><td>Pointer to the mutex to associate with the condition variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabd8bd827c1d0d4b9f108da9098e10e51" name="gabd8bd827c1d0d4b9f108da9098e10e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd8bd827c1d0d4b9f108da9098e10e51">&#9670;&#160;</a></span>LF_COND_SIGNAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LF_COND_SIGNAL</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>cond</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/util.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="group__API.html#ga1c464cee8cabb65eebf454fc016d47b1">LF_ASSERTN</a>(<a class="code hl_function" href="group__Platform.html#ga7267ad6679b93c9a9f321cdf864e0092">lf_cond_signal</a>(cond), <span class="stringliteral">&quot;Condition variable signal failed.&quot;</span>)</div>
<div class="ttc" id="agroup__Platform_html_ga7267ad6679b93c9a9f321cdf864e0092"><div class="ttname"><a href="group__Platform.html#ga7267ad6679b93c9a9f321cdf864e0092">lf_cond_signal</a></div><div class="ttdeci">int lf_cond_signal(lf_cond_t *cond)</div><div class="ttdoc">Wake up one thread waiting for condition variable cond.</div></div>
</div><!-- fragment -->
<p>Signal a condition variable with error checking. </p>
<p>This is optimized away if the NDEBUG flag is defined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Pointer to the condition variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8b24bfd4605a8726dbfc2cee30c27e08" name="ga8b24bfd4605a8726dbfc2cee30c27e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b24bfd4605a8726dbfc2cee30c27e08">&#9670;&#160;</a></span>LF_COND_WAIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LF_COND_WAIT</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>cond</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/util.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="group__API.html#ga1c464cee8cabb65eebf454fc016d47b1">LF_ASSERTN</a>(<a class="code hl_function" href="group__Platform.html#gaba6871b2088bcd86f973e0299cdd4ff8">lf_cond_wait</a>(cond), <span class="stringliteral">&quot;Condition variable wait failed.&quot;</span>)</div>
<div class="ttc" id="agroup__Platform_html_gaba6871b2088bcd86f973e0299cdd4ff8"><div class="ttname"><a href="group__Platform.html#gaba6871b2088bcd86f973e0299cdd4ff8">lf_cond_wait</a></div><div class="ttdeci">int lf_cond_wait(lf_cond_t *cond)</div><div class="ttdoc">Wait for condition variable &quot;cond&quot; to be signaled or broadcast.</div></div>
</div><!-- fragment -->
<p>Wait on a condition variable with error checking. </p>
<p>This is optimized away if the NDEBUG flag is defined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Pointer to the condition variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga912847660fb8b04317fc270125d6b1f3" name="ga912847660fb8b04317fc270125d6b1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga912847660fb8b04317fc270125d6b1f3">&#9670;&#160;</a></span>LF_CRITICAL_SECTION_ENTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LF_CRITICAL_SECTION_ENTER</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/util.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="group__API.html#ga26ab6a0fd21cdcff11a5557406536bf1">LF_ASSERT</a>(!<a class="code hl_function" href="group__Platform.html#gae0fda178667bc6cd94890a13316c285c">lf_critical_section_enter</a>(env), <span class="stringliteral">&quot;Could not enter critical section&quot;</span>)</div>
<div class="ttc" id="agroup__API_html_ga26ab6a0fd21cdcff11a5557406536bf1"><div class="ttname"><a href="group__API.html#ga26ab6a0fd21cdcff11a5557406536bf1">LF_ASSERT</a></div><div class="ttdeci">#define LF_ASSERT(condition, format,...)</div><div class="ttdoc">Assert that a condition is true.</div><div class="ttdef"><b>Definition</b> logging_macros.h:101</div></div>
<div class="ttc" id="agroup__Platform_html_gae0fda178667bc6cd94890a13316c285c"><div class="ttname"><a href="group__Platform.html#gae0fda178667bc6cd94890a13316c285c">lf_critical_section_enter</a></div><div class="ttdeci">int lf_critical_section_enter(environment_t *env)</div><div class="ttdoc">Enter critical section within an environment.</div></div>
</div><!-- fragment -->
<p>Enter critical section with error checking. </p>
<p>This is optimized away if the NDEBUG flag is defined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>Pointer to the environment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga687e881099481d8efe446ad8a17d72e5" name="ga687e881099481d8efe446ad8a17d72e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga687e881099481d8efe446ad8a17d72e5">&#9670;&#160;</a></span>LF_CRITICAL_SECTION_EXIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LF_CRITICAL_SECTION_EXIT</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/util.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="group__API.html#ga26ab6a0fd21cdcff11a5557406536bf1">LF_ASSERT</a>(!<a class="code hl_function" href="group__Platform.html#gaed2c25495b50b46780c6288e4370541e">lf_critical_section_exit</a>(env), <span class="stringliteral">&quot;Could not exit critical section&quot;</span>)</div>
<div class="ttc" id="agroup__Platform_html_gaed2c25495b50b46780c6288e4370541e"><div class="ttname"><a href="group__Platform.html#gaed2c25495b50b46780c6288e4370541e">lf_critical_section_exit</a></div><div class="ttdeci">int lf_critical_section_exit(environment_t *env)</div><div class="ttdoc">Leave a critical section within an environment.</div></div>
</div><!-- fragment -->
<p>Exit critical section with error checking. </p>
<p>This is optimized away if the NDEBUG flag is defined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>Pointer to the environment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad5a08658dc3e13eab4cddafd94734794" name="gad5a08658dc3e13eab4cddafd94734794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5a08658dc3e13eab4cddafd94734794">&#9670;&#160;</a></span>LF_LEVEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LF_LEVEL</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/util.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">(index &amp; 0xffffLL)</div>
</div><!-- fragment -->
<p>Macro for extracting the level from the index of a reaction. </p>
<p>A reaction that has no upstream reactions has level 0. Other reactions have a level that is the length of the longest upstream chain to a reaction with level 0 (inclusive). This is used, along with the deadline, to sort reactions in the reaction queue. It ensures that reactions that are upstream in the dependence graph execute before reactions that are downstream. </p>

</div>
</div>
<a id="gaac9240f79bd758e00ed7bbf75dafc4fa" name="gaac9240f79bd758e00ed7bbf75dafc4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac9240f79bd758e00ed7bbf75dafc4fa">&#9670;&#160;</a></span>LF_MAX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LF_MAX</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>Y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/util.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">(((X) &gt; (Y)) ? (X) : (Y))</div>
</div><!-- fragment -->
<p>Utility for finding the maximum of two values. </p>

</div>
</div>
<a id="ga4359466e7fdb68dcf8116c469946cd92" name="ga4359466e7fdb68dcf8116c469946cd92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4359466e7fdb68dcf8116c469946cd92">&#9670;&#160;</a></span>LF_MIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LF_MIN</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>X</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>Y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/util.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">(((X) &lt; (Y)) ? (X) : (Y))</div>
</div><!-- fragment -->
<p>Utility for finding the minimum of two values. </p>

</div>
</div>
<a id="gadab0b8f13f8462ec0eddc7257ddb5394" name="gadab0b8f13f8462ec0eddc7257ddb5394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadab0b8f13f8462ec0eddc7257ddb5394">&#9670;&#160;</a></span>LF_MUTEX_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LF_MUTEX_INIT</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mutex</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/util.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="group__API.html#ga1c464cee8cabb65eebf454fc016d47b1">LF_ASSERTN</a>(<a class="code hl_function" href="group__Platform.html#gaa6f228487e6af38e496882f406aafaf6">lf_mutex_init</a>(mutex), <span class="stringliteral">&quot;Mutex init failed.&quot;</span>)</div>
<div class="ttc" id="agroup__Platform_html_gaa6f228487e6af38e496882f406aafaf6"><div class="ttname"><a href="group__Platform.html#gaa6f228487e6af38e496882f406aafaf6">lf_mutex_init</a></div><div class="ttdeci">int lf_mutex_init(lf_mutex_t *mutex)</div><div class="ttdoc">Initialize a mutex.</div></div>
</div><!-- fragment -->
<p>Initialize mutex with error checking. </p>
<p>This is optimized away if the NDEBUG flag is defined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>Pointer to the mutex to initialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab907d4c8d53c26fdbcbaa8d02e6a8810" name="gab907d4c8d53c26fdbcbaa8d02e6a8810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab907d4c8d53c26fdbcbaa8d02e6a8810">&#9670;&#160;</a></span>LF_MUTEX_LOCK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LF_MUTEX_LOCK</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mutex</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/util.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="group__API.html#ga1c464cee8cabb65eebf454fc016d47b1">LF_ASSERTN</a>(<a class="code hl_function" href="group__Platform.html#gac4c0721974b31d98f491be1febeb2c9a">lf_mutex_lock</a>(mutex), <span class="stringliteral">&quot;Mutex lock failed.&quot;</span>)</div>
<div class="ttc" id="agroup__Platform_html_gac4c0721974b31d98f491be1febeb2c9a"><div class="ttname"><a href="group__Platform.html#gac4c0721974b31d98f491be1febeb2c9a">lf_mutex_lock</a></div><div class="ttdeci">int lf_mutex_lock(lf_mutex_t *mutex)</div><div class="ttdoc">Lock the specified mutex.</div></div>
</div><!-- fragment -->
<p>Lock mutex with error checking. </p>
<p>This is optimized away if the NDEBUG flag is defined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>Pointer to the mutex to lock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2bb9c8d2b589a6eb4f72f6750a1133fc" name="ga2bb9c8d2b589a6eb4f72f6750a1133fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bb9c8d2b589a6eb4f72f6750a1133fc">&#9670;&#160;</a></span>LF_MUTEX_UNLOCK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LF_MUTEX_UNLOCK</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>mutex</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/util.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line"><a class="code hl_define" href="group__API.html#ga1c464cee8cabb65eebf454fc016d47b1">LF_ASSERTN</a>(<a class="code hl_function" href="group__Platform.html#ga01c4d5070c8402d4713a3fcab5a46a9f">lf_mutex_unlock</a>(mutex), <span class="stringliteral">&quot;Mutex unlock failed.&quot;</span>)</div>
<div class="ttc" id="agroup__Platform_html_ga01c4d5070c8402d4713a3fcab5a46a9f"><div class="ttname"><a href="group__Platform.html#ga01c4d5070c8402d4713a3fcab5a46a9f">lf_mutex_unlock</a></div><div class="ttdeci">int lf_mutex_unlock(lf_mutex_t *mutex)</div><div class="ttdoc">Unlock the specified mutex.</div></div>
</div><!-- fragment -->
<p>Unlock mutex with error checking. </p>
<p>This is optimized away if the NDEBUG flag is defined. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>Pointer to the mutex to unlock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3b755b6f58cb9ea64ae2f1ba9a382c86" name="ga3b755b6f58cb9ea64ae2f1ba9a382c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b755b6f58cb9ea64ae2f1ba9a382c86">&#9670;&#160;</a></span>MIN_SLEEP_DURATION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIN_SLEEP_DURATION&#160;&#160;&#160;<a class="el" href="group__Constants.html#gaa2aeaab0c2033d1db412c8021bff93fc">USEC</a>(10)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Constant giving the minimum amount of time to sleep to wait for physical time to reach a logical time. </p>
<p>Unless the "fast" option is given, an LF program will wait until physical time matches logical time before handling an event with a given logical time. The amount of time is less than this given threshold, then no wait will occur. The purpose of this is to prevent unnecessary delays caused by simply setting up and performing the wait. </p>

</div>
</div>
<a id="ga7516169f705d99222725e6970f0ec703" name="ga7516169f705d99222725e6970f0ec703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7516169f705d99222725e6970f0ec703">&#9670;&#160;</a></span>SCHED_ADAPTIVE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCHED_ADAPTIVE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__types_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_types.h</a>&gt;</code></p>

<p>Experimental adaptive scheduler. </p>

</div>
</div>
<a id="ga0238f536f81a61c0d568b36eac9b9a00" name="ga0238f536f81a61c0d568b36eac9b9a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0238f536f81a61c0d568b36eac9b9a00">&#9670;&#160;</a></span>SCHED_GEDF_NP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCHED_GEDF_NP&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__types_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_types.h</a>&gt;</code></p>

<p>Experimental GEDF-NP scheduler. </p>

</div>
</div>
<a id="gacc410134875d15b02634fb0aa8163a00" name="gacc410134875d15b02634fb0aa8163a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc410134875d15b02634fb0aa8163a00">&#9670;&#160;</a></span>SCHED_NP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SCHED_NP&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__types_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_types.h</a>&gt;</code></p>

<p>Default non-preemptive scheduler. </p>

</div>
</div>
<a id="gaaf1dece34c4fcc135c2bd4feaf44e095" name="gaaf1dece34c4fcc135c2bd4feaf44e095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf1dece34c4fcc135c2bd4feaf44e095">&#9670;&#160;</a></span>tracepoint_reaction_deadline_missed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tracepoint_reaction_deadline_missed</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>reaction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>worker</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tracepoint_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/tracepoint.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">  <a class="code hl_function" href="#gad0ae74c1c8d1935b3fb92e546988503c">call_tracepoint</a>(<a class="code hl_enumvalue" href="group__Tracing.html#ggab02e9e69539d60297cedb38c2193a453a8dd4df4dfbe3f6fd12f454467d61cda0">reaction_deadline_missed</a>, reaction-&gt;self, env-&gt;current_tag, worker, worker, reaction-&gt;number, NULL,  \</div>
<div class="line">                  NULL, 0)</div>
<div class="ttc" id="agroup__Internal_html_gad0ae74c1c8d1935b3fb92e546988503c"><div class="ttname"><a href="#gad0ae74c1c8d1935b3fb92e546988503c">call_tracepoint</a></div><div class="ttdeci">void call_tracepoint(int event_type, void *reactor, tag_t tag, int worker, int src_id, int dst_id, instant_t *physical_time, trigger_t *trigger, interval_t extra_delay)</div><div class="ttdoc">Pass the provided info to the tracing module.</div></div>
<div class="ttc" id="agroup__Tracing_html_ggab02e9e69539d60297cedb38c2193a453a8dd4df4dfbe3f6fd12f454467d61cda0"><div class="ttname"><a href="group__Tracing.html#ggab02e9e69539d60297cedb38c2193a453a8dd4df4dfbe3f6fd12f454467d61cda0">reaction_deadline_missed</a></div><div class="ttdeci">@ reaction_deadline_missed</div><div class="ttdef"><b>Definition</b> trace_types.h:23</div></div>
</div><!-- fragment -->
<p>Trace the occurrence of a deadline miss. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment in which we are executing </td></tr>
    <tr><td class="paramname">reaction</td><td>Pointer to the <a class="el" href="structreaction__t.html" title="Reaction activation record to push onto the reaction queue.">reaction_t</a> struct for the reaction. </td></tr>
    <tr><td class="paramname">worker</td><td>The thread number of the worker thread or 0 for single-threaded execution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaebbdf64d4b017a879c69fcda11e74efe" name="gaebbdf64d4b017a879c69fcda11e74efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebbdf64d4b017a879c69fcda11e74efe">&#9670;&#160;</a></span>tracepoint_reaction_ends</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tracepoint_reaction_ends</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>reaction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>worker</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tracepoint_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/tracepoint.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">  <a class="code hl_function" href="#gad0ae74c1c8d1935b3fb92e546988503c">call_tracepoint</a>(<a class="code hl_enumvalue" href="group__Tracing.html#ggab02e9e69539d60297cedb38c2193a453a79889b5c51ccdf63962a8ec230ff3f6b">reaction_ends</a>, reaction-&gt;self, env-&gt;current_tag, worker, worker, reaction-&gt;number, NULL, NULL,       \</div>
<div class="line">                  reaction-&gt;deadline)</div>
<div class="ttc" id="agroup__Tracing_html_ggab02e9e69539d60297cedb38c2193a453a79889b5c51ccdf63962a8ec230ff3f6b"><div class="ttname"><a href="group__Tracing.html#ggab02e9e69539d60297cedb38c2193a453a79889b5c51ccdf63962a8ec230ff3f6b">reaction_ends</a></div><div class="ttdeci">@ reaction_ends</div><div class="ttdef"><b>Definition</b> trace_types.h:22</div></div>
</div><!-- fragment -->
<p>Trace the end of a reaction execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment in which we are executing </td></tr>
    <tr><td class="paramname">reaction</td><td>Pointer to the <a class="el" href="structreaction__t.html" title="Reaction activation record to push onto the reaction queue.">reaction_t</a> struct for the reaction. </td></tr>
    <tr><td class="paramname">worker</td><td>The thread number of the worker thread or 0 for single-threaded execution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8c90883c30c8d773cde2df65f9f95e59" name="ga8c90883c30c8d773cde2df65f9f95e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c90883c30c8d773cde2df65f9f95e59">&#9670;&#160;</a></span>tracepoint_reaction_starts</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tracepoint_reaction_starts</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>reaction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>worker</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tracepoint_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/tracepoint.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">  <a class="code hl_function" href="#gad0ae74c1c8d1935b3fb92e546988503c">call_tracepoint</a>(<a class="code hl_enumvalue" href="group__Tracing.html#ggab02e9e69539d60297cedb38c2193a453a7ca2fc1a301d8e66944fab471646728a">reaction_starts</a>, reaction-&gt;self, env-&gt;current_tag, worker, worker, reaction-&gt;number, NULL, NULL,     \</div>
<div class="line">                  reaction-&gt;deadline)</div>
<div class="ttc" id="agroup__Tracing_html_ggab02e9e69539d60297cedb38c2193a453a7ca2fc1a301d8e66944fab471646728a"><div class="ttname"><a href="group__Tracing.html#ggab02e9e69539d60297cedb38c2193a453a7ca2fc1a301d8e66944fab471646728a">reaction_starts</a></div><div class="ttdeci">@ reaction_starts</div><div class="ttdef"><b>Definition</b> trace_types.h:21</div></div>
</div><!-- fragment -->
<p>Trace the start of a reaction execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment in which we are executing </td></tr>
    <tr><td class="paramname">reaction</td><td>Pointer to the <a class="el" href="structreaction__t.html" title="Reaction activation record to push onto the reaction queue.">reaction_t</a> struct for the reaction. </td></tr>
    <tr><td class="paramname">worker</td><td>The thread number of the worker thread or 0 for single-threaded execution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga77931b6e1d5a6c7f462902e78db801ba" name="ga77931b6e1d5a6c7f462902e78db801ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77931b6e1d5a6c7f462902e78db801ba">&#9670;&#160;</a></span>tracepoint_scheduler_advancing_time_ends</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tracepoint_scheduler_advancing_time_ends</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tracepoint_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/tracepoint.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">  <a class="code hl_function" href="#gad0ae74c1c8d1935b3fb92e546988503c">call_tracepoint</a>(<a class="code hl_enumvalue" href="group__Tracing.html#ggab02e9e69539d60297cedb38c2193a453a0422fad861a51f83258d104e6b34fdad">scheduler_advancing_time_ends</a>, NULL, env-&gt;current_tag, -1, -1, -1, NULL, NULL, 0)</div>
<div class="ttc" id="agroup__Tracing_html_ggab02e9e69539d60297cedb38c2193a453a0422fad861a51f83258d104e6b34fdad"><div class="ttname"><a href="group__Tracing.html#ggab02e9e69539d60297cedb38c2193a453a0422fad861a51f83258d104e6b34fdad">scheduler_advancing_time_ends</a></div><div class="ttdeci">@ scheduler_advancing_time_ends</div><div class="ttdef"><b>Definition</b> trace_types.h:30</div></div>
</div><!-- fragment -->
<p>Trace the end of the scheduler waiting for logical time to advance or an event to appear on the event queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment in which we are executing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga65f95d31a900f5cde73f152c36f116bf" name="ga65f95d31a900f5cde73f152c36f116bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65f95d31a900f5cde73f152c36f116bf">&#9670;&#160;</a></span>tracepoint_scheduler_advancing_time_starts</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tracepoint_scheduler_advancing_time_starts</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tracepoint_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/tracepoint.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">  <a class="code hl_function" href="#gad0ae74c1c8d1935b3fb92e546988503c">call_tracepoint</a>(<a class="code hl_enumvalue" href="group__Tracing.html#ggab02e9e69539d60297cedb38c2193a453a79e198f97731e9ea1f982ccb8db8f5d0">scheduler_advancing_time_starts</a>, NULL, env-&gt;current_tag, -1, -1, -1, NULL, NULL, 0);</div>
<div class="ttc" id="agroup__Tracing_html_ggab02e9e69539d60297cedb38c2193a453a79e198f97731e9ea1f982ccb8db8f5d0"><div class="ttname"><a href="group__Tracing.html#ggab02e9e69539d60297cedb38c2193a453a79e198f97731e9ea1f982ccb8db8f5d0">scheduler_advancing_time_starts</a></div><div class="ttdeci">@ scheduler_advancing_time_starts</div><div class="ttdef"><b>Definition</b> trace_types.h:29</div></div>
</div><!-- fragment -->
<p>Trace the start of the scheduler waiting for logical time to advance or an event to appear on the event queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment in which we are executing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4ea3c33342ac48ed332eb540a14ea53f" name="ga4ea3c33342ac48ed332eb540a14ea53f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ea3c33342ac48ed332eb540a14ea53f">&#9670;&#160;</a></span>tracepoint_worker_wait_ends</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tracepoint_worker_wait_ends</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>worker</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tracepoint_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/tracepoint.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">  <a class="code hl_function" href="#gad0ae74c1c8d1935b3fb92e546988503c">call_tracepoint</a>(<a class="code hl_enumvalue" href="group__Tracing.html#ggab02e9e69539d60297cedb38c2193a453afa179671ba1508f1c16b10ffef3a17c6">worker_wait_ends</a>, NULL, env-&gt;current_tag, worker, worker, -1, NULL, NULL, 0)</div>
<div class="ttc" id="agroup__Tracing_html_ggab02e9e69539d60297cedb38c2193a453afa179671ba1508f1c16b10ffef3a17c6"><div class="ttname"><a href="group__Tracing.html#ggab02e9e69539d60297cedb38c2193a453afa179671ba1508f1c16b10ffef3a17c6">worker_wait_ends</a></div><div class="ttdeci">@ worker_wait_ends</div><div class="ttdef"><b>Definition</b> trace_types.h:28</div></div>
</div><!-- fragment -->
<p>Trace the end of a worker waiting for something to change on the event or reaction queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment in which we are executing </td></tr>
    <tr><td class="paramname">worker</td><td>The thread number of the worker thread or 0 for single-threaded execution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5d07ee55d71cbd545ad4bb577c2dc6b9" name="ga5d07ee55d71cbd545ad4bb577c2dc6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d07ee55d71cbd545ad4bb577c2dc6b9">&#9670;&#160;</a></span>tracepoint_worker_wait_starts</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tracepoint_worker_wait_starts</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>worker</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tracepoint_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/tracepoint.h</a>&gt;</code></p>
<b>Value:</b><div class="fragment"><div class="line">  <a class="code hl_function" href="#gad0ae74c1c8d1935b3fb92e546988503c">call_tracepoint</a>(<a class="code hl_enumvalue" href="group__Tracing.html#ggab02e9e69539d60297cedb38c2193a453a9c6849445ded286ba9f914d3b1decd2a">worker_wait_starts</a>, NULL, env-&gt;current_tag, worker, worker, -1, NULL, NULL, 0)</div>
<div class="ttc" id="agroup__Tracing_html_ggab02e9e69539d60297cedb38c2193a453a9c6849445ded286ba9f914d3b1decd2a"><div class="ttname"><a href="group__Tracing.html#ggab02e9e69539d60297cedb38c2193a453a9c6849445ded286ba9f914d3b1decd2a">worker_wait_starts</a></div><div class="ttdeci">@ worker_wait_starts</div><div class="ttdef"><b>Definition</b> trace_types.h:27</div></div>
</div><!-- fragment -->
<p>Trace the start of a worker waiting for something to change on the reaction queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment in which we are executing </td></tr>
    <tr><td class="paramname">worker</td><td>The thread number of the worker thread or 0 for single-threaded execution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="ga416845ec4469b3186de047c32402f5e8" name="ga416845ec4469b3186de047c32402f5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga416845ec4469b3186de047c32402f5e8">&#9670;&#160;</a></span>allocation_record_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct allocation_record_t allocation_record_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__types_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_types.h</a>&gt;</code></p>

<p>Allocation record to keep track of dynamically-allocated memory. </p>
<p>An allocation record that is used by a destructor for a reactor to free memory that has been dynamically allocated for the particular instance of the reactor. This will be an element of linked list. The <span class="tt">allocated</span> pointer points to the allocated memory, and the <span class="tt">next</span> pointer points to the next allocation record (or NULL if there are no more). </p>

</div>
</div>
<a id="gaa47b54e9e041dfe1b75fffceb1051466" name="gaa47b54e9e041dfe1b75fffceb1051466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa47b54e9e041dfe1b75fffceb1051466">&#9670;&#160;</a></span>environment_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct environment_t environment_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="environment_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/environment.h</a>&gt;</code></p>

<p>Execution environment. </p>
<p>This struct contains information about the execution environment. An execution environment maintains a notion of a "current tag" and has its own event queue and scheduler. Normally, there is only one execution environment, but if you use scheduling enclaves, then there will be one for each enclave. </p>

</div>
</div>
<a id="ga59f5f6b9c6023baebf9c49c328b639a1" name="ga59f5f6b9c6023baebf9c49c328b639a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59f5f6b9c6023baebf9c49c328b639a1">&#9670;&#160;</a></span>event_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct event_t event_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__types_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_types.h</a>&gt;</code></p>

<p>Event activation record for storing event queue entries. </p>
<p>This type is used for storing activation records in the event queue. Each event represents a scheduled trigger with its associated data. </p>

</div>
</div>
<a id="ga4448d06be794d3f5412d0edb412dc00e" name="ga4448d06be794d3f5412d0edb412dc00e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4448d06be794d3f5412d0edb412dc00e">&#9670;&#160;</a></span>index_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="#gad8239ddc32134716f57e54bb972f6bf0">pqueue_pri_t</a> <a class="el" href="#ga4448d06be794d3f5412d0edb412dc00e">index_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__types_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_types.h</a>&gt;</code></p>

<p>Topological order index for reactions. </p>

</div>
</div>
<a id="ga91b17c088cd50ce69df73f1470a18799" name="ga91b17c088cd50ce69df73f1470a18799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91b17c088cd50ce69df73f1470a18799">&#9670;&#160;</a></span>lf_port_base_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct lf_port_base_t lf_port_base_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__token_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_token.h</a>&gt;</code></p>

<p>Base type for ports. </p>
<p>Port structs are customized types because their payloads are type specific. This struct represents their common features. Given any pointer to a port struct, it can be cast to <a class="el" href="structlf__port__base__t.html" title="Base type for ports.">lf_port_base_t</a> and then these common fields can be accessed.</p>
<p>IMPORTANT: If this is changed, it must also be changed in CPortGenerator.java generateAuxiliaryStruct(). </p>

</div>
</div>
<a id="ga0199f9b027e13cf08095d91fe798c663" name="ga0199f9b027e13cf08095d91fe798c663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0199f9b027e13cf08095d91fe798c663">&#9670;&#160;</a></span>lf_scheduler_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct lf_scheduler_t lf_scheduler_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="scheduler__instance_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/threaded/scheduler_instance.h</a>&gt;</code></p>

<p>Parameters used in schedulers of the threaded reactor C runtime. </p>
<dl class="section note"><dt>Note</dt><dd>Members of this struct are added based on existing schedulers' needs. These should be expanded to accommodate new schedulers. </dd></dl>

</div>
</div>
<a id="gaa6696d69bef6bb4bdd52ef9ab9d2c614" name="gaa6696d69bef6bb4bdd52ef9ab9d2c614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6696d69bef6bb4bdd52ef9ab9d2c614">&#9670;&#160;</a></span>lf_sparse_io_record_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct lf_sparse_io_record_t lf_sparse_io_record_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__token_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_token.h</a>&gt;</code></p>

<p>A record of the subset of channels of a multiport that have present inputs. </p>
<p>This struct is used to efficiently track which channels of a multiport have present inputs, particularly useful for sparse I/O operations where only a small subset of channels are active. </p>

</div>
</div>
<a id="ga18d624d162daca00e24d1d528ec3c18f" name="ga18d624d162daca00e24d1d528ec3c18f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18d624d162daca00e24d1d528ec3c18f">&#9670;&#160;</a></span>lf_tag_advancement_barrier_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct lf_tag_advancement_barrier_t lf_tag_advancement_barrier_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__types_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_types.h</a>&gt;</code></p>

<p>A struct representing a barrier in threaded LF programs. </p>
<p>This will prevent advancement of the current tag if the number of requestors is larger than 0 or the value of horizon is not (FOREVER, 0). </p>

</div>
</div>
<a id="ga7d95374fb5368705263c2f1ac2579183" name="ga7d95374fb5368705263c2f1ac2579183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d95374fb5368705263c2f1ac2579183">&#9670;&#160;</a></span>mixed_radix_int_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct mixed_radix_int_t mixed_radix_int_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mixed__radix_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/mixed_radix.h</a>&gt;</code></p>

<p>Representation of a permuted mixed radix integer. </p>
<p>The three arrays (digits, radixes, and permutation) are all assumed to have the same size as given by the size field. </p>

</div>
</div>
<a id="ga1c3f02694b2a0ec19584c395a88bb6f9" name="ga1c3f02694b2a0ec19584c395a88bb6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c3f02694b2a0ec19584c395a88bb6f9">&#9670;&#160;</a></span>pqueue_cmp_pri_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* pqueue_cmp_pri_f) (<a class="el" href="#gad8239ddc32134716f57e54bb972f6bf0">pqueue_pri_t</a> next, <a class="el" href="#gad8239ddc32134716f57e54bb972f6bf0">pqueue_pri_t</a> curr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__base_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_base.h</a>&gt;</code></p>

<p>Callback to compare two priorities. </p>

</div>
</div>
<a id="ga664f0abcd86c8089468869aa3dc6e535" name="ga664f0abcd86c8089468869aa3dc6e535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga664f0abcd86c8089468869aa3dc6e535">&#9670;&#160;</a></span>pqueue_eq_elem_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* pqueue_eq_elem_f) (void *next, void *curr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__base_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_base.h</a>&gt;</code></p>

<p>Callback to determine whether two elements are equivalent. </p>

</div>
</div>
<a id="ga31ca7927983005bd7866021819ad7037" name="ga31ca7927983005bd7866021819ad7037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31ca7927983005bd7866021819ad7037">&#9670;&#160;</a></span>pqueue_get_pos_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t(* pqueue_get_pos_f) (void *a)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__base_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_base.h</a>&gt;</code></p>

<p>Callback functions to get the position of an element. </p>

</div>
</div>
<a id="gaa84f0100faf971295df5aed226c390a6" name="gaa84f0100faf971295df5aed226c390a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa84f0100faf971295df5aed226c390a6">&#9670;&#160;</a></span>pqueue_get_pri_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="#gad8239ddc32134716f57e54bb972f6bf0">pqueue_pri_t</a>(* pqueue_get_pri_f) (void *a)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__base_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_base.h</a>&gt;</code></p>

<p>Callback to get the priority of an element. </p>

</div>
</div>
<a id="gad8239ddc32134716f57e54bb972f6bf0" name="gad8239ddc32134716f57e54bb972f6bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8239ddc32134716f57e54bb972f6bf0">&#9670;&#160;</a></span>pqueue_pri_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned long long <a class="el" href="#gad8239ddc32134716f57e54bb972f6bf0">pqueue_pri_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__base_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_base.h</a>&gt;</code></p>

<p>Priority data type. </p>

</div>
</div>
<a id="ga884902da135214a6167f1536ad4ed4bc" name="ga884902da135214a6167f1536ad4ed4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga884902da135214a6167f1536ad4ed4bc">&#9670;&#160;</a></span>pqueue_print_entry_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* pqueue_print_entry_f) (void *a)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__base_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_base.h</a>&gt;</code></p>

<p>Debug callback function to print a entry. </p>

</div>
</div>
<a id="gafdc8f52cbc45181ef375df22917bc4f9" name="gafdc8f52cbc45181ef375df22917bc4f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdc8f52cbc45181ef375df22917bc4f9">&#9670;&#160;</a></span>pqueue_set_pos_f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* pqueue_set_pos_f) (void *a, size_t pos)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__base_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_base.h</a>&gt;</code></p>

<p>Callback functions to set the position of an element. </p>

</div>
</div>
<a id="ga05e211b59fd9be5939218e11d1132167" name="ga05e211b59fd9be5939218e11d1132167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05e211b59fd9be5939218e11d1132167">&#9670;&#160;</a></span>pqueue_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct pqueue_t pqueue_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__base_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_base.h</a>&gt;</code></p>

<p>The priority queue struct. </p>

</div>
</div>
<a id="gac52d056c47d9595f94d37e95484b3acd" name="gac52d056c47d9595f94d37e95484b3acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac52d056c47d9595f94d37e95484b3acd">&#9670;&#160;</a></span>pqueue_tag_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structpqueue__t.html">pqueue_t</a> <a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__tag_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_tag.h</a>&gt;</code></p>

<p>Type of a priority queue sorted by tags. </p>

</div>
</div>
<a id="ga149e5fee1c1841bcc96c72f200601d90" name="ga149e5fee1c1841bcc96c72f200601d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga149e5fee1c1841bcc96c72f200601d90">&#9670;&#160;</a></span>reaction_function_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* reaction_function_t) (void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__types_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_types.h</a>&gt;</code></p>

<p>Reaction function type. </p>
<p>The argument passed to one of these reaction functions is a pointer to the self struct for the reactor. </p>

</div>
</div>
<a id="ga6202eb05c29c30bfd6a8fc203de6422f" name="ga6202eb05c29c30bfd6a8fc203de6422f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6202eb05c29c30bfd6a8fc203de6422f">&#9670;&#160;</a></span>self_base_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct self_base_t self_base_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__types_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_types.h</a>&gt;</code></p>

<p>The base type for all reactor self structs. </p>
<p>The first element of every self struct defined in generated code will be a pointer to an allocation record, which is either NULL or the head of a NULL-terminated linked list of allocation records. This list is used to free memory that has been dynamically allocated. This struct also provides a pointer to the currently executing reaction, to the environment in which the reaction is executing, and to the mutex that is used to protect the reactor. If modal models are being used, it also records the current mode. </p>

</div>
</div>
<a id="ga0cb4f0fedba2f1e1fd3893440ab53647" name="ga0cb4f0fedba2f1e1fd3893440ab53647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cb4f0fedba2f1e1fd3893440ab53647">&#9670;&#160;</a></span>token_freed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="#gabe23a36a87d2f0c076da417eb0114c7e">token_freed</a> <a class="el" href="#gabe23a36a87d2f0c076da417eb0114c7e">token_freed</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__token_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_token.h</a>&gt;</code></p>

<p>Possible return values for <a class="el" href="#ga88c890be1f8d45461a6985cbfe6faa99">_lf_done_using</a> and <a class="el" href="#ga2798a92c59a1d46b602298cdbd187ab1">_lf_free_token</a>. </p>

</div>
</div>
<a id="gad0befcbc6fe23c8dd0b6f483d4067e45" name="gad0befcbc6fe23c8dd0b6f483d4067e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0befcbc6fe23c8dd0b6f483d4067e45">&#9670;&#160;</a></span>token_template_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct token_template_t token_template_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__token_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_token.h</a>&gt;</code></p>

<p>Base type for ports (<a class="el" href="structlf__port__base__t.html" title="Base type for ports.">lf_port_base_t</a>) and actions (<a class="el" href="structtrigger__t.html" title="Trigger struct representing an output, timer, action, or input.">trigger_t</a>), which can carry tokens. </p>
<p>The structs <a class="el" href="structlf__port__base__t.html" title="Base type for ports.">lf_port_base_t</a> and <a class="el" href="structtrigger__t.html" title="Trigger struct representing an output, timer, action, or input.">trigger_t</a> should start with an instance of this struct so that they can be cast to this struct to access these fields in a uniform way. This template provides the common structure for handling tokens in both ports and actions, ensuring consistent token management across different types of connections. </p>

</div>
</div>
<a id="ga58dc2f4a624d2f3030b7e5f3596e58d6" name="ga58dc2f4a624d2f3030b7e5f3596e58d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58dc2f4a624d2f3030b7e5f3596e58d6">&#9670;&#160;</a></span>token_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct token_type_t token_type_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__token_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_token.h</a>&gt;</code></p>

<p>Type information for tokens. </p>
<p>Specifically, this struct contains the fields needed to support token types, which carry dynamically allocated data. </p>

</div>
</div>
<a id="ga7804d825257e1eb4296de7da8fec62f6" name="ga7804d825257e1eb4296de7da8fec62f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7804d825257e1eb4296de7da8fec62f6">&#9670;&#160;</a></span>trace_record_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef INTERNAL struct trace_record_t trace_record_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tracepoint_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/tracepoint.h</a>&gt;</code></p>

<p>A trace record that gets written in binary to the trace file in the default implementation. </p>

</div>
</div>
<a id="ga3608c2ed78ba97535f8d82a489846305" name="ga3608c2ed78ba97535f8d82a489846305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3608c2ed78ba97535f8d82a489846305">&#9670;&#160;</a></span>trigger_handle_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="#ga3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__types_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_types.h</a>&gt;</code></p>

<p>Handles for scheduled triggers. </p>
<p>These handles are returned by <a class="el" href="group__API.html#ga6778eef97447cf0ba1f0afa8ba3a8dca" title="Schedule an action to occur with the specified time offset with no payload (no value conveyed).">lf_schedule()</a> functions. The intent is that the handle can be used to cancel a future scheduled event, but this is not implemented yet. </p>

</div>
</div>
<a id="ga3fa7784c89589b49764048e9909d0e07" name="ga3fa7784c89589b49764048e9909d0e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fa7784c89589b49764048e9909d0e07">&#9670;&#160;</a></span>ushort</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned short int <a class="el" href="#ga3fa7784c89589b49764048e9909d0e07">ushort</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__types_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_types.h</a>&gt;</code></p>

<p>Unsigned short type. </p>
<p>Redefine here for portability if sys/types.h is not included.</p>
<dl class="section see"><dt>See also</dt><dd>sys/types.h</dd></dl>
<dl class="section note"><dt>Note</dt><dd>using sizeof(ushort) should be okay but not sizeof ushort. </dd></dl>

</div>
</div>
<a id="ga4caef7fcd0476a936700512d28a23aa8" name="ga4caef7fcd0476a936700512d28a23aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4caef7fcd0476a936700512d28a23aa8">&#9670;&#160;</a></span>watchdog_function_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* watchdog_function_t) (void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="watchdog_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/threaded/watchdog.h</a>&gt;</code></p>

<p>Watchdog function type. </p>
<p>The argument passed to one of these watchdog functions is a pointer to the self struct for the reactor. </p>

</div>
</div>
<a id="gaee1cd2bc521f76fa428cc659474d9570" name="gaee1cd2bc521f76fa428cc659474d9570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee1cd2bc521f76fa428cc659474d9570">&#9670;&#160;</a></span>watchdog_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct watchdog_t watchdog_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="watchdog_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/threaded/watchdog.h</a>&gt;</code></p>

<p>Typdef for <a class="el" href="structwatchdog__t.html" title="Typdef for watchdog_t struct, used to call watchdog handler.">watchdog_t</a> struct, used to call watchdog handler. </p>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="ga0183c0b43037a172a1cd9aa6ed6b3822" name="ga0183c0b43037a172a1cd9aa6ed6b3822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0183c0b43037a172a1cd9aa6ed6b3822">&#9670;&#160;</a></span>lf_spacing_policy_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga0183c0b43037a172a1cd9aa6ed6b3822">lf_spacing_policy_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__types_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_types.h</a>&gt;</code></p>

<p>Policy for handling scheduled events that violate the specified minimum interarrival time. </p>
<p>The default policy is <span class="tt">defer</span>: adjust the tag to that the minimum interarrival time is satisfied. The <span class="tt">drop</span> policy simply drops events that are scheduled too early. The <span class="tt">replace</span> policy will attempt to replace the payload of the preceding event. Unless the preceding event has already been handled, it gets assigned the value of the new event. If the preceding event has already been popped off the event queue, the <span class="tt">defer</span> policy is fallen back to. The <span class="tt">update</span> policy drops the preceding event, if it is still in the event queue, and updates it with the newly scheduled event. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga0183c0b43037a172a1cd9aa6ed6b3822a893b1cf0de04eaf44a009fecabd16b90" name="gga0183c0b43037a172a1cd9aa6ed6b3822a893b1cf0de04eaf44a009fecabd16b90"></a>defer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga0183c0b43037a172a1cd9aa6ed6b3822a1e34755950041e469ca91ff2b7d1c019" name="gga0183c0b43037a172a1cd9aa6ed6b3822a1e34755950041e469ca91ff2b7d1c019"></a>drop&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga0183c0b43037a172a1cd9aa6ed6b3822a8a4df390c6f816287b90cb2b33ab4323" name="gga0183c0b43037a172a1cd9aa6ed6b3822a8a4df390c6f816287b90cb2b33ab4323"></a>replace&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga0183c0b43037a172a1cd9aa6ed6b3822a15edc24cdf7dea17a43c6c50580eba2b" name="gga0183c0b43037a172a1cd9aa6ed6b3822a15edc24cdf7dea17a43c6c50580eba2b"></a>update&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ga759ba374f75ea0025b9af1bb35f14d7e" name="ga759ba374f75ea0025b9af1bb35f14d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga759ba374f75ea0025b9af1bb35f14d7e">&#9670;&#160;</a></span>port_status_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga759ba374f75ea0025b9af1bb35f14d7e">port_status_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__types_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_types.h</a>&gt;</code></p>

<p>Status of a given port at a given logical time. </p>
<p>If the value is 'present', it is an indicator that the port is present at the given logical time. If the value is 'absent', it is an indicator that the port is absent at the given logical time. If the value is 'unknown', it is unknown whether the port is present or absent (e.g., in a distributed application).</p>
<dl class="section note"><dt>Note</dt><dd>For non-network ports, unknown is unused. </dd>
<dd>
The absent and present fields need to be compatible with false and true respectively because for non-network ports, the status can either be present or absent (no possibility of unknown). </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga759ba374f75ea0025b9af1bb35f14d7ea1a8fae68a24a59c5629c241401fabb08" name="gga759ba374f75ea0025b9af1bb35f14d7ea1a8fae68a24a59c5629c241401fabb08"></a>absent&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga759ba374f75ea0025b9af1bb35f14d7eaaeb73d7cb56b19bff3d9f80426ed3267" name="gga759ba374f75ea0025b9af1bb35f14d7eaaeb73d7cb56b19bff3d9f80426ed3267"></a>present&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga759ba374f75ea0025b9af1bb35f14d7ea5b9f6d065e6e98483b3d3ed01f4f6cbe" name="gga759ba374f75ea0025b9af1bb35f14d7ea5b9f6d065e6e98483b3d3ed01f4f6cbe"></a>unknown&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ga6e496c05213aa4bcbc0055ceee7808fa" name="ga6e496c05213aa4bcbc0055ceee7808fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e496c05213aa4bcbc0055ceee7808fa">&#9670;&#160;</a></span>reaction_status_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga6e496c05213aa4bcbc0055ceee7808fa">reaction_status_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__types_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_types.h</a>&gt;</code></p>

<p>Status of a given reaction at a given logical time. </p>
<p>If a reaction is 'inactive', it is neither running nor queued. If a reaction is 'queued', it is going to be executed at the current logical time, but it has not started running yet. If a reaction is 'running', its body is being executed.</p>
<dl class="section note"><dt>Note</dt><dd>inactive must equal zero because it should be possible to allocate a reaction with default values using calloc. </dd>
<dd>
The running state does not seem to be read. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6e496c05213aa4bcbc0055ceee7808faa76c1253bb97844abbdf89af6dfc3c7d6" name="gga6e496c05213aa4bcbc0055ceee7808faa76c1253bb97844abbdf89af6dfc3c7d6"></a>inactive&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga6e496c05213aa4bcbc0055ceee7808faa8ff224790af0c8a18f259da89dfb2225" name="gga6e496c05213aa4bcbc0055ceee7808faa8ff224790af0c8a18f259da89dfb2225"></a>queued&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga6e496c05213aa4bcbc0055ceee7808faab514bba77fe136c3a3b6f56b818f7b0c" name="gga6e496c05213aa4bcbc0055ceee7808faab514bba77fe136c3a3b6f56b818f7b0c"></a>running&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="gabe23a36a87d2f0c076da417eb0114c7e" name="gabe23a36a87d2f0c076da417eb0114c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe23a36a87d2f0c076da417eb0114c7e">&#9670;&#160;</a></span>token_freed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#gabe23a36a87d2f0c076da417eb0114c7e">token_freed</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__token_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_token.h</a>&gt;</code></p>

<p>Possible return values for <a class="el" href="#ga88c890be1f8d45461a6985cbfe6faa99">_lf_done_using</a> and <a class="el" href="#ga2798a92c59a1d46b602298cdbd187ab1">_lf_free_token</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabe23a36a87d2f0c076da417eb0114c7ea3d7522b54086645e077eb70e78731c5c" name="ggabe23a36a87d2f0c076da417eb0114c7ea3d7522b54086645e077eb70e78731c5c"></a>NOT_FREED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabe23a36a87d2f0c076da417eb0114c7ea417a0268666423fd955fea6f38cde238" name="ggabe23a36a87d2f0c076da417eb0114c7ea417a0268666423fd955fea6f38cde238"></a>VALUE_FREED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabe23a36a87d2f0c076da417eb0114c7ea0a6094445d7a54e61aa3a43f6d017e2b" name="ggabe23a36a87d2f0c076da417eb0114c7ea0a6094445d7a54e61aa3a43f6d017e2b"></a>TOKEN_FREED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggabe23a36a87d2f0c076da417eb0114c7ea02ef194d373714ee3ac62226729e0cb0" name="ggabe23a36a87d2f0c076da417eb0114c7ea02ef194d373714ee3ac62226729e0cb0"></a>TOKEN_AND_VALUE_FREED&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ga4659db62370c837baa55484134b3bfb7" name="ga4659db62370c837baa55484134b3bfb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4659db62370c837baa55484134b3bfb7">&#9670;&#160;</a></span>_lf_advance_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_advance_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>next_tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Advance from the current tag to the next. </p>
<p>If the given next_time is equal to the current time, then increase the microstep. Otherwise, update the current time and set the microstep to zero. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment in which we are executing </td></tr>
    <tr><td class="paramname">next_tag</td><td>The tag step to advance to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6396bfcdac50ddb71b6b29fa33a3cc5d" name="ga6396bfcdac50ddb71b6b29fa33a3cc5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6396bfcdac50ddb71b6b29fa33a3cc5d">&#9670;&#160;</a></span>_lf_create_dummy_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structevent__t.html">event_t</a> * _lf_create_dummy_events </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Create a dummy event with the specified tag. </p>
<p>A dummy event is an event with no triggers that can be put on the event queue to trigger a tag advance to the specified tag. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>Environment in which we are executing. </td></tr>
    <tr><td class="paramname">tag</td><td>The tag of that event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the dummy event. </dd></dl>

</div>
</div>
<a id="ga5a0540790dfc6d954fb443da3336ce27" name="ga5a0540790dfc6d954fb443da3336ce27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a0540790dfc6d954fb443da3336ce27">&#9670;&#160;</a></span>_lf_decrement_tag_barrier_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_decrement_tag_barrier_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__threaded_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/threaded/reactor_threaded.h</a>&gt;</code></p>

<p>Decrement the total number of pending barrier requests for the environment tag barrier. </p>
<p>If the total number of requests reaches zero, this function resets the tag barrier to FOREVER_TAG and notifies all threads that are waiting on the barrier that the number of requests has reached zero.</p>
<p>This function assumes that the caller already holds the mutex lock on env.</p>
<dl class="section note"><dt>Note</dt><dd>This function is only useful in threaded applications to facilitate certain non-blocking functionalities such as receiving timed messages over the network or handling stop in the federated execution.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment in which we are executing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga88c890be1f8d45461a6985cbfe6faa99" name="ga88c890be1f8d45461a6985cbfe6faa99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88c890be1f8d45461a6985cbfe6faa99">&#9670;&#160;</a></span>_lf_done_using()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#gabe23a36a87d2f0c076da417eb0114c7e">token_freed</a> _lf_done_using </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlf__token__t.html">lf_token_t</a> *</td>          <td class="paramname"><span class="paramname"><em>token</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__token_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_token.h</a>&gt;</code></p>

<p>Decrement the reference count of the specified token. </p>
<p>If the reference count hits 0, free the memory for the value carried by the token, and, if the token is not also the template token of its trigger, free the token.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>Pointer to a token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOT_FREED if nothing was freed, VALUE_FREED if the value was freed, TOKEN_FREED if only the token was freed, and TOKEN_AND_VALUE_FREED if both the value and the token were freed. </dd></dl>

</div>
</div>
<a id="gafd97c46ee623b1ae34a70088ee9b5020" name="gafd97c46ee623b1ae34a70088ee9b5020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd97c46ee623b1ae34a70088ee9b5020">&#9670;&#160;</a></span>_lf_free_all_tokens()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_free_all_tokens </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__token_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_token.h</a>&gt;</code></p>

<p>Free all tokens. </p>
<p>Free tokens on the _lf_token_recycling_bin hashset and all template tokens. </p>

</div>
</div>
<a id="ga2798a92c59a1d46b602298cdbd187ab1" name="ga2798a92c59a1d46b602298cdbd187ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2798a92c59a1d46b602298cdbd187ab1">&#9670;&#160;</a></span>_lf_free_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#gabe23a36a87d2f0c076da417eb0114c7e">token_freed</a> _lf_free_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlf__token__t.html">lf_token_t</a> *</td>          <td class="paramname"><span class="paramname"><em>token</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__token_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_token.h</a>&gt;</code></p>

<p>Free the specified token, if appropriate. </p>
<p>If the reference count is greater than 0, then do not free anything. Otherwise, the token value (payload) will be freed, if there is one. Then the token itself will be freed. The freed token will be put on the recycling bin unless that bin has reached the designated capacity, in which case free() will be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>Pointer to a token. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOT_FREED if nothing was freed, VALUE_FREED if the value was freed, TOKEN_FREED if only the token was freed, and TOKEN_AND_VALUE_FREED if both the value and the token were freed. </dd></dl>

</div>
</div>
<a id="gab1efa737bf70317f885c1dc772c4f23b" name="gab1efa737bf70317f885c1dc772c4f23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1efa737bf70317f885c1dc772c4f23b">&#9670;&#160;</a></span>_lf_free_token_copies()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_free_token_copies </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__token_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_token.h</a>&gt;</code></p>

<p>Free token copies made for mutable inputs. </p>
<p>This function should be called at the beginning of each time step to avoid memory leaks. </p>

</div>
</div>
<a id="gac109cd752121228507a95495a1eb6d8f" name="gac109cd752121228507a95495a1eb6d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac109cd752121228507a95495a1eb6d8f">&#9670;&#160;</a></span>_lf_get_environments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _lf_get_environments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> **</td>          <td class="paramname"><span class="paramname"><em>envs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="environment_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/environment.h</a>&gt;</code></p>

<p>Update the argument to point to the beginning of the array of environments in this program. </p>
<dl class="section note"><dt>Note</dt><dd>Is code-generated by the compiler </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">envs</td><td>A double pointer which will be dereferenced and modified </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int The number of environments in the array </dd></dl>

</div>
</div>
<a id="ga8f2f9c98968a10bf4d37077fd363ac48" name="ga8f2f9c98968a10bf4d37077fd363ac48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f2f9c98968a10bf4d37077fd363ac48">&#9670;&#160;</a></span>_lf_get_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlf__token__t.html">lf_token_t</a> * _lf_get_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtoken__template__t.html">token_template_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tmplt</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__token_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_token.h</a>&gt;</code></p>

<p>Get a token for the specified template. </p>
<p>If the template already has a token and the reference count is 1, then return that token. Otherwise, create a new token, make it the new template, and dissociate or free the previous template token.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmplt</td><td>The template. // template is a C++ keyword. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new or recycled <a class="el" href="structlf__token__t.html" title="Token type for dynamically allocated arrays and structs sent as messages.">lf_token_t</a> struct. </dd></dl>

</div>
</div>
<a id="gaa8e97abcbd89bb371d396da44ff4becb" name="gaa8e97abcbd89bb371d396da44ff4becb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8e97abcbd89bb371d396da44ff4becb">&#9670;&#160;</a></span>_lf_increment_tag_barrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_increment_tag_barrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>future_tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__threaded_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/threaded/reactor_threaded.h</a>&gt;</code></p>

<p>Raise a barrier to prevent the current tag for the specified environment from advancing to or beyond the value of the future_tag argument, if possible. </p>
<p>If the current tag is already at or beyond future_tag, then prevent any further advances. This function will increment the total number of pending barrier requests. For each call to this function, there should always be a subsequent call to <a class="el" href="#ga5a0540790dfc6d954fb443da3336ce27" title="Decrement the total number of pending barrier requests for the environment tag barrier.">_lf_decrement_tag_barrier_locked()</a> to release the barrier.</p>
<p>If there is already a barrier raised at a tag later than future_tag, this function will change the barrier to future_tag or the current tag, whichever is larger. If the existing barrier is earlier than future_tag, this function will not change the barrier. If there are no existing barriers and future_tag is in the past relative to the current tag, this function will raise a barrier to the current tag plus one microstep.</p>
<p>This function acquires the mutex on the specified environment.</p>
<dl class="section note"><dt>Note</dt><dd>This function is only useful in threaded applications to facilitate certain non-blocking functionalities such as receiving timed messages over the network or handling stop in a federated execution.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>Environment within which we are executing. </td></tr>
    <tr><td class="paramname">future_tag</td><td>A desired tag for the barrier. This function will guarantee that current logical time will not go past future_tag if it is in the future. If future_tag is in the past (or equals to current logical time), the runtime will freeze advancement of logical time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga01d3c6cadb7930c096ffe1f794173f5c" name="ga01d3c6cadb7930c096ffe1f794173f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01d3c6cadb7930c096ffe1f794173f5c">&#9670;&#160;</a></span>_lf_increment_tag_barrier_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_increment_tag_barrier_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>future_tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__threaded_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/threaded/reactor_threaded.h</a>&gt;</code></p>

<p>Version of _lf_increment_tag_barrier to call when the caller holds the mutex. </p>
<p>This version does not acquire the mutex belonging to env.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>Environment within which we are executing. </td></tr>
    <tr><td class="paramname">future_tag</td><td>A desired tag for the barrier. This function will guarantee that current logical time will not go past future_tag if it is in the future. If future_tag is in the past (or equals to current logical time), the runtime will freeze advancement of logical time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5d1a2996844350bc1e29de47e3b56644" name="ga5d1a2996844350bc1e29de47e3b56644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d1a2996844350bc1e29de47e3b56644">&#9670;&#160;</a></span>_lf_initialize_template()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_initialize_template </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtoken__template__t.html">token_template_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tmplt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>element_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__token_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_token.h</a>&gt;</code></p>

<p>Initialize the specified template to contain a token that is an. </p>
<p>array with the specified element size. If the template already has a token with a reference count greater than 1 or a non-matching type, it will be replaced and that token will be freed. The length of the returned token will be 0, its value will be NULL, and its reference count will be 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmplt</td><td>The template. // template is a C++ keyword. </td></tr>
    <tr><td class="paramname">element_size</td><td>The element size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga61a2c70695093f8a38b1e922fb36547f" name="ga61a2c70695093f8a38b1e922fb36547f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61a2c70695093f8a38b1e922fb36547f">&#9670;&#160;</a></span>_lf_initialize_timer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _lf_initialize_timer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrigger__t.html">trigger_t</a> *</td>          <td class="paramname"><span class="paramname"><em>timer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Initialize the given timer. </p>
<p>If this timer has a zero offset, enqueue the reactions it triggers. If this timer is to trigger reactions at a <em>future</em> tag as well, schedule it accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>Environment in which we are executing. </td></tr>
    <tr><td class="paramname">timer</td><td>The timer to initialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the timer has an offset of 0, in which case the reaction is triggered rather than scheduled. </dd></dl>

</div>
</div>
<a id="ga37bdd5c8fe3428b85eff05f0629da411" name="ga37bdd5c8fe3428b85eff05f0629da411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37bdd5c8fe3428b85eff05f0629da411">&#9670;&#160;</a></span>_lf_initialize_timers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _lf_initialize_timers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Initialize all the timers in the environment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>Environment in which we are executing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any timer has an offset of 0, in which case the reaction is triggered rather than scheduled. </dd></dl>

</div>
</div>
<a id="ga6e2c7940f2e59f5ff57807df6b41f5fe" name="ga6e2c7940f2e59f5ff57807df6b41f5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e2c7940f2e59f5ff57807df6b41f5fe">&#9670;&#160;</a></span>_lf_initialize_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlf__token__t.html">lf_token_t</a> * _lf_initialize_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtoken__template__t.html">token_template_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tmplt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__token_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_token.h</a>&gt;</code></p>

<p>Return a token for storing an array of the specified length with new memory allocated (using calloc, so initialize to zero) for storing that array. </p>
<p>If the template's token is available (it is non-null and its reference count is 1), then reuse it. Otherwise, create a new token and replace the template token with the new one, freeing the previous token from its template association. The element_size for elements of the array is specified by the specified template. The caller should populate the value and ref_count field of the returned token after this returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmplt</td><td>The token template (must not be NULL). // template is a C++ keyword. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the array, or 1 if it is not an array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either the template's token or a new one, in each case with a value field pointing to newly allocated memory. </dd></dl>

</div>
</div>
<a id="gac171b72d59f37653f012d30cad72a2d2" name="gac171b72d59f37653f012d30cad72a2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac171b72d59f37653f012d30cad72a2d2">&#9670;&#160;</a></span>_lf_initialize_token_with_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlf__token__t.html">lf_token_t</a> * _lf_initialize_token_with_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtoken__template__t.html">token_template_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tmplt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__token_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_token.h</a>&gt;</code></p>

<p>Return a token storing the specified value, which is assumed to be either a scalar (if length is 1) or an array of the specified length. </p>
<p>If the token in the specified template is available (it non-null and its reference count is 1), then return it. Otherwise, create a new token and replace the template token with the new one, freeing the previous token from its template association. The element_size for elements of the array is specified by the specified template.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmplt</td><td>A template for the token. // template is a C++ keyword. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the array. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the array, or 1 if it is not an array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either the specified token or a new one, in each case with a value field pointing to newly allocated memory. </dd></dl>

</div>
</div>
<a id="ga52ffa06ff177dc19d33713beb2ff344e" name="ga52ffa06ff177dc19d33713beb2ff344e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52ffa06ff177dc19d33713beb2ff344e">&#9670;&#160;</a></span>_lf_initialize_trigger_objects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_initialize_trigger_objects </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Generated function that produces a table containing all triggers (i.e., inputs, timers, and actions). </p>

</div>
</div>
<a id="gaa6a016400f119168b48505e51baaaa55" name="gaa6a016400f119168b48505e51baaaa55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6a016400f119168b48505e51baaaa55">&#9670;&#160;</a></span>_lf_initialize_watchdogs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_initialize_watchdogs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="watchdog_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/threaded/watchdog.h</a>&gt;</code></p>

<p>Function to initialize mutexes for watchdogs. </p>
<p>This function is used to initialize the mutexes for the watchdogs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment to initialize the watchdogs for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeac3f6a2d15f30e3adecc9f431162bef" name="gaeac3f6a2d15f30e3adecc9f431162bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeac3f6a2d15f30e3adecc9f431162bef">&#9670;&#160;</a></span>_lf_insert_reactions_for_trigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a> _lf_insert_reactions_for_trigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrigger__t.html">trigger_t</a> *</td>          <td class="paramname"><span class="paramname"><em>trigger</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlf__token__t.html">lf_token_t</a> *</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Insert reactions triggered by trigger to the reaction queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>Environment in which we are executing. </td></tr>
    <tr><td class="paramname">trigger</td><td>The trigger. </td></tr>
    <tr><td class="paramname">token</td><td>The token wrapping the payload or NULL for no payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, or 0 if no new reaction was scheduled because the function was called incorrectly. </dd></dl>

</div>
</div>
<a id="ga7fe988f0eee005defaa2ad2c9f1f2fd8" name="ga7fe988f0eee005defaa2ad2c9f1f2fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fe988f0eee005defaa2ad2c9f1f2fd8">&#9670;&#160;</a></span>_lf_invoke_reaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_invoke_reaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreaction__t.html">reaction_t</a> *</td>          <td class="paramname"><span class="paramname"><em>reaction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>worker</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Invoke the specified reaction on the specified worker in the specified environment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment in which we are executing. </td></tr>
    <tr><td class="paramname">reaction</td><td>The reaction. </td></tr>
    <tr><td class="paramname">worker</td><td>The worker number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga23e88870b9a699d1a067ff5b397e0887" name="ga23e88870b9a699d1a067ff5b397e0887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23e88870b9a699d1a067ff5b397e0887">&#9670;&#160;</a></span>_lf_multiport_iterator_impl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlf__multiport__iterator__t.html">lf_multiport_iterator_t</a> _lf_multiport_iterator_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlf__port__base__t.html">lf_port_base_t</a> **</td>          <td class="paramname"><span class="paramname"><em>port</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="port_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/port.h</a>&gt;</code></p>

<p>Given an array of pointers to port structs, return an iterator that can be used to iterate over the present channels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>An array of pointers to port structs. </td></tr>
    <tr><td class="paramname">width</td><td>The width of the multiport (or a negative number if not a multiport). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4616dad8eeb4cbe04a4f9697d3de9b16" name="ga4616dad8eeb4cbe04a4f9697d3de9b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4616dad8eeb4cbe04a4f9697d3de9b16">&#9670;&#160;</a></span>_lf_new_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlf__token__t.html">lf_token_t</a> * _lf_new_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtoken__type__t.html">token_type_t</a> *</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__token_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_token.h</a>&gt;</code></p>

<p>Return a new token with the specified type, value, and length. </p>
<p>This will attempt to get one from the recyling bin, and, if the recycling bin is empty, will allocate a new token using calloc and set its type to point to the specified type. The returned token will indicate that it is not a template token, and its reference count will be 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the token. </td></tr>
    <tr><td class="paramname">value</td><td>The value, or NULL to have no value. </td></tr>
    <tr><td class="paramname">length</td><td>The array length of the value, 1 to not be an array, or 0 to have no value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lf_token_t* </dd></dl>

</div>
</div>
<a id="gab9e357a21e338cd3719cdec409b9f7a6" name="gab9e357a21e338cd3719cdec409b9f7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9e357a21e338cd3719cdec409b9f7a6">&#9670;&#160;</a></span>_lf_next_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_next_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__threaded_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/threaded/reactor_threaded.h</a>&gt;</code></p>

<p>Advance the logical time. </p>
<p>If there is at least one event in the event queue, then wait until physical time matches or exceeds the time of the least tag on the event queue; pop the next event(s) from the event queue that all have the same tag; extract from those events the reactions that are to be invoked at this logical time and insert them into the reaction queue. The event queue is sorted by time tag.</p>
<p>If there is no event in the queue and the keepalive command-line option was not given, and this is not a federated execution with centralized coordination, set the stop tag to the current tag. If keepalive was given, then wait for either <a class="el" href="group__API.html#gab49affc958f705d9e33c5e3463848bda" title="Request a stop to execution as soon as possible.">lf_request_stop()</a> to be called or an event appears in the event queue and then return.</p>
<p>Every time tag is advanced, it is checked against stop tag and if they are equal, shutdown reactions are triggered.</p>
<p>This does not acquire the mutex lock. It assumes the lock is already held. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>Environment within which we are executing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga41e1c14ed7c1ab5ab19b8b98d84006b6" name="ga41e1c14ed7c1ab5ab19b8b98d84006b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41e1c14ed7c1ab5ab19b8b98d84006b6">&#9670;&#160;</a></span>_lf_pop_events()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_pop_events </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Pop all events from event_q with tag equal to current tag. </p>
<p>This will extract all the reactions triggered by these events and stick them onto the reaction queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment in which we are executing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga292c73e4f09daa50330b53079df620a9" name="ga292c73e4f09daa50330b53079df620a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga292c73e4f09daa50330b53079df620a9">&#9670;&#160;</a></span>_lf_register_trace_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _lf_register_trace_event </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>pointer1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>pointer2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Tracing.html#gaeec3d6d67240b942f12f5d8770698ae3">_lf_trace_object_t</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>description</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tracepoint_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/tracepoint.h</a>&gt;</code></p>

<p>Register a trace object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer1</td><td>Pointer that identifies the object, typically to a reactor self struct. </td></tr>
    <tr><td class="paramname">pointer2</td><td>Further identifying pointer, typically to a trigger (action or timer) or NULL if irrelevant. </td></tr>
    <tr><td class="paramname">type</td><td>The type of trace object. </td></tr>
    <tr><td class="paramname">description</td><td>The human-readable description of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if successful, 0 if the trace object table is full. </dd></dl>

</div>
</div>
<a id="gabeff98dcfb6b5715aac8e1438c5a6e77" name="gabeff98dcfb6b5715aac8e1438c5a6e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabeff98dcfb6b5715aac8e1438c5a6e77">&#9670;&#160;</a></span>_lf_replace_template_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_replace_template_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtoken__template__t.html">token_template_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tmplt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlf__token__t.html">lf_token_t</a> *</td>          <td class="paramname"><span class="paramname"><em>newtoken</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__token_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_token.h</a>&gt;</code></p>

<p>Replace the token in the specified template, if there is one, with a new one. </p>
<p>If the new token is the same as the token in the template, then this does nothing. Otherwise, it frees the previous template token.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tmplt</td><td>Pointer to a template. // template is a C++ keyword. </td></tr>
    <tr><td class="paramname">newtoken</td><td>The replacement token. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf2c6b4fac0a87c3cc914c713714e1fca" name="gaf2c6b4fac0a87c3cc914c713714e1fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2c6b4fac0a87c3cc914c713714e1fca">&#9670;&#160;</a></span>_lf_sched_advance_tag_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool _lf_sched_advance_tag_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlf__scheduler__t.html">lf_scheduler_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sched</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="scheduler__sync__tag__advance_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/threaded/scheduler_sync_tag_advance.h</a>&gt;</code></p>

<p>Advance the tag to the next tag on the event queue. </p>
<p>This will also pop events for the newly acquired tag and trigger the enabled reactions using the scheduler.</p>
<p>This function assumes the caller holds the environment mutex lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sched</td><td>The scheduler instance to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the worker thread should exit. False otherwise. </dd></dl>

</div>
</div>
<a id="ga9d2634d70492498740984f320dffe8f0" name="ga9d2634d70492498740984f320dffe8f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d2634d70492498740984f320dffe8f0">&#9670;&#160;</a></span>_lf_schedule_at_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a> _lf_schedule_at_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrigger__t.html">trigger_t</a> *</td>          <td class="paramname"><span class="paramname"><em>trigger</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlf__token__t.html">lf_token_t</a> *</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Schedule an event at a specific tag (time, microstep). </p>
<p>If there is an event found at the requested tag, the payload is replaced and 0 is returned.</p>
<p>Note that this function is an internal API that must be called with a tag that is in the future relative to the current tag (or the environment has not started executing). Also, it must be called with tags that are in order for a given trigger. This means that the following order is illegal: </p><div class="fragment"><div class="line"><a class="code hl_function" href="#ga9d2634d70492498740984f320dffe8f0">_lf_schedule_at_tag</a>(env, trigger1, bigger_tag, ...);</div>
<div class="line"><a class="code hl_function" href="#ga9d2634d70492498740984f320dffe8f0">_lf_schedule_at_tag</a>(env, trigger1, smaller_tag, ...);</div>
<div class="ttc" id="agroup__Internal_html_ga9d2634d70492498740984f320dffe8f0"><div class="ttname"><a href="#ga9d2634d70492498740984f320dffe8f0">_lf_schedule_at_tag</a></div><div class="ttdeci">trigger_handle_t _lf_schedule_at_tag(environment_t *env, trigger_t *trigger, tag_t tag, lf_token_t *token)</div><div class="ttdoc">Schedule an event at a specific tag (time, microstep).</div></div>
</div><!-- fragment --><p> where <span class="tt">bigger_tag &gt; smaller_tag</span>. This function is primarily used for network communication (which is assumed to be in order).</p>
<p>This function assumes the caller holds the mutex lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>Environment in which we are executing. </td></tr>
    <tr><td class="paramname">trigger</td><td>The trigger to be invoked at a later logical time. </td></tr>
    <tr><td class="paramname">tag</td><td>Logical tag of the event </td></tr>
    <tr><td class="paramname">token</td><td>The token wrapping the payload or NULL for no payload.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A positive trigger handle for success, 0 if no new event was scheduled (instead, the payload was updated), or -1 for error (the tag is equal to or less than the current tag). </dd></dl>

</div>
</div>
<a id="gaf31c25686db5996e9f3493745e63856a" name="gaf31c25686db5996e9f3493745e63856a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf31c25686db5996e9f3493745e63856a">&#9670;&#160;</a></span>_lf_schedule_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a> _lf_schedule_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Schedule an action to occur with the specified value and time offset with a copy of the specified value. </p>
<p>This is an internal API that is identical to <span class="tt">lf_schedule_copy</span> except that it takes an environment as an argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>Environment in which we are executing. </td></tr>
    <tr><td class="paramname">action</td><td>The action to be triggered (a pointer to an <span class="tt"><a class="el" href="structlf__action__base__t.html" title="Base type for actions.">lf_action_base_t</a></span>). </td></tr>
    <tr><td class="paramname">offset</td><td>The time offset over and above that in the action. </td></tr>
    <tr><td class="paramname">value</td><td>A pointer to the value to copy. </td></tr>
    <tr><td class="paramname">length</td><td>The length, if an array, 1 if a scalar, and 0 if value is NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the event, or 0 if no event was scheduled, or -1 for error. </dd></dl>

</div>
</div>
<a id="ga6d8b49ac9cf089b35a5d2df6a9209255" name="ga6d8b49ac9cf089b35a5d2df6a9209255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d8b49ac9cf089b35a5d2df6a9209255">&#9670;&#160;</a></span>_lf_schedule_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a> _lf_schedule_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>action</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a></td>          <td class="paramname"><span class="paramname"><em>extra_delay</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlf__token__t.html">lf_token_t</a> *</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Schedule the specified action at a later tag with the specified token as a payload. </p>
<p>This is an internal API that is identical to <span class="tt">lf_schedule_token</span> except that it takes an environment as an argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>Environment in which we are executing. </td></tr>
    <tr><td class="paramname">action</td><td>The action to be triggered (a pointer to an <span class="tt"><a class="el" href="structlf__action__base__t.html" title="Base type for actions.">lf_action_base_t</a></span>). </td></tr>
    <tr><td class="paramname">extra_delay</td><td>Extra offset of the event release above that in the action. </td></tr>
    <tr><td class="paramname">token</td><td>The token to carry the payload or null for no payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the event, or 0 if no event was scheduled, or -1 for error. </dd></dl>

</div>
</div>
<a id="gab5d69d8631d56d64fb90547a8d6b10cd" name="gab5d69d8631d56d64fb90547a8d6b10cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5d69d8631d56d64fb90547a8d6b10cd">&#9670;&#160;</a></span>_lf_start_time_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_start_time_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Perform whatever is needed to start a time step. </p>
<p>For example, this function resets outputs to be absent at the start of a new time step. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment in which we are executing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf31f8aca1b004a6e5e0e695063de1b47" name="gaf31f8aca1b004a6e5e0e695063de1b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf31f8aca1b004a6e5e0e695063de1b47">&#9670;&#160;</a></span>_lf_trigger_reaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_trigger_reaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreaction__t.html">reaction_t</a> *</td>          <td class="paramname"><span class="paramname"><em>reaction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>worker_number</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Trigger the specified reaction on the specified worker in the specified environment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>Environment in which we are executing. </td></tr>
    <tr><td class="paramname">reaction</td><td>The reaction. </td></tr>
    <tr><td class="paramname">worker_number</td><td>The ID of the worker that is making this call. 0 should be used if there is only one worker (e.g., when the program is using the single-threaded C runtime). -1 is used for an anonymous call in a context where a worker number does not make sense (e.g., the caller is not a worker thread). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga282a342efac4fc3e198fb9656f0a9adc" name="ga282a342efac4fc3e198fb9656f0a9adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga282a342efac4fc3e198fb9656f0a9adc">&#9670;&#160;</a></span>_lf_trigger_shutdown_reactions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_trigger_shutdown_reactions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Trigger all the shutdown reactions in the specified environment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>Environment in which we are executing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafd3a0abded3adbc25ab7dbc261e7b16c" name="gafd3a0abded3adbc25ab7dbc261e7b16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafd3a0abded3adbc25ab7dbc261e7b16c">&#9670;&#160;</a></span>_lf_trigger_startup_reactions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_trigger_startup_reactions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Trigger all the startup reactions in the specified environment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>Environment in which we are executing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3d1cd5263a79c14e62a5fb34530a0a93" name="ga3d1cd5263a79c14e62a5fb34530a0a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d1cd5263a79c14e62a5fb34530a0a93">&#9670;&#160;</a></span>_lf_wait_on_tag_barrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _lf_wait_on_tag_barrier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>proposed_tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__threaded_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/threaded/reactor_threaded.h</a>&gt;</code></p>

<p>Wait on the tag barrier for the environment. </p>
<p>If the proposed_tag is greater than or equal to a barrier tag that has been set by a call to _lf_increment_tag_barrier or _lf_increment_tag_barrier_locked, and if there are requestors still pending on that barrier, then wait until all requestors have been satisfied. This is used in federated execution when an incoming timed message has been partially read so that we know its tag, but the rest of message has not yet been read and hence the event has not yet appeared on the event queue. To prevent tardiness, this function blocks the advancement of time until to the proposed tag until the message has been put onto the event queue.</p>
<p>If the proposed_tag is greater than the stop tag, then use the stop tag instead.</p>
<p>This function assumes the mutex is already locked. Thus, it unlocks the mutex while it's waiting to allow the tag barrier to change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>Environment within which we are executing. </td></tr>
    <tr><td class="paramname">proposed_tag</td><td>The tag that the runtime wants to advance to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if no wait was needed and 1 if a wait actually occurred. </dd></dl>

</div>
</div>
<a id="gab3957d31bade9b6ebcbc27aae6be3f14" name="gab3957d31bade9b6ebcbc27aae6be3f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3957d31bade9b6ebcbc27aae6be3f14">&#9670;&#160;</a></span>_lf_watchdog_terminate_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _lf_watchdog_terminate_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="watchdog_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/threaded/watchdog.h</a>&gt;</code></p>

<p>Terminates all watchdogs inside the environment. </p>
<p>This function is used to terminate all the watchdogs inside the environment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment to terminate the watchdogs for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad0ae74c1c8d1935b3fb92e546988503c" name="gad0ae74c1c8d1935b3fb92e546988503c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0ae74c1c8d1935b3fb92e546988503c">&#9670;&#160;</a></span>call_tracepoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void call_tracepoint </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>event_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>reactor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>worker</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>src_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dst_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a> *</td>          <td class="paramname"><span class="paramname"><em>physical_time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrigger__t.html">trigger_t</a> *</td>          <td class="paramname"><span class="paramname"><em>trigger</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a></td>          <td class="paramname"><span class="paramname"><em>extra_delay</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tracepoint_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/tracepoint.h</a>&gt;</code></p>

<p>Pass the provided info to the tracing module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_type</td><td>The kind of tracepoint. </td></tr>
    <tr><td class="paramname">reactor</td><td>A pointer used as an opaque ID of the source reactor, if one exists. </td></tr>
    <tr><td class="paramname">tag</td><td>The tag associated with the tracepoint. </td></tr>
    <tr><td class="paramname">worker</td><td>The worker thread where the tracepoint was reached. </td></tr>
    <tr><td class="paramname">src_id</td><td>The ID of the source federate/enclave, if applicable. </td></tr>
    <tr><td class="paramname">dst_id</td><td>The ID of the destination federate/enclave, if applicable. </td></tr>
    <tr><td class="paramname">physical_time</td><td>The time at which the tracepoint was reached, or NULL if not applicable. </td></tr>
    <tr><td class="paramname">trigger</td><td>The trigger, if this tracepoint signifies scheduling of an event. </td></tr>
    <tr><td class="paramname">extra_delay</td><td>The delay passed to schedule(), if applicable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf73b90f735c070d534171f3e92730ac8" name="gaf73b90f735c070d534171f3e92730ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf73b90f735c070d534171f3e92730ac8">&#9670;&#160;</a></span>environment_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void environment_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="environment_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/environment.h</a>&gt;</code></p>

<p>Free the dynamically allocated memory on the environment struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment in which we are executing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab49da5954eb69f3d126162da44c25b36" name="gab49da5954eb69f3d126162da44c25b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab49da5954eb69f3d126162da44c25b36">&#9670;&#160;</a></span>environment_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int environment_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_workers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_timers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_startup_reactions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_shutdown_reactions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_reset_reactions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_is_present_fields</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_modes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_state_resets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_watchdogs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>trace_file_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="environment_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/environment.h</a>&gt;</code></p>

<p>Initialize an environment struct with parameters given in the arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment to initialize. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the environment. </td></tr>
    <tr><td class="paramname">id</td><td>The ID of the environment. </td></tr>
    <tr><td class="paramname">num_workers</td><td>The number of worker threads in the environment. </td></tr>
    <tr><td class="paramname">num_timers</td><td>The number of timer triggers in the environment. </td></tr>
    <tr><td class="paramname">num_startup_reactions</td><td>The number of startup reactions in the environment. </td></tr>
    <tr><td class="paramname">num_shutdown_reactions</td><td>The number of shutdown reactions in the environment. </td></tr>
    <tr><td class="paramname">num_reset_reactions</td><td>The number of reset reactions in the environment. </td></tr>
    <tr><td class="paramname">num_is_present_fields</td><td>The number of is_present fields in the environment. </td></tr>
    <tr><td class="paramname">num_modes</td><td>The number of modes in the environment. </td></tr>
    <tr><td class="paramname">num_state_resets</td><td>The number of state resets in the environment. </td></tr>
    <tr><td class="paramname">num_watchdogs</td><td>The number of watchdogs in the environment. </td></tr>
    <tr><td class="paramname">trace_file_name</td><td>The name of the trace file to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="gaf23dde6465214cc92114e0c49bccdc72" name="gaf23dde6465214cc92114e0c49bccdc72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf23dde6465214cc92114e0c49bccdc72">&#9670;&#160;</a></span>environment_init_tags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void environment_init_tags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a></td>          <td class="paramname"><span class="paramname"><em>start_time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a></td>          <td class="paramname"><span class="paramname"><em>duration</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="environment_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/environment.h</a>&gt;</code></p>

<p>Initialize the start and stop tags on the environment struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment to initialize. </td></tr>
    <tr><td class="paramname">start_time</td><td>The start time of the environment. </td></tr>
    <tr><td class="paramname">duration</td><td>The duration of the environment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeb51302599cae953b2b8942088879e2f" name="gaeb51302599cae953b2b8942088879e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb51302599cae953b2b8942088879e2f">&#9670;&#160;</a></span>environment_verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void environment_verify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="environment_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/environment.h</a>&gt;</code></p>

<p>Verify that the environment is correctly set up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment to verify. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8db9f1cd3ea7eb70e6958e732b26e61d" name="ga8db9f1cd3ea7eb70e6958e732b26e61d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8db9f1cd3ea7eb70e6958e732b26e61d">&#9670;&#160;</a></span>error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void void void void error </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>msg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/util.h</a>&gt;</code></p>

<p>Print the error defined by the errno variable with the specified message as a prefix, then exit with error code 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The prefix to the message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9b50c51a9046dfb8814b2f609020d0a4" name="ga9b50c51a9046dfb8814b2f609020d0a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b50c51a9046dfb8814b2f609020d0a4">&#9670;&#160;</a></span>get_next_event_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtag__t.html">tag_t</a> get_next_event_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__threaded_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/threaded/reactor_threaded.h</a>&gt;</code></p>

<p>Return the tag of the next event on the event queue. </p>
<p>If the event queue is empty then return either FOREVER_TAG or, is a stop_time (timeout time) has been set, the stop time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>Environment within which we are executing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacd6d67f4e05f2780b23aef72f92468f5" name="gacd6d67f4e05f2780b23aef72f92468f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd6d67f4e05f2780b23aef72f92468f5">&#9670;&#160;</a></span>get_reaction_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#gad8239ddc32134716f57e54bb972f6bf0">pqueue_pri_t</a> get_reaction_index </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>reaction</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue.h</a>&gt;</code></p>

<p>Report a priority equal to the index of the given reaction. </p>
<p>Used for sorting pointers to <a class="el" href="structreaction__t.html" title="Reaction activation record to push onto the reaction queue.">reaction_t</a> structs in the blocked and executing queues. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reaction</td><td>A pointer to a <a class="el" href="structreaction__t.html" title="Reaction activation record to push onto the reaction queue.">reaction_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga051ae6a8bc2b547818e06cb0c72b14a2" name="ga051ae6a8bc2b547818e06cb0c72b14a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga051ae6a8bc2b547818e06cb0c72b14a2">&#9670;&#160;</a></span>get_reaction_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t get_reaction_position </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>reaction</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue.h</a>&gt;</code></p>

<p>Return the given reaction's position in the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reaction</td><td>A pointer to a <a class="el" href="structreaction__t.html" title="Reaction activation record to push onto the reaction queue.">reaction_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga987e40d356a70d4799d6fe56920d3b8f" name="ga987e40d356a70d4799d6fe56920d3b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga987e40d356a70d4799d6fe56920d3b8f">&#9670;&#160;</a></span>in_no_particular_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int in_no_particular_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gad8239ddc32134716f57e54bb972f6bf0">pqueue_pri_t</a></td>          <td class="paramname"><span class="paramname"><em>thiz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gad8239ddc32134716f57e54bb972f6bf0">pqueue_pri_t</a></td>          <td class="paramname"><span class="paramname"><em>that</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue.h</a>&gt;</code></p>

<p>Return 0 regardless of argument order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thiz</td><td>First argument. </td></tr>
    <tr><td class="paramname">that</td><td>Second argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga19d650d18c331602f44c642bce2456e8" name="ga19d650d18c331602f44c642bce2456e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19d650d18c331602f44c642bce2456e8">&#9670;&#160;</a></span>in_reverse_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int in_reverse_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gad8239ddc32134716f57e54bb972f6bf0">pqueue_pri_t</a></td>          <td class="paramname"><span class="paramname"><em>thiz</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gad8239ddc32134716f57e54bb972f6bf0">pqueue_pri_t</a></td>          <td class="paramname"><span class="paramname"><em>that</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue.h</a>&gt;</code></p>

<p>Return 1 if the first argument is greater than the second and zero otherwise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thiz</td><td>First argument. </td></tr>
    <tr><td class="paramname">that</td><td>Second argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga42d0bf55641d6ff4390081175de65496" name="ga42d0bf55641d6ff4390081175de65496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42d0bf55641d6ff4390081175de65496">&#9670;&#160;</a></span>initialize_global()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_global </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Initialize global variables and start tracing before calling the <a class="el" href="#ga52ffa06ff177dc19d33713beb2ff344e">_lf_initialize_trigger_objects()</a> function. </p>

</div>
</div>
<a id="ga1a5fdb69bc112879d4014bb0790e843c" name="ga1a5fdb69bc112879d4014bb0790e843c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a5fdb69bc112879d4014bb0790e843c">&#9670;&#160;</a></span>lf_allocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * lf_allocate </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structallocation__record__t.html">allocation_record_t</a> **</td>          <td class="paramname"><span class="paramname"><em>head</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor.h</a>&gt;</code></p>

<p>Allocate memory and record on the specified allocation record (a self struct). </p>
<p>This will allocate memory using calloc (so the allocated memory is zeroed out) and record the allocated memory on the specified self struct so that it will be freed when calling <a class="el" href="#ga2f0b7c8d624c2da93012538bd93568ad">lf_free_reactor()</a>.</p>
<p>In a reaction body, you can access the head of the allocation records for the current reactor with <span class="tt">&amp;self-&gt;base.allocations</span>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of items of size 'size' to accomodate. </td></tr>
    <tr><td class="paramname">size</td><td>The size of each item. </td></tr>
    <tr><td class="paramname">head</td><td>Pointer to the head of a list on which to record the allocation, or NULL to not record it (an <span class="tt">allocation_record_t**</span>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the allocated memory. </dd></dl>

</div>
</div>
<a id="ga6876ddf559d9ecf14ae78f76e6ff2045" name="ga6876ddf559d9ecf14ae78f76e6ff2045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6876ddf559d9ecf14ae78f76e6ff2045">&#9670;&#160;</a></span>lf_combine_deadline_and_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga4448d06be794d3f5412d0edb412dc00e">index_t</a> lf_combine_deadline_and_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a></td>          <td class="paramname"><span class="paramname"><em>deadline</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>level</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Combine a deadline and a level into a single index for sorting in the reaction queue. </p>
<p>This shifts the deadline right by 16 bits and inserts the level in the low-order 16 bits. If the deadline is larger than <span class="tt">ULLONG_MAX &gt;&gt; 16</span>, then it is treated as the largest possible deadline. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deadline</td><td>THe deadline. </td></tr>
    <tr><td class="paramname">level</td><td>The level in the reaction graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf2a6b2663dca116472afc45b50040a3d" name="gaf2a6b2663dca116472afc45b50040a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2a6b2663dca116472afc45b50040a3d">&#9670;&#160;</a></span>lf_create_environments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_create_environments </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Create and initialize the required number of environments for the program. </p>
<dl class="section note"><dt>Note</dt><dd>This function will be code generated by the compiler. </dd></dl>

</div>
</div>
<a id="gaf61e1a6183ff7d40b1b998c08447130e" name="gaf61e1a6183ff7d40b1b998c08447130e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf61e1a6183ff7d40b1b998c08447130e">&#9670;&#160;</a></span>lf_delay_strict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtag__t.html">tag_t</a> lf_delay_strict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a></td>          <td class="paramname"><span class="paramname"><em>interval</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tag_8h.html">/Users/runner/work/reactor-c/reactor-c/tag/api/tag.h</a>&gt;</code></p>

<p>Return the latest tag strictly less than the specified tag plus the interval, unless tag is NEVER or interval is negative (including NEVER),. </p>
<p>in which case return the tag unmodified. Any interval less than 0 (including NEVER) is interpreted as "no delay", whereas an interval equal to 0 is interpreted as one microstep delay. If the time sum overflows, saturate the time value at FOREVER. For example:</p><ul>
<li>if tag = (t, 0) and interval = 10, return (t + 10 - 1, UINT_MAX)</li>
<li>if tag = (t, 0) and interval = 0, return (t, 0)</li>
<li>if tag = (t, 0) and interval = NEVER, return (t, 0)</li>
<li>if tag = (FOREVER, 0) and interval = 10, return (FOREVER, 0)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>The tag to increment. </td></tr>
    <tr><td class="paramname">interval</td><td>The time interval. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6e9c2ed60ca5adec5ba3f43d4410dc75" name="ga6e9c2ed60ca5adec5ba3f43d4410dc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e9c2ed60ca5adec5ba3f43d4410dc75">&#9670;&#160;</a></span>lf_fed_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t lf_fed_id </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/util.h</a>&gt;</code></p>

<p>Return the federate ID or -1 if this program is not part of a federation. </p>

</div>
</div>
<a id="gaa028b6b458854278bb2a2de486e40268" name="gaa028b6b458854278bb2a2de486e40268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa028b6b458854278bb2a2de486e40268">&#9670;&#160;</a></span>lf_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structallocation__record__t.html">allocation_record_t</a> **</td>          <td class="paramname"><span class="paramname"><em>head</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Free memory on the specified allocation record (a self struct). </p>
<p>This will mark the allocation record empty by setting <span class="tt">*head</span> to NULL. If the argument is NULL, do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of a list on which allocations are recorded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadf76c4fc43b07691236fa6a483762481" name="gadf76c4fc43b07691236fa6a483762481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf76c4fc43b07691236fa6a483762481">&#9670;&#160;</a></span>lf_free_all_reactors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_free_all_reactors </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor.h</a>&gt;</code></p>

<p>Free all the reactors that are allocated with <code><a class="el" href="#ga129c6df527165b2378d1dc4852411c35">lf_new_reactor(size_t)</a></code>. </p>

</div>
</div>
<a id="ga2f0b7c8d624c2da93012538bd93568ad" name="ga2f0b7c8d624c2da93012538bd93568ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f0b7c8d624c2da93012538bd93568ad">&#9670;&#160;</a></span>lf_free_reactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_free_reactor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structself__base__t.html">self_base_t</a> *</td>          <td class="paramname"><span class="paramname"><em>self</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor.h</a>&gt;</code></p>

<p>Free the specified reactor. </p>
<p>This will free the memory recorded on the allocations list of the specified reactor and then free the specified self struct. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">self</td><td>The self struct of the reactor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeb163964110b0029fc4c460b2478ea4d" name="gaeb163964110b0029fc4c460b2478ea4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb163964110b0029fc4c460b2478ea4d">&#9670;&#160;</a></span>lf_get_new_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structevent__t.html">event_t</a> * lf_get_new_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Get a new event. </p>
<p>If there is a recycled event available, use that. If not, allocate a new one. In either case, all fields will be zero'ed out. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>Environment in which we are executing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga129c6df527165b2378d1dc4852411c35" name="ga129c6df527165b2378d1dc4852411c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga129c6df527165b2378d1dc4852411c35">&#9670;&#160;</a></span>lf_new_reactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structself__base__t.html">self_base_t</a> * lf_new_reactor </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor.h</a>&gt;</code></p>

<p>Allocate memory for a new runtime instance of a reactor. </p>
<p>This records the reactor on the list of reactors to be freed at termination of the program. If you plan to free the reactor before termination of the program, use <code><a class="el" href="#ga1a5fdb69bc112879d4014bb0790e843c">lf_allocate(size_t, size_t, allocation_record_t**)</a></code> with a null last argument instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of the self struct, obtained with sizeof(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaae4a4a9ce970c18bff7785cf7863777c" name="gaae4a4a9ce970c18bff7785cf7863777c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae4a4a9ce970c18bff7785cf7863777c">&#9670;&#160;</a></span>lf_print_snapshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_print_snapshot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor.h</a>&gt;</code></p>

<p>Print a snapshot of the priority queues used during execution (for debugging). </p>
<p>This function implementation will be empty if the NDEBUG macro is defined; that macro is normally defined for release builds. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment in which we are executing, which you can access in a reaction body with <span class="tt">self-&gt;base.environment</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0dbdf3a0cb8b0075acfc45437f4c7e27" name="ga0dbdf3a0cb8b0075acfc45437f4c7e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dbdf3a0cb8b0075acfc45437f4c7e27">&#9670;&#160;</a></span>lf_recycle_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_recycle_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structevent__t.html">event_t</a> *</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Recycle the given event. </p>
<p>This will zero out the event and push it onto the recycle queue. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>Environment in which we are executing. </td></tr>
    <tr><td class="paramname">e</td><td>The event to recycle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3c0888056123fd1ef7c2fdd7a8081ddf" name="ga3c0888056123fd1ef7c2fdd7a8081ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c0888056123fd1ef7c2fdd7a8081ddf">&#9670;&#160;</a></span>lf_replace_token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_replace_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent__t.html">event_t</a> *</td>          <td class="paramname"><span class="paramname"><em>event</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlf__token__t.html">lf_token_t</a> *</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Replace the token on the specified event with the specified token and free the old token. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The event. </td></tr>
    <tr><td class="paramname">token</td><td>The token. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga485e4339d95d23ae5bcbb06c244e7145" name="ga485e4339d95d23ae5bcbb06c244e7145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga485e4339d95d23ae5bcbb06c244e7145">&#9670;&#160;</a></span>lf_sched_done_with_reaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_sched_done_with_reaction </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>worker_number</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreaction__t.html">reaction_t</a> *</td>          <td class="paramname"><span class="paramname"><em>done_reaction</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="scheduler_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/threaded/scheduler.h</a>&gt;</code></p>

<p>Inform the scheduler that worker thread 'worker_number' is done executing the 'done_reaction'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worker_number</td><td>The worker number for the worker thread that has finished executing 'done_reaction'. </td></tr>
    <tr><td class="paramname">done_reaction</td><td>The reaction that is done. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2139bc60dc5be91d750d5e877af07843" name="ga2139bc60dc5be91d750d5e877af07843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2139bc60dc5be91d750d5e877af07843">&#9670;&#160;</a></span>lf_sched_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_sched_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlf__scheduler__t.html">lf_scheduler_t</a> *</td>          <td class="paramname"><span class="paramname"><em>scheduler</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="scheduler_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/threaded/scheduler.h</a>&gt;</code></p>

<p>Free the memory used by the scheduler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scheduler</td><td>The scheduler</td></tr>
  </table>
  </dd>
</dl>
<p>This must be called when the scheduler is no longer needed. </p>

</div>
</div>
<a id="ga95107b668caa59d5bca9fff1af21e7fb" name="ga95107b668caa59d5bca9fff1af21e7fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95107b668caa59d5bca9fff1af21e7fb">&#9670;&#160;</a></span>lf_sched_get_ready_reaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structreaction__t.html">reaction_t</a> * lf_sched_get_ready_reaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlf__scheduler__t.html">lf_scheduler_t</a> *</td>          <td class="paramname"><span class="paramname"><em>scheduler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>worker_number</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="scheduler_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/threaded/scheduler.h</a>&gt;</code></p>

<p>Ask the scheduler for one more reaction. </p>
<p>This function blocks until it can return a ready reaction for worker thread 'worker_number' or it is time for the worker thread to stop and exit (where a NULL value would be returned). This function assumes that the environment mutex is not locked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scheduler</td><td>The scheduler </td></tr>
    <tr><td class="paramname">worker_number</td><td>For the calling worker thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reaction_t* A reaction for the worker to execute. NULL if the calling worker thread should exit. </dd></dl>

</div>
</div>
<a id="ga0ebe8d7670a73a6572c7152d31e1fb62" name="ga0ebe8d7670a73a6572c7152d31e1fb62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ebe8d7670a73a6572c7152d31e1fb62">&#9670;&#160;</a></span>lf_sched_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_sched_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>number_of_workers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsched__params__t.html">sched_params_t</a> *</td>          <td class="paramname"><span class="paramname"><em>parameters</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="scheduler_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/threaded/scheduler.h</a>&gt;</code></p>

<p>Initialize the scheduler. </p>
<p>This has to be called before other functions of the scheduler can be used. If the scheduler is already initialized, this will be a no-op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment in which we should initialize the scheduler </td></tr>
    <tr><td class="paramname">number_of_workers</td><td>Indicate how many workers this scheduler will be managing. </td></tr>
    <tr><td class="paramname">parameters</td><td>Pointer to a <span class="tt"><a class="el" href="structsched__params__t.html" title="Struct representing the most common scheduler parameters.">sched_params_t</a></span> struct containing additional scheduler parameters. Can be NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga28927b8a184fe101ad414ed866c49148" name="ga28927b8a184fe101ad414ed866c49148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28927b8a184fe101ad414ed866c49148">&#9670;&#160;</a></span>lf_schedule_trigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ga3608c2ed78ba97535f8d82a489846305">trigger_handle_t</a> lf_schedule_trigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrigger__t.html">trigger_t</a> *</td>          <td class="paramname"><span class="paramname"><em>trigger</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a></td>          <td class="paramname"><span class="paramname"><em>delay</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlf__token__t.html">lf_token_t</a> *</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="schedule_8h.html">/Users/runner/work/reactor-c/reactor-c/include/api/schedule.h</a>&gt;</code></p>

<p>Schedule the specified trigger to execute in the specified environment with given delay and token. </p>
<p>This is the most flexible version of the schedule functions and is used in the implementation of many of the others. End users would rarely use it.</p>
<p>This will schedule the specified trigger at env-&gt;current_tag.time plus the offset of the specified trigger plus the delay. The value is required to be either NULL or a pointer to a token wrapping the payload. The token carries a reference count, and when the reference count decrements to 0, the will be freed. Hence, it is essential that the payload be in memory allocated using malloc.</p>
<p>There are several conditions under which this function will not actually put an event on the event queue and decrement the reference count of the token (if there is one), which could result in the payload being freed. In all cases, this function returns 0. Otherwise, it returns a handle to the scheduled trigger, which is an integer greater than 0.</p>
<p>The first condition is that a stop has been requested and the trigger offset plus the extra delay is greater than zero. The second condition is that the trigger offset plus the extra delay is greater that the requested stop time (timeout). A third condition is that the trigger argument is null. Also, an event might not be scheduled if the trigger is an action with a <span class="tt">min_spacing</span> parameter. See the documentation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment in which to schedule the event. </td></tr>
    <tr><td class="paramname">trigger</td><td>The action or timer to be triggered. </td></tr>
    <tr><td class="paramname">delay</td><td>Offset of the event release. </td></tr>
    <tr><td class="paramname">token</td><td>The token payload. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A handle to the event, or 0 if no event was scheduled, or -1 for error. </dd></dl>

</div>
</div>
<a id="gae47f6c04336244e4739c05f5c38e730e" name="gae47f6c04336244e4739c05f5c38e730e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae47f6c04336244e4739c05f5c38e730e">&#9670;&#160;</a></span>lf_scheduler_trigger_reaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_scheduler_trigger_reaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlf__scheduler__t.html">lf_scheduler_t</a> *</td>          <td class="paramname"><span class="paramname"><em>scheduler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreaction__t.html">reaction_t</a> *</td>          <td class="paramname"><span class="paramname"><em>reaction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>worker_number</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="scheduler_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/threaded/scheduler.h</a>&gt;</code></p>

<p>Inform the scheduler that worker thread 'worker_number' would like to trigger 'reaction' at the current tag. </p>
<p>If a worker number is not available (e.g., this function is not called by a worker thread), -1 should be passed as the 'worker_number'.</p>
<p>The scheduler will ensure that the same reaction is not triggered twice in the same tag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scheduler</td><td>The scheduler. </td></tr>
    <tr><td class="paramname">reaction</td><td>The reaction to trigger at the current tag. </td></tr>
    <tr><td class="paramname">worker_number</td><td>The ID of the worker that is making this call. 0 should be used if there is only one worker (e.g., when the program is using the single-threaded C runtime). -1 is used for an anonymous call in a context where a worker number does not make sense (e.g., the caller is not a worker thread). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7bafb933f1e301b37b5d5164229f386d" name="ga7bafb933f1e301b37b5d5164229f386d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bafb933f1e301b37b5d5164229f386d">&#9670;&#160;</a></span>lf_semaphore_acquire()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_semaphore_acquire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlf__semaphore__t.html">lf_semaphore_t</a> *</td>          <td class="paramname"><span class="paramname"><em>semaphore</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__semaphore_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/lf_semaphore.h</a>&gt;</code></p>

<p>Acquire the 'semaphore'. </p>
<p>Will block if count is 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semaphore</td><td>Instance of a semaphore. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1207a7db6221cb49ccf260c31e57a5ac" name="ga1207a7db6221cb49ccf260c31e57a5ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1207a7db6221cb49ccf260c31e57a5ac">&#9670;&#160;</a></span>lf_semaphore_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_semaphore_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlf__semaphore__t.html">lf_semaphore_t</a> *</td>          <td class="paramname"><span class="paramname"><em>semaphore</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__semaphore_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/lf_semaphore.h</a>&gt;</code></p>

<p>Destroy the 'semaphore'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semaphore</td><td>Instance of a semaphore. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4f13b40eede6275ac98d4ea1e2802e00" name="ga4f13b40eede6275ac98d4ea1e2802e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f13b40eede6275ac98d4ea1e2802e00">&#9670;&#160;</a></span>lf_semaphore_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlf__semaphore__t.html">lf_semaphore_t</a> * lf_semaphore_new </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__semaphore_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/lf_semaphore.h</a>&gt;</code></p>

<p>Create a new semaphore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The count to start with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lf_semaphore_t* Can be NULL on error. </dd></dl>

</div>
</div>
<a id="gae924daa1634a8e574b5b8966d54158dd" name="gae924daa1634a8e574b5b8966d54158dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae924daa1634a8e574b5b8966d54158dd">&#9670;&#160;</a></span>lf_semaphore_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_semaphore_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlf__semaphore__t.html">lf_semaphore_t</a> *</td>          <td class="paramname"><span class="paramname"><em>semaphore</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__semaphore_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/lf_semaphore.h</a>&gt;</code></p>

<p>Release the 'semaphore' and add 'i' to its count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semaphore</td><td>Instance of a semaphore </td></tr>
    <tr><td class="paramname">i</td><td>The count to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2e816883471b300567e207c16471502e" name="ga2e816883471b300567e207c16471502e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e816883471b300567e207c16471502e">&#9670;&#160;</a></span>lf_semaphore_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_semaphore_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlf__semaphore__t.html">lf_semaphore_t</a> *</td>          <td class="paramname"><span class="paramname"><em>semaphore</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__semaphore_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/lf_semaphore.h</a>&gt;</code></p>

<p>Wait on the 'semaphore' if count is 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">semaphore</td><td>Instance of a semaphore. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2dce2075be67995107b9d8f2d5e20551" name="ga2dce2075be67995107b9d8f2d5e20551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2dce2075be67995107b9d8f2d5e20551">&#9670;&#160;</a></span>lf_set_default_command_line_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_set_default_command_line_options </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Generated function that optionally sets default command-line options. </p>

</div>
</div>
<a id="ga07b2e94bcac5d7bcfd47d4eaf35a4977" name="ga07b2e94bcac5d7bcfd47d4eaf35a4977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07b2e94bcac5d7bcfd47d4eaf35a4977">&#9670;&#160;</a></span>lf_set_stop_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_set_stop_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor.h</a>&gt;</code></p>

<p>Set the stop tag if it is less than the stop tag of the specified environment. </p>
<dl class="section note"><dt>Note</dt><dd>In threaded programs, the environment's mutex must be locked before calling this function. </dd></dl>

</div>
</div>
<a id="ga1e92870e0258c83da4c541e4ec48169b" name="ga1e92870e0258c83da4c541e4ec48169b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e92870e0258c83da4c541e4ec48169b">&#9670;&#160;</a></span>lf_tag_latest_earlier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtag__t.html">tag_t</a> lf_tag_latest_earlier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tag_8h.html">/Users/runner/work/reactor-c/reactor-c/tag/api/tag.h</a>&gt;</code></p>

<p>Return the greatest tag earlier than the given tag. </p>
<p>If the given tag is <span class="tt">FOREVER_TAG</span> or <span class="tt">NEVER_TAG</span>, however, just return the given tag. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>The tag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad149603053631bf4d6236426ddae2bde" name="gad149603053631bf4d6236426ddae2bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad149603053631bf4d6236426ddae2bde">&#9670;&#160;</a></span>lf_terminate_execution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_terminate_execution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Function that is called when the program is about to exit. </p>
<p>This function will be invoked after all shutdown actions have completed. For non-federated programs, the code generator generates an empty function to implement this. For federated programs, the function is implemented in federate.c.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment in which we are executing </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga751c9fce12510f5bb98d862f57077396" name="ga751c9fce12510f5bb98d862f57077396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga751c9fce12510f5bb98d862f57077396">&#9670;&#160;</a></span>lf_time_logical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a> lf_time_logical </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tag_8h.html">/Users/runner/work/reactor-c/reactor-c/tag/api/tag.h</a>&gt;</code></p>

<p>Return the current logical time in nanoseconds. </p>
<p>On many platforms, this is the number of nanoseconds since January 1, 1970, but it is actually platform dependent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment from which we want the current logical time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A time instant. </dd></dl>

</div>
</div>
<a id="ga6faad0d905f7135352f511bc235425e1" name="ga6faad0d905f7135352f511bc235425e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6faad0d905f7135352f511bc235425e1">&#9670;&#160;</a></span>lf_time_logical_elapsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> lf_time_logical_elapsed </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>env</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tag_8h.html">/Users/runner/work/reactor-c/reactor-c/tag/api/tag.h</a>&gt;</code></p>

<p>Return the elapsed logical time in nanoseconds since the start of execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment from which we want the elapsed logical time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A time interval. </dd></dl>

</div>
</div>
<a id="ga5a16cb75bd134d91bbb002b5d1ddc45c" name="ga5a16cb75bd134d91bbb002b5d1ddc45c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a16cb75bd134d91bbb002b5d1ddc45c">&#9670;&#160;</a></span>lf_tracing_check_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_tracing_check_version </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tracepoint_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/tracepoint.h</a>&gt;</code></p>

<p>Check if the tracing library is compatible with the current version of the runtime. </p>

</div>
</div>
<a id="ga1b64e4e645fbebb1a3b132280b2c5b35" name="ga1b64e4e645fbebb1a3b132280b2c5b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b64e4e645fbebb1a3b132280b2c5b35">&#9670;&#160;</a></span>lf_vprint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_vprint </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/util.h</a>&gt;</code></p>

<p>varargs alternative of "lf_print" </p>

</div>
</div>
<a id="ga334870b12bd4bc49b9da219e31225477" name="ga334870b12bd4bc49b9da219e31225477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga334870b12bd4bc49b9da219e31225477">&#9670;&#160;</a></span>lf_vprint_debug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void void void lf_vprint_debug </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/util.h</a>&gt;</code></p>

<p>varargs alternative of "lf_print_debug" </p>

</div>
</div>
<a id="ga3d1b4e46f0394bbf2e74c4eabfd8923f" name="ga3d1b4e46f0394bbf2e74c4eabfd8923f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d1b4e46f0394bbf2e74c4eabfd8923f">&#9670;&#160;</a></span>lf_vprint_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_vprint_error </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/util.h</a>&gt;</code></p>

<p>varargs alternative of "lf_print_error" </p>

</div>
</div>
<a id="ga698eb7c2ecf514b4afa1ab7ab598eea2" name="ga698eb7c2ecf514b4afa1ab7ab598eea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga698eb7c2ecf514b4afa1ab7ab598eea2">&#9670;&#160;</a></span>lf_vprint_error_and_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void void void lf_vprint_error_and_exit </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/util.h</a>&gt;</code></p>

<p>varargs alternative of "lf_print_error_and_exit" </p>

</div>
</div>
<a id="ga8432a03751d354b69ffe2f5b8c664654" name="ga8432a03751d354b69ffe2f5b8c664654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8432a03751d354b69ffe2f5b8c664654">&#9670;&#160;</a></span>lf_vprint_log()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void void lf_vprint_log </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/util.h</a>&gt;</code></p>

<p>varargs alternative of "lf_print_log" </p>

</div>
</div>
<a id="ga47f8c72c1407daae89508da09273d655" name="ga47f8c72c1407daae89508da09273d655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47f8c72c1407daae89508da09273d655">&#9670;&#160;</a></span>lf_vprint_warning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void void lf_vprint_warning </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list</td>          <td class="paramname"><span class="paramname"><em>args</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/util.h</a>&gt;</code></p>

<p>varargs alternative of "lf_print_warning" </p>

</div>
</div>
<a id="gad96dd94446ff66184dcf0f8f65cdb4f0" name="gad96dd94446ff66184dcf0f8f65cdb4f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad96dd94446ff66184dcf0f8f65cdb4f0">&#9670;&#160;</a></span>logical_tag_complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void logical_tag_complete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>tag_to_send</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="scheduler__sync__tag__advance_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/threaded/scheduler_sync_tag_advance.h</a>&gt;</code></p>

<p>Placeholder for code-generated function that will, in a federated execution, be used to coordinate the advancement of tag. </p>
<p>It will notify the runtime infrastructure (RTI) that all reactions at the specified logical tag have completed.</p>
<p>This function should be called only while holding the mutex lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag_to_send</td><td>The tag to send. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaab4b6c3ec9d416bc0965f81ff9194736" name="gaab4b6c3ec9d416bc0965f81ff9194736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab4b6c3ec9d416bc0965f81ff9194736">&#9670;&#160;</a></span>mixed_radix_incr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mixed_radix_incr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmixed__radix__int__t.html">mixed_radix_int_t</a> *</td>          <td class="paramname"><span class="paramname"><em>mixed</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mixed__radix_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/mixed_radix.h</a>&gt;</code></p>

<p>Increment the mixed radix number by one according to the permutation matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mixed</td><td>A pointer to the mixed-radix number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9405e2b2a5f79663f57c7933a2cec2b8" name="ga9405e2b2a5f79663f57c7933a2cec2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9405e2b2a5f79663f57c7933a2cec2b8">&#9670;&#160;</a></span>mixed_radix_parent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mixed_radix_parent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmixed__radix__int__t.html">mixed_radix_int_t</a> *</td>          <td class="paramname"><span class="paramname"><em>mixed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mixed__radix_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/mixed_radix.h</a>&gt;</code></p>

<p>Return the int value of a mixed-radix number after dropping the first n digits. </p>
<p>If n is larger than or equal to the size of the mixed-radix number, then return 0. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mixed</td><td>A pointer to the mixed-radix number. </td></tr>
    <tr><td class="paramname">n</td><td>The number of digits to drop, which is assumed to be greater than or equal to 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0402727c71049a3b200c1f9fbfdfcb41" name="ga0402727c71049a3b200c1f9fbfdfcb41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0402727c71049a3b200c1f9fbfdfcb41">&#9670;&#160;</a></span>mixed_radix_to_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mixed_radix_to_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmixed__radix__int__t.html">mixed_radix_int_t</a> *</td>          <td class="paramname"><span class="paramname"><em>mixed</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="mixed__radix_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/mixed_radix.h</a>&gt;</code></p>

<p>Return the int value of a mixed-radix number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mixed</td><td>A pointer to the mixed-radix number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa0f5e3d63138880461b1f04dc2d4f48a" name="gaa0f5e3d63138880461b1f04dc2d4f48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0f5e3d63138880461b1f04dc2d4f48a">&#9670;&#160;</a></span>pqueue_empty_into()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqueue_empty_into </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpqueue__t.html">pqueue_t</a> **</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpqueue__t.html">pqueue_t</a> **</td>          <td class="paramname"><span class="paramname"><em>src</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__base_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_base.h</a>&gt;</code></p>

<p>Empty 'src' into 'dest'. </p>
<p>As an optimization, this function might swap 'src' and 'dest'. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The queue to fill up </td></tr>
    <tr><td class="paramname">src</td><td>The queue to empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9bb9cb0e5f41746db17b7581f5fe0559" name="ga9bb9cb0e5f41746db17b7581f5fe0559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bb9cb0e5f41746db17b7581f5fe0559">&#9670;&#160;</a></span>pqueue_find_equal_same_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * pqueue_find_equal_same_priority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpqueue__t.html">pqueue_t</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__base_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_base.h</a>&gt;</code></p>

<p>Return an entry with the same priority (determined by <span class="tt">cmppri</span>) that matches the supplied entry (determined by <span class="tt">eqelem</span>) or <span class="tt">NULL</span> if there is no such entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue </td></tr>
    <tr><td class="paramname">e</td><td>The entry to compare against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if no matching event has been found, otherwise the entry </dd></dl>

</div>
</div>
<a id="ga23a8f91001427f237232082b8d25e81a" name="ga23a8f91001427f237232082b8d25e81a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23a8f91001427f237232082b8d25e81a">&#9670;&#160;</a></span>pqueue_find_same_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * pqueue_find_same_priority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpqueue__t.html">pqueue_t</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__base_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_base.h</a>&gt;</code></p>

<p>Return an entry with the same priority as the specified entry or NULL if there is no such entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue </td></tr>
    <tr><td class="paramname">e</td><td>The entry to compare against </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if no matching event has been found, otherwise the entry </dd></dl>

</div>
</div>
<a id="gacceacc4429dd9cd31d5af09f3f473cb0" name="gacceacc4429dd9cd31d5af09f3f473cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacceacc4429dd9cd31d5af09f3f473cb0">&#9670;&#160;</a></span>pqueue_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqueue_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpqueue__t.html">pqueue_t</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__base_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_base.h</a>&gt;</code></p>

<p>Free all memory used by the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5a4c8b51b16189ab4a687f562733b1a5" name="ga5a4c8b51b16189ab4a687f562733b1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a4c8b51b16189ab4a687f562733b1a5">&#9670;&#160;</a></span>pqueue_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpqueue__t.html">pqueue_t</a> * pqueue_init </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga1c3f02694b2a0ec19584c395a88bb6f9">pqueue_cmp_pri_f</a></td>          <td class="paramname"><span class="paramname"><em>cmppri</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gaa84f0100faf971295df5aed226c390a6">pqueue_get_pri_f</a></td>          <td class="paramname"><span class="paramname"><em>getpri</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga31ca7927983005bd7866021819ad7037">pqueue_get_pos_f</a></td>          <td class="paramname"><span class="paramname"><em>getpos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gafdc8f52cbc45181ef375df22917bc4f9">pqueue_set_pos_f</a></td>          <td class="paramname"><span class="paramname"><em>setpos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga664f0abcd86c8089468869aa3dc6e535">pqueue_eq_elem_f</a></td>          <td class="paramname"><span class="paramname"><em>eqelem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga884902da135214a6167f1536ad4ed4bc">pqueue_print_entry_f</a></td>          <td class="paramname"><span class="paramname"><em>prt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__base_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_base.h</a>&gt;</code></p>

<p>Allocate and initialize a priority queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The initial estimate of the number of queue items for which memory should be preallocated </td></tr>
    <tr><td class="paramname">cmppri</td><td>The callback function to run to compare two elements This callback should return -1 for 'lower', 0 for 'same', and 1 for 'higher', or vice versa if reverse priority is desired </td></tr>
    <tr><td class="paramname">getpri</td><td>The callback function to run to set a score to an element </td></tr>
    <tr><td class="paramname">getpos</td><td>The callback function to get the current element's position </td></tr>
    <tr><td class="paramname">setpos</td><td>The callback function to set the current element's position </td></tr>
    <tr><td class="paramname">eqelem</td><td>the callback function to check equivalence of entries </td></tr>
    <tr><td class="paramname">prt</td><td>the callback function to print an element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The handle or NULL for insufficent memory. </dd></dl>

</div>
</div>
<a id="gaddd8cdfbc8c47b8cdd7eb4c4560de7aa" name="gaddd8cdfbc8c47b8cdd7eb4c4560de7aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddd8cdfbc8c47b8cdd7eb4c4560de7aa">&#9670;&#160;</a></span>pqueue_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pqueue_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpqueue__t.html">pqueue_t</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__base_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_base.h</a>&gt;</code></p>

<p>Insert an element into the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue </td></tr>
    <tr><td class="paramname">d</td><td>The data to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd></dl>

</div>
</div>
<a id="ga9ec5c03203b587dbb92f8d2a977aa7e4" name="ga9ec5c03203b587dbb92f8d2a977aa7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ec5c03203b587dbb92f8d2a977aa7e4">&#9670;&#160;</a></span>pqueue_peek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * pqueue_peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpqueue__t.html">pqueue_t</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__base_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_base.h</a>&gt;</code></p>

<p>Access highest-ranking item without removing it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on error, otherwise the entry </dd></dl>

</div>
</div>
<a id="ga66bce8cd2c2afa804405005798498823" name="ga66bce8cd2c2afa804405005798498823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66bce8cd2c2afa804405005798498823">&#9670;&#160;</a></span>pqueue_pop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * pqueue_pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpqueue__t.html">pqueue_t</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__base_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_base.h</a>&gt;</code></p>

<p>Pop the highest-ranking item from the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on error, otherwise the entry </dd></dl>

</div>
</div>
<a id="ga1bc71ac57e101d48d91c75ecbf8fc278" name="ga1bc71ac57e101d48d91c75ecbf8fc278"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bc71ac57e101d48d91c75ecbf8fc278">&#9670;&#160;</a></span>pqueue_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqueue_print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpqueue__t.html">pqueue_t</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga884902da135214a6167f1536ad4ed4bc">pqueue_print_entry_f</a></td>          <td class="paramname"><span class="paramname"><em>print</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__base_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_base.h</a>&gt;</code></p>

<p>Print the contents of the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue. </td></tr>
    <tr><td class="paramname">print</td><td>The callback function to print the entry or NULL to use the default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga921be3b49e4021888c595188438fdf7a" name="ga921be3b49e4021888c595188438fdf7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga921be3b49e4021888c595188438fdf7a">&#9670;&#160;</a></span>pqueue_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pqueue_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpqueue__t.html">pqueue_t</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__base_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_base.h</a>&gt;</code></p>

<p>Remove an item from the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue </td></tr>
    <tr><td class="paramname">e</td><td>The entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd></dl>

</div>
</div>
<a id="gae0cf88c8360a5f08ada81feaaeb40505" name="gae0cf88c8360a5f08ada81feaaeb40505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0cf88c8360a5f08ada81feaaeb40505">&#9670;&#160;</a></span>pqueue_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pqueue_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpqueue__t.html">pqueue_t</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__base_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_base.h</a>&gt;</code></p>

<p>Return the size of the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac6870c37fb36dcb65dbfcceff317cab4" name="gac6870c37fb36dcb65dbfcceff317cab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6870c37fb36dcb65dbfcceff317cab4">&#9670;&#160;</a></span>pqueue_tag_compare()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pqueue_tag_compare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gad8239ddc32134716f57e54bb972f6bf0">pqueue_pri_t</a></td>          <td class="paramname"><span class="paramname"><em>priority1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gad8239ddc32134716f57e54bb972f6bf0">pqueue_pri_t</a></td>          <td class="paramname"><span class="paramname"><em>priority2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__tag_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_tag.h</a>&gt;</code></p>

<p>Callback comparison function for the tag-based priority queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority1</td><td>A pointer to a <a class="el" href="structpqueue__tag__element__t.html" title="The type for an element in a priority queue that is sorted by tag.">pqueue_tag_element_t</a>, cast to <a class="el" href="#gad8239ddc32134716f57e54bb972f6bf0" title="Priority data type.">pqueue_pri_t</a>. </td></tr>
    <tr><td class="paramname">priority2</td><td>A pointer to a <a class="el" href="structpqueue__tag__element__t.html" title="The type for an element in a priority queue that is sorted by tag.">pqueue_tag_element_t</a>, cast to <a class="el" href="#gad8239ddc32134716f57e54bb972f6bf0" title="Priority data type.">pqueue_pri_t</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if the first argument is less than second, 0 if the two arguments are the same, and 1 otherwise. </dd></dl>

</div>
</div>
<a id="gafe428033cb2f6915828e75efb90edc44" name="gafe428033cb2f6915828e75efb90edc44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe428033cb2f6915828e75efb90edc44">&#9670;&#160;</a></span>pqueue_tag_find_equal_same_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpqueue__tag__element__t.html">pqueue_tag_element_t</a> * pqueue_tag_find_equal_same_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpqueue__tag__element__t.html">pqueue_tag_element_t</a> *</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__tag_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_tag.h</a>&gt;</code></p>

<p>Return an item with the same tag (<span class="tt">cmppri</span> returns 0) that matches the supplied element (<span class="tt">eqelem</span> returns non-zero) or NULL if there is none. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue. </td></tr>
    <tr><td class="paramname">e</td><td>The element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An entry with the specified tag or NULL if there isn't one. </dd></dl>

</div>
</div>
<a id="ga91d0568eb488ec1255fc1146163934fa" name="ga91d0568eb488ec1255fc1146163934fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91d0568eb488ec1255fc1146163934fa">&#9670;&#160;</a></span>pqueue_tag_find_with_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpqueue__tag__element__t.html">pqueue_tag_element_t</a> * pqueue_tag_find_with_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__tag_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_tag.h</a>&gt;</code></p>

<p>Return the first item with the specified tag or NULL if there is none. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue. </td></tr>
    <tr><td class="paramname">t</td><td>The tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An entry with the specified tag or NULL if there isn't one. </dd></dl>

</div>
</div>
<a id="ga7eee6edbbb90d5a0bb072a728dd3c7f2" name="ga7eee6edbbb90d5a0bb072a728dd3c7f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7eee6edbbb90d5a0bb072a728dd3c7f2">&#9670;&#160;</a></span>pqueue_tag_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqueue_tag_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__tag_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_tag.h</a>&gt;</code></p>

<p>Free all memory used by the queue including elements that are marked dynamic. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga30b038fea77adb97ee6e0ab13af55ede" name="ga30b038fea77adb97ee6e0ab13af55ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30b038fea77adb97ee6e0ab13af55ede">&#9670;&#160;</a></span>pqueue_tag_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> * pqueue_tag_init </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>initial_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__tag_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_tag.h</a>&gt;</code></p>

<p>Create a priority queue sorted by tags. </p>
<p>The elements of the priority queue will be of type <a class="el" href="structpqueue__tag__element__t.html" title="The type for an element in a priority queue that is sorted by tag.">pqueue_tag_element_t</a>. The caller should call <a class="el" href="#ga7eee6edbbb90d5a0bb072a728dd3c7f2" title="Free all memory used by the queue including elements that are marked dynamic.">pqueue_tag_free()</a> when finished with the queue. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initial_size</td><td>The initial size of the priority queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A dynamically allocated priority queue or NULL if memory allocation fails. </dd></dl>

</div>
</div>
<a id="ga7194e0ba9a3cd659f5e94f5a46c3d1f1" name="ga7194e0ba9a3cd659f5e94f5a46c3d1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7194e0ba9a3cd659f5e94f5a46c3d1f1">&#9670;&#160;</a></span>pqueue_tag_init_customize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> * pqueue_tag_init_customize </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>initial_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga1c3f02694b2a0ec19584c395a88bb6f9">pqueue_cmp_pri_f</a></td>          <td class="paramname"><span class="paramname"><em>cmppri</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga664f0abcd86c8089468869aa3dc6e535">pqueue_eq_elem_f</a></td>          <td class="paramname"><span class="paramname"><em>eqelem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ga884902da135214a6167f1536ad4ed4bc">pqueue_print_entry_f</a></td>          <td class="paramname"><span class="paramname"><em>prt</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__tag_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_tag.h</a>&gt;</code></p>

<p>Create a priority queue that stores elements with a particular payload. </p>
<p>The elements of the priority queue will be of type <a class="el" href="structpqueue__tag__element__t.html" title="The type for an element in a priority queue that is sorted by tag.">pqueue_tag_element_t</a>. The caller should call <a class="el" href="#ga7eee6edbbb90d5a0bb072a728dd3c7f2">pqueue_tag_free()</a> when finished with the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initial_size</td><td>The initial size of the priority queue. </td></tr>
    <tr><td class="paramname">cmppri</td><td>The callback function to compare priorities. </td></tr>
    <tr><td class="paramname">eqelem</td><td>The callback function to check equivalence of payloads. </td></tr>
    <tr><td class="paramname">prt</td><td>The callback function to print elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A dynamically allocated priority queue or NULL if memory allocation fails. </dd></dl>

</div>
</div>
<a id="ga7db3de28c457287e689dedc3a6dc20da" name="ga7db3de28c457287e689dedc3a6dc20da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7db3de28c457287e689dedc3a6dc20da">&#9670;&#160;</a></span>pqueue_tag_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pqueue_tag_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpqueue__tag__element__t.html">pqueue_tag_element_t</a> *</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__tag_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_tag.h</a>&gt;</code></p>

<p>Insert an element into the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue. </td></tr>
    <tr><td class="paramname">d</td><td>The element to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd></dl>

</div>
</div>
<a id="ga067e8fdd88be6f660e79744350a74128" name="ga067e8fdd88be6f660e79744350a74128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga067e8fdd88be6f660e79744350a74128">&#9670;&#160;</a></span>pqueue_tag_insert_if_no_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pqueue_tag_insert_if_no_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__tag_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_tag.h</a>&gt;</code></p>

<p>Insert a tag into the queue if the tag is not already in the queue. </p>
<p>This automatically creates a dynamically allocated element in the queue and ensures that if the element is still on the queue when pqueue_tag_free is called, then that memory will be freed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue. </td></tr>
    <tr><td class="paramname">t</td><td>The tag to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, 1 otherwise. </dd></dl>

</div>
</div>
<a id="ga89084b69d8049630eebb8df759c666d0" name="ga89084b69d8049630eebb8df759c666d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89084b69d8049630eebb8df759c666d0">&#9670;&#160;</a></span>pqueue_tag_insert_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pqueue_tag_insert_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__tag_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_tag.h</a>&gt;</code></p>

<p>Insert a tag into the queue. </p>
<p>This automatically creates a dynamically allocated element in the queue and ensures that if the element is still on the queue when pqueue_tag_free is called, then that memory will be freed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue. </td></tr>
    <tr><td class="paramname">t</td><td>The tag to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd></dl>

</div>
</div>
<a id="ga16cbdbb45d26bd5373e258de819cfdd3" name="ga16cbdbb45d26bd5373e258de819cfdd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16cbdbb45d26bd5373e258de819cfdd3">&#9670;&#160;</a></span>pqueue_tag_peek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpqueue__tag__element__t.html">pqueue_tag_element_t</a> * pqueue_tag_peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__tag_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_tag.h</a>&gt;</code></p>

<p>Return highest-ranking item (the one with the least tag) without removing it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on if the queue is empty, otherwise the entry. </dd></dl>

</div>
</div>
<a id="ga9bcecb00b894ad00b07f84940fe7af95" name="ga9bcecb00b894ad00b07f84940fe7af95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bcecb00b894ad00b07f84940fe7af95">&#9670;&#160;</a></span>pqueue_tag_peek_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtag__t.html">tag_t</a> pqueue_tag_peek_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__tag_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_tag.h</a>&gt;</code></p>

<p>Return the least tag in the queue or FOREVER if the queue is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The least tag in the queue or FOREVER if the queue is empty. </dd></dl>

</div>
</div>
<a id="gaf6709c3c3756e65205762a4cf33848be" name="gaf6709c3c3756e65205762a4cf33848be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6709c3c3756e65205762a4cf33848be">&#9670;&#160;</a></span>pqueue_tag_pop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpqueue__tag__element__t.html">pqueue_tag_element_t</a> * pqueue_tag_pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__tag_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_tag.h</a>&gt;</code></p>

<p>Pop the least-tag element from the queue. </p>
<p>If the entry was dynamically allocated, then it is now up to the caller to ensure that it is freed. It will not be freed by pqueue_tag_free. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on error, otherwise the entry </dd></dl>

</div>
</div>
<a id="gaa2144411e9b6d74af078d51078526fe3" name="gaa2144411e9b6d74af078d51078526fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2144411e9b6d74af078d51078526fe3">&#9670;&#160;</a></span>pqueue_tag_pop_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtag__t.html">tag_t</a> pqueue_tag_pop_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__tag_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_tag.h</a>&gt;</code></p>

<p>Pop the least-tag element from the queue and return its tag. </p>
<p>If the queue is empty, return FOREVER_TAG. This function handles freeing the element struct if it was dynamically allocated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on error, otherwise the entry </dd></dl>

</div>
</div>
<a id="gac5612f277391c7129183d2826021c3e3" name="gac5612f277391c7129183d2826021c3e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5612f277391c7129183d2826021c3e3">&#9670;&#160;</a></span>pqueue_tag_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqueue_tag_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpqueue__tag__element__t.html">pqueue_tag_element_t</a> *</td>          <td class="paramname"><span class="paramname"><em>e</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__tag_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_tag.h</a>&gt;</code></p>

<p>Remove an item from the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue. </td></tr>
    <tr><td class="paramname">e</td><td>The entry to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga135a225e2361b815a415607bc1f71e3b" name="ga135a225e2361b815a415607bc1f71e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga135a225e2361b815a415607bc1f71e3b">&#9670;&#160;</a></span>pqueue_tag_remove_up_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqueue_tag_remove_up_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__tag_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_tag.h</a>&gt;</code></p>

<p>Remove items from the queue with tags up to and including the specified tag. </p>
<p>If the specified tag is FOREVER_TAG, then all items will be removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue. </td></tr>
    <tr><td class="paramname">t</td><td>The specified tag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0679a4db1f4d970d9f1048e253b79562" name="ga0679a4db1f4d970d9f1048e253b79562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0679a4db1f4d970d9f1048e253b79562">&#9670;&#160;</a></span>pqueue_tag_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t pqueue_tag_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#gac52d056c47d9595f94d37e95484b3acd">pqueue_tag_t</a> *</td>          <td class="paramname"><span class="paramname"><em>q</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue__tag_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue_tag.h</a>&gt;</code></p>

<p>Return the size of the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga26e33f5180dc5951b3d26094959913b7" name="ga26e33f5180dc5951b3d26094959913b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26e33f5180dc5951b3d26094959913b7">&#9670;&#160;</a></span>print_reaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_reaction </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>reaction</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue.h</a>&gt;</code></p>

<p>Print some information about the given reaction. </p>
<p>This only prints something if logging is set to DEBUG. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reaction</td><td>A pointer to a <a class="el" href="structreaction__t.html" title="Reaction activation record to push onto the reaction queue.">reaction_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga80aaf4eeed3e2902f8fe9de80b45777d" name="ga80aaf4eeed3e2902f8fe9de80b45777d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80aaf4eeed3e2902f8fe9de80b45777d">&#9670;&#160;</a></span>process_args()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int process_args </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>[]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Process the command-line arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>The number of command-line arguments. </td></tr>
    <tr><td class="paramname">argv</td><td>The command-line arguments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga648da83816bb67aedeeaa8c10a99ec7a" name="ga648da83816bb67aedeeaa8c10a99ec7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga648da83816bb67aedeeaa8c10a99ec7a">&#9670;&#160;</a></span>reaction_matches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int reaction_matches </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue.h</a>&gt;</code></p>

<p>Return 1 if the two arguments are identical pointers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First argument. </td></tr>
    <tr><td class="paramname">b</td><td>Second argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeaaa76aeb7d93efc4e0f0c484548af70" name="gaeaaa76aeb7d93efc4e0f0c484548af70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaaa76aeb7d93efc4e0f0c484548af70">&#9670;&#160;</a></span>schedule_output_reactions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void schedule_output_reactions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structreaction__t.html">reaction_t</a> *</td>          <td class="paramname"><span class="paramname"><em>reaction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>worker</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Schedule the output reactions for the specified reaction in the specified environment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment in which we are executing. </td></tr>
    <tr><td class="paramname">reaction</td><td>The reaction. </td></tr>
    <tr><td class="paramname">worker</td><td>The worker number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6f9a4a14de3aa9e560935a57093eb122" name="ga6f9a4a14de3aa9e560935a57093eb122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f9a4a14de3aa9e560935a57093eb122">&#9670;&#160;</a></span>send_next_event_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtag__t.html">tag_t</a> send_next_event_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>wait_for_reply</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__threaded_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/threaded/reactor_threaded.h</a>&gt;</code></p>

<p>Send the next event tag. </p>
<p>In a federated execution with centralized coordination, this function returns a tag that is less than or equal to the specified tag when, as far as the federation is concerned, it is safe to commit to advancing to the returned tag. That is, all incoming network messages with tags less than the returned tag have been received. In unfederated execution or in federated execution with decentralized control, this function returns the specified tag immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>Environment within which we are executing. </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to which to advance. </td></tr>
    <tr><td class="paramname">wait_for_reply</td><td>If true, wait for the RTI to respond. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tag to which it is safe to advance. </dd></dl>

</div>
</div>
<a id="ga463f89e588c57a76b4cd6a0e633a94b4" name="ga463f89e588c57a76b4cd6a0e633a94b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga463f89e588c57a76b4cd6a0e633a94b4">&#9670;&#160;</a></span>set_reaction_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_reaction_position </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>reaction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="pqueue_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/pqueue.h</a>&gt;</code></p>

<p>Set the given reaction's position in the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reaction</td><td>A pointer to a <a class="el" href="structreaction__t.html" title="Reaction activation record to push onto the reaction queue.">reaction_t</a>. </td></tr>
    <tr><td class="paramname">pos</td><td>The position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5ee7c21a8b90bb09784f221c1de4d9c9" name="ga5ee7c21a8b90bb09784f221c1de4d9c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ee7c21a8b90bb09784f221c1de4d9c9">&#9670;&#160;</a></span>should_stop_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool should_stop_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlf__scheduler__t.html">lf_scheduler_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sched</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="scheduler__sync__tag__advance_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/threaded/scheduler_sync_tag_advance.h</a>&gt;</code></p>

<p>Return true if the worker should stop now; false otherwise. </p>
<p>This function assumes the caller holds the mutex lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sched</td><td>The scheduler instance to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa329f59a16f5617b5195f2c05872c9e9" name="gaa329f59a16f5617b5195f2c05872c9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa329f59a16f5617b5195f2c05872c9e9">&#9670;&#160;</a></span>termination()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void termination </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__common_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/reactor_common.h</a>&gt;</code></p>

<p>Perform final wrap-up on exit. </p>
<p>This function will be registered to execute on exit. It reports elapsed logical and physical times and reports if any memory allocated for tokens has not been freed. </p>

</div>
</div>
<a id="ga896f27619ab0582d5a70d8f613567671" name="ga896f27619ab0582d5a70d8f613567671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga896f27619ab0582d5a70d8f613567671">&#9670;&#160;</a></span>tracepoint_schedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tracepoint_schedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrigger__t.html">trigger_t</a> *</td>          <td class="paramname"><span class="paramname"><em>trigger</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a></td>          <td class="paramname"><span class="paramname"><em>extra_delay</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tracepoint_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/tracepoint.h</a>&gt;</code></p>

<p>Trace a call to schedule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">env</td><td>The environment in which we are executing </td></tr>
    <tr><td class="paramname">trigger</td><td>Pointer to the <a class="el" href="structtrigger__t.html" title="Trigger struct representing an output, timer, action, or input.">trigger_t</a> struct for the trigger. </td></tr>
    <tr><td class="paramname">extra_delay</td><td>The extra delay passed to schedule(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga70c4ab92f00f9bcc31e4d696db1c0526" name="ga70c4ab92f00f9bcc31e4d696db1c0526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70c4ab92f00f9bcc31e4d696db1c0526">&#9670;&#160;</a></span>wait_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wait_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__API.html#ga827080fd3c574bad5a32db9f7c367587">instant_t</a></td>          <td class="paramname"><span class="paramname"><em>wait_until_time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lf_cond_t *</td>          <td class="paramname"><span class="paramname"><em>condition</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="reactor__threaded_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/threaded/reactor_threaded.h</a>&gt;</code></p>

<p>Wait until physical time matches or exceeds the time of the specified tag. </p>
<p>If -fast is given, there will be no wait.</p>
<p>If an event is put on the event queue during the wait, then the wait is interrupted and this function returns false. It also returns false if the timeout time is reached before the wait has completed. Note this this could return true even if the a new event was placed on the queue. This will occur if that event time matches or exceeds the specified time.</p>
<p>The mutex lock associated with the condition argument is assumed to be held by the calling thread. This mutex is released while waiting. If the current physical time has already passed the specified time, then this function immediately returns true and the mutex is not released.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wait_until_time</td><td>The time to wait until physical time matches it. </td></tr>
    <tr><td class="paramname">condition</td><td>A condition variable that can interrupt the wait. The mutex associated with this condition variable will be released during the wait.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return false if the wait is interrupted either because of an event queue signal or if the wait time was interrupted early by reaching the stop time, if one was specified. Return true if the full wait time was reached. </dd></dl>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="gaf4657205de7da8f0bf7b346985a983fc" name="gaf4657205de7da8f0bf7b346985a983fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4657205de7da8f0bf7b346985a983fc">&#9670;&#160;</a></span>_lf_count_token_allocations</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int _lf_count_token_allocations</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="lf__token_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/lf_token.h</a>&gt;</code></p>

<p>Counter used to issue a warning if memory is allocated for tokens and never freed. </p>
<p>Note that every trigger will have one token allocated for it. That token is not counted because it is not expected to be freed. </p>

</div>
</div>
<a id="ga3c7bddddb86913975950acdcf8bfef2a" name="ga3c7bddddb86913975950acdcf8bfef2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c7bddddb86913975950acdcf8bfef2a">&#9670;&#160;</a></span>_lf_my_fed_id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t _lf_my_fed_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="util_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/utils/util.h</a>&gt;</code></p>

<p>The ID of this federate. </p>
<p>For a non-federated execution, this will be -1. For a federated execution, it will be assigned when the generated function <a class="el" href="#ga52ffa06ff177dc19d33713beb2ff344e" title="Generated function that produces a table containing all triggers (i.e., inputs, timers,...">_lf_initialize_trigger_objects()</a> is called. </p><dl class="section see"><dt>See also</dt><dd>xtext/org.icyphy.linguafranca/src/org/icyphy/generator/CGenerator.xtend. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on <span class="timestamp"></span> for reactor-c by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
