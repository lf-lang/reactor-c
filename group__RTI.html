<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>reactor-c: RTI</title>
<link rel="icon" href="favicon.ico" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">reactor-c<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">C Runtime for Lingua Franca</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__RTI.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">RTI </div></div>
</div><!--header-->
<div class="contents">

<p>Functions for the runtime infrastructure for federated execution.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-files" class="groupheader"><a id="files" name="files"></a>
Files</h2></td></tr>
<tr class="memitem:README_2Emd" id="r_README_2Emd"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="core_2federated_2RTI_2README_8md.html">README.md</a></td></tr>
<tr class="memitem:rti_5Fcommon_2Eh" id="r_rti_5Fcommon_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__common_8h.html">rti_common.h</a></td></tr>
<tr class="memdesc:rti__common_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common declarations for runtime infrastructure (RTI) for scheduling enclaves and distributed Lingua Franca programs. <br /></td></tr>
<tr class="memitem:rti_5Flocal_2Eh" id="r_rti_5Flocal_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__local_8h.html">rti_local.h</a></td></tr>
<tr class="memdesc:rti__local_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file declares functions used to implement scheduling enclaves. <br /></td></tr>
<tr class="memitem:rti_5Fremote_2Eh" id="r_rti_5Fremote_2Eh"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rti__remote_8h.html">rti_remote.h</a></td></tr>
<tr class="memdesc:rti__remote_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declarations for runtime infrastructure (RTI) for distributed Lingua Franca programs. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:enclave_5Finfo_5Ft" id="r_enclave_5Finfo_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structenclave__info__t.html">enclave_info_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding information about each enclave in the program.  <a href="structenclave__info__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:federate_5Finfo_5Ft" id="r_federate_5Finfo_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfederate__info__t.html">federate_info_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a federate known to the RTI, including its runtime state, mode of execution, and connectivity with other federates.  <a href="structfederate__info__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:minimum_5Fdelay_5Ft" id="r_minimum_5Fdelay_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structminimum__delay__t.html">minimum_delay_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct for minimum delays from upstream nodes.  <a href="structminimum__delay__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:rti_5Fcommon_5Ft" id="r_rti_5Fcommon_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrti__common__t.html">rti_common_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common RTI data structure for both remote standalone RTI and local RTI used in enclaved execution.  <a href="structrti__common__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:rti_5Flocal_5Ft" id="r_rti_5Flocal_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrti__local__t.html">rti_local_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding information about the local RTI.  <a href="structrti__local__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:rti_5Fremote_5Ft" id="r_rti_5Fremote_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrti__remote__t.html">rti_remote_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that an RTI instance uses to keep track of its own and its corresponding federates' state.  <a href="structrti__remote__t.html#details">More...</a><br /></td></tr>
<tr class="memitem:scheduling_5Fnode_5Ft" id="r_scheduling_5Fnode_5Ft"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscheduling__node__t.html">scheduling_node_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the scheduling nodes coordinated by the RTI.  <a href="structscheduling__node__t.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga0066544a32ab71d5601142354230452b" id="r_ga0066544a32ab71d5601142354230452b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0066544a32ab71d5601142354230452b">MAX_TIME_FOR_REPLY_TO_STOP_REQUEST</a>&#160;&#160;&#160;<a class="el" href="group__Constants.html#ga30e47c4dd44d168c2982d3ec1d4e0825">SEC</a>(30)</td></tr>
<tr class="memdesc:ga0066544a32ab71d5601142354230452b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time allowed for federates to reply to stop request.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga39e986990bfc20d1512b61ab119ce628" id="r_ga39e986990bfc20d1512b61ab119ce628"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="#ga9705d612b9ce908ee485e92eb3f2769f">clock_sync_stat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga39e986990bfc20d1512b61ab119ce628">clock_sync_stat</a></td></tr>
<tr class="memdesc:ga39e986990bfc20d1512b61ab119ce628"><td class="mdescLeft">&#160;</td><td class="mdescRight">The status of clock synchronization.  <br /></td></tr>
<tr class="memitem:ga1567a1034e3b7c6528bc12fdc04a4c71" id="r_ga1567a1034e3b7c6528bc12fdc04a4c71"><td class="memItemLeft" align="right" valign="top">typedef struct enclave_info_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1567a1034e3b7c6528bc12fdc04a4c71">enclave_info_t</a></td></tr>
<tr class="memdesc:ga1567a1034e3b7c6528bc12fdc04a4c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding information about each enclave in the program.  <br /></td></tr>
<tr class="memitem:ga50856f252373f4c456a34c6f26d385ce" id="r_ga50856f252373f4c456a34c6f26d385ce"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="#ga83ca4d4187a661b1395c9f860d61c97e">execution_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga50856f252373f4c456a34c6f26d385ce">execution_mode_t</a></td></tr>
<tr class="memdesc:ga50856f252373f4c456a34c6f26d385ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mode of execution of a federate.  <br /></td></tr>
<tr class="memitem:gacd32a9389f9882becea414555263cde1" id="r_gacd32a9389f9882becea414555263cde1"><td class="memItemLeft" align="right" valign="top">typedef struct federate_info_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacd32a9389f9882becea414555263cde1">federate_info_t</a></td></tr>
<tr class="memdesc:gacd32a9389f9882becea414555263cde1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about a federate known to the RTI, including its runtime state, mode of execution, and connectivity with other federates.  <br /></td></tr>
<tr class="memitem:ga51ee50491dd9db504fa075ae0b490e14" id="r_ga51ee50491dd9db504fa075ae0b490e14"><td class="memItemLeft" align="right" valign="top">typedef struct minimum_delay_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga51ee50491dd9db504fa075ae0b490e14">minimum_delay_t</a></td></tr>
<tr class="memdesc:ga51ee50491dd9db504fa075ae0b490e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct for minimum delays from upstream nodes.  <br /></td></tr>
<tr class="memitem:ga2df16421461ba5b27dc451b16865b750" id="r_ga2df16421461ba5b27dc451b16865b750"><td class="memItemLeft" align="right" valign="top">typedef struct rti_common_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2df16421461ba5b27dc451b16865b750">rti_common_t</a></td></tr>
<tr class="memdesc:ga2df16421461ba5b27dc451b16865b750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common RTI data structure for both remote standalone RTI and local RTI used in enclaved execution.  <br /></td></tr>
<tr class="memitem:ga224a440a405fa3f473a27ad65edca186" id="r_ga224a440a405fa3f473a27ad65edca186"><td class="memItemLeft" align="right" valign="top">typedef struct rti_remote_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga224a440a405fa3f473a27ad65edca186">rti_remote_t</a></td></tr>
<tr class="memdesc:ga224a440a405fa3f473a27ad65edca186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that an RTI instance uses to keep track of its own and its corresponding federates' state.  <br /></td></tr>
<tr class="memitem:ga991b71a39df8e306998cbc9d15f9e381" id="r_ga991b71a39df8e306998cbc9d15f9e381"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="#ga2c9591789f1d6afd603e0330e13f3744">scheduling_node_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga991b71a39df8e306998cbc9d15f9e381">scheduling_node_state_t</a></td></tr>
<tr class="memdesc:ga991b71a39df8e306998cbc9d15f9e381"><td class="mdescLeft">&#160;</td><td class="mdescRight">State of the scheduling node during execution.  <br /></td></tr>
<tr class="memitem:gad4b7689a045ef99a1c86753731fb8836" id="r_gad4b7689a045ef99a1c86753731fb8836"><td class="memItemLeft" align="right" valign="top">typedef struct scheduling_node_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad4b7689a045ef99a1c86753731fb8836">scheduling_node_t</a></td></tr>
<tr class="memdesc:gad4b7689a045ef99a1c86753731fb8836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the scheduling nodes coordinated by the RTI.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga9705d612b9ce908ee485e92eb3f2769f" id="r_ga9705d612b9ce908ee485e92eb3f2769f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9705d612b9ce908ee485e92eb3f2769f">clock_sync_stat</a> { <a class="el" href="#gga9705d612b9ce908ee485e92eb3f2769fafef85b2461484e7a55ae3f50d3ca996c">clock_sync_off</a>
, <a class="el" href="#gga9705d612b9ce908ee485e92eb3f2769faf21c0b4c30338f2717ebc9f53fa34558">clock_sync_init</a>
, <a class="el" href="#gga9705d612b9ce908ee485e92eb3f2769fa8423b23ffffdfc03fcb3f68cf4007531">clock_sync_on</a>
 }</td></tr>
<tr class="memdesc:ga9705d612b9ce908ee485e92eb3f2769f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The status of clock synchronization.  <a href="#ga9705d612b9ce908ee485e92eb3f2769f">More...</a><br /></td></tr>
<tr class="memitem:ga83ca4d4187a661b1395c9f860d61c97e" id="r_ga83ca4d4187a661b1395c9f860d61c97e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga83ca4d4187a661b1395c9f860d61c97e">execution_mode_t</a> { <a class="el" href="#gga83ca4d4187a661b1395c9f860d61c97eaf84c11ba888e499a8a282a3e6f5de7de">FAST</a>
, <a class="el" href="#gga83ca4d4187a661b1395c9f860d61c97eadbd89a052eecc45eaa443bcbecc7c5e4">REALTIME</a>
 }</td></tr>
<tr class="memdesc:ga83ca4d4187a661b1395c9f860d61c97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mode of execution of a federate.  <a href="#ga83ca4d4187a661b1395c9f860d61c97e">More...</a><br /></td></tr>
<tr class="memitem:ga2c9591789f1d6afd603e0330e13f3744" id="r_ga2c9591789f1d6afd603e0330e13f3744"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2c9591789f1d6afd603e0330e13f3744">scheduling_node_state_t</a> { <a class="el" href="#gga2c9591789f1d6afd603e0330e13f3744a96c582a5af213ca7fb34f970d83875f5">NOT_CONNECTED</a>
, <a class="el" href="#gga2c9591789f1d6afd603e0330e13f3744a440c8b08fdd77c2aa90283c06dbe465a">GRANTED</a>
, <a class="el" href="#gga2c9591789f1d6afd603e0330e13f3744a1869818fd53ff519eb8e429301bdff73">PENDING</a>
 }</td></tr>
<tr class="memdesc:ga2c9591789f1d6afd603e0330e13f3744"><td class="mdescLeft">&#160;</td><td class="mdescRight">State of the scheduling node during execution.  <a href="#ga2c9591789f1d6afd603e0330e13f3744">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5f9802f30e0cb2ceedf199ebb35c946b" id="r_ga5f9802f30e0cb2ceedf199ebb35c946b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5f9802f30e0cb2ceedf199ebb35c946b">_logical_tag_complete</a> (<a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *e, <a class="el" href="structtag__t.html">tag_t</a> completed)</td></tr>
<tr class="memdesc:ga5f9802f30e0cb2ceedf199ebb35c946b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the completed tag for the specified node.  <br /></td></tr>
<tr class="memitem:ga272b481a0cc2f86f21c75e8efa19a551" id="r_ga272b481a0cc2f86f21c75e8efa19a551"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga272b481a0cc2f86f21c75e8efa19a551">clock_synchronization_thread</a> (void *noargs)</td></tr>
<tr class="memdesc:ga272b481a0cc2f86f21c75e8efa19a551"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (quasi-)periodic thread that performs clock synchronization with each federate.  <br /></td></tr>
<tr class="memitem:ga00b9b047401cd08937d21ae84ee2ef79" id="r_ga00b9b047401cd08937d21ae84ee2ef79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga00b9b047401cd08937d21ae84ee2ef79">downstream_next_event_tag</a> (<a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *node, uint16_t node_sending_new_net_id)</td></tr>
<tr class="memdesc:ga00b9b047401cd08937d21ae84ee2ef79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the specified scheduling node is needed to receive a downstream next event tag (DNET), and, if so, return the details.  <br /></td></tr>
<tr class="memitem:gad5f8cfd324d9403aa800a88020276969" id="r_gad5f8cfd324d9403aa800a88020276969"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad5f8cfd324d9403aa800a88020276969">earliest_future_incoming_message_tag</a> (<a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *e)</td></tr>
<tr class="memdesc:gad5f8cfd324d9403aa800a88020276969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a node (enclave or federate), find the tag of the earliest possible incoming message (EIMT) from upstream enclaves or federates, which will be the smallest upstream NET plus the least delay.  <br /></td></tr>
<tr class="memitem:gadaad58c39361263d511f49b0952bcaee" id="r_gadaad58c39361263d511f49b0952bcaee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadaad58c39361263d511f49b0952bcaee">eimt_strict</a> (<a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *e)</td></tr>
<tr class="memdesc:gadaad58c39361263d511f49b0952bcaee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a node (enclave or federate), find the earliest incoming message tag (EIMT) from any immediately upstream node that is not part of zero-delay cycle (ZDC).  <br /></td></tr>
<tr class="memitem:gae0b396a4e41b93505274bbfb55b7a510" id="r_gae0b396a4e41b93505274bbfb55b7a510"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae0b396a4e41b93505274bbfb55b7a510">federate_info_thread_TCP</a> (void *fed)</td></tr>
<tr class="memdesc:gae0b396a4e41b93505274bbfb55b7a510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread handling TCP communication with a federate.  <br /></td></tr>
<tr class="memitem:gaa202c053941549eb84d77776c67b5137" id="r_gaa202c053941549eb84d77776c67b5137"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa202c053941549eb84d77776c67b5137">free_local_rti</a> ()</td></tr>
<tr class="memdesc:gaa202c053941549eb84d77776c67b5137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free memory associated with the local the RTI and the local RTI iself.  <br /></td></tr>
<tr class="memitem:gaa8f3d17093904564d4a1eebd526a2164" id="r_gaa8f3d17093904564d4a1eebd526a2164"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa8f3d17093904564d4a1eebd526a2164">free_scheduling_nodes</a> (<a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> **scheduling_nodes, uint16_t number_of_scheduling_nodes)</td></tr>
<tr class="memdesc:gaa8f3d17093904564d4a1eebd526a2164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free dynamically allocated memory on the scheduling nodes and the scheduling node array itself.  <br /></td></tr>
<tr class="memitem:gac81735735888368a08b2b16cf8d440ea" id="r_gac81735735888368a08b2b16cf8d440ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac81735735888368a08b2b16cf8d440ea">get_dnet_candidate</a> (<a class="el" href="structtag__t.html">tag_t</a> next_event_tag, <a class="el" href="structtag__t.html">tag_t</a> minimum_delay)</td></tr>
<tr class="memdesc:gac81735735888368a08b2b16cf8d440ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the tag g that is the latest tag that satisfies lf_tag_add(g, minimum_delay) &lt; next_event_tag.  <br /></td></tr>
<tr class="memitem:ga3f4f3aae4aa73c87569b677f2c0957b7" id="r_ga3f4f3aae4aa73c87569b677f2c0957b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3f4f3aae4aa73c87569b677f2c0957b7">handle_address_ad</a> (uint16_t federate_id)</td></tr>
<tr class="memdesc:ga3f4f3aae4aa73c87569b677f2c0957b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle address advertisement messages (.  <br /></td></tr>
<tr class="memitem:ga0424648d3659346e9c7c645cca35d470" id="r_ga0424648d3659346e9c7c645cca35d470"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0424648d3659346e9c7c645cca35d470">handle_address_query</a> (uint16_t fed_id)</td></tr>
<tr class="memdesc:ga0424648d3659346e9c7c645cca35d470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle address query messages.  <br /></td></tr>
<tr class="memitem:ga1ffcd0bc844a81aa45cfaa4e1e697ef1" id="r_ga1ffcd0bc844a81aa45cfaa4e1e697ef1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1ffcd0bc844a81aa45cfaa4e1e697ef1">handle_latest_tag_confirmed</a> (<a class="el" href="structfederate__info__t.html">federate_info_t</a> *fed)</td></tr>
<tr class="memdesc:ga1ffcd0bc844a81aa45cfaa4e1e697ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle a latest tag confirmed (LTC) message.  <br /></td></tr>
<tr class="memitem:gad68a1cbfc6299b091b8f7b0e97f8bb5b" id="r_gad68a1cbfc6299b091b8f7b0e97f8bb5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad68a1cbfc6299b091b8f7b0e97f8bb5b">handle_next_event_tag</a> (<a class="el" href="structfederate__info__t.html">federate_info_t</a> *fed)</td></tr>
<tr class="memdesc:gad68a1cbfc6299b091b8f7b0e97f8bb5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle a next event tag (NET) message.  <br /></td></tr>
<tr class="memitem:gad69c4cb2041a1a262bce829c49ae9246" id="r_gad69c4cb2041a1a262bce829c49ae9246"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad69c4cb2041a1a262bce829c49ae9246">handle_physical_clock_sync_message</a> (<a class="el" href="structfederate__info__t.html">federate_info_t</a> *my_fed, <a class="el" href="group__Federated.html#ga54c375e3893ff5969d20df65b90c8335">socket_type_t</a> socket_type)</td></tr>
<tr class="memdesc:gad69c4cb2041a1a262bce829c49ae9246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle clock synchronization T3 messages from federates.  <br /></td></tr>
<tr class="memitem:ga307edbac9eb75981db9dc7c0fcfc73e6" id="r_ga307edbac9eb75981db9dc7c0fcfc73e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga307edbac9eb75981db9dc7c0fcfc73e6">handle_port_absent_message</a> (<a class="el" href="structfederate__info__t.html">federate_info_t</a> *sending_federate, unsigned char *buffer)</td></tr>
<tr class="memdesc:ga307edbac9eb75981db9dc7c0fcfc73e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle a port absent message being received rom a federate via the RIT.  <br /></td></tr>
<tr class="memitem:ga41ca594227fe9bb62f67b21cc2e7b6d6" id="r_ga41ca594227fe9bb62f67b21cc2e7b6d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga41ca594227fe9bb62f67b21cc2e7b6d6">handle_stop_request_message</a> (<a class="el" href="structfederate__info__t.html">federate_info_t</a> *fed)</td></tr>
<tr class="memdesc:ga41ca594227fe9bb62f67b21cc2e7b6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle a MSG_TYPE_STOP_REQUEST message.  <br /></td></tr>
<tr class="memitem:gac4d4e5a1df9c31133d942a6e50e4c163" id="r_gac4d4e5a1df9c31133d942a6e50e4c163"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac4d4e5a1df9c31133d942a6e50e4c163">handle_stop_request_reply</a> (<a class="el" href="structfederate__info__t.html">federate_info_t</a> *fed)</td></tr>
<tr class="memdesc:gac4d4e5a1df9c31133d942a6e50e4c163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle a MSG_TYPE_STOP_REQUEST_REPLY message.  <br /></td></tr>
<tr class="memitem:ga9fca6a5c7e73b40db2f6ef6f50c7a112" id="r_ga9fca6a5c7e73b40db2f6ef6f50c7a112"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9fca6a5c7e73b40db2f6ef6f50c7a112">handle_timed_message</a> (<a class="el" href="structfederate__info__t.html">federate_info_t</a> *sending_federate, unsigned char *buffer)</td></tr>
<tr class="memdesc:ga9fca6a5c7e73b40db2f6ef6f50c7a112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle a timed message being received from a federate by the RTI to relay to another federate.  <br /></td></tr>
<tr class="memitem:ga0a2eadb2f35483bc7ce62a5845110330" id="r_ga0a2eadb2f35483bc7ce62a5845110330"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0a2eadb2f35483bc7ce62a5845110330">handle_timestamp</a> (<a class="el" href="structfederate__info__t.html">federate_info_t</a> *my_fed)</td></tr>
<tr class="memdesc:ga0a2eadb2f35483bc7ce62a5845110330"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to handle timestamp messages.  <br /></td></tr>
<tr class="memitem:gaf934cc54979bcf640a7868377daab5e2" id="r_gaf934cc54979bcf640a7868377daab5e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf934cc54979bcf640a7868377daab5e2">initialize_enclave_info</a> (<a class="el" href="structenclave__info__t.html">enclave_info_t</a> *enclave, int idx, <a class="el" href="structenvironment__t.html">environment_t</a> *env)</td></tr>
<tr class="memdesc:gaf934cc54979bcf640a7868377daab5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the enclave object.  <br /></td></tr>
<tr class="memitem:gab32a595d53f125832570251023d10c46" id="r_gab32a595d53f125832570251023d10c46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab32a595d53f125832570251023d10c46">initialize_federate</a> (<a class="el" href="structfederate__info__t.html">federate_info_t</a> *fed, uint16_t id)</td></tr>
<tr class="memdesc:gab32a595d53f125832570251023d10c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the federate with the specified ID.  <br /></td></tr>
<tr class="memitem:ga167855af2f7fb010609dceda0a59b43d" id="r_ga167855af2f7fb010609dceda0a59b43d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga167855af2f7fb010609dceda0a59b43d">initialize_local_rti</a> (<a class="el" href="structenvironment__t.html">environment_t</a> *envs, int num_envs)</td></tr>
<tr class="memdesc:ga167855af2f7fb010609dceda0a59b43d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically create and initialize the local RTI.  <br /></td></tr>
<tr class="memitem:ga0aefafd71cb0b057a604a04f1af61174" id="r_ga0aefafd71cb0b057a604a04f1af61174"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0aefafd71cb0b057a604a04f1af61174">initialize_RTI</a> (<a class="el" href="structrti__remote__t.html">rti_remote_t</a> *rti)</td></tr>
<tr class="memdesc:ga0aefafd71cb0b057a604a04f1af61174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the _RTI instance.  <br /></td></tr>
<tr class="memitem:gadd2a2ad3c8a9f8e6cde5ecbcb83d7e8d" id="r_gadd2a2ad3c8a9f8e6cde5ecbcb83d7e8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadd2a2ad3c8a9f8e6cde5ecbcb83d7e8d">initialize_rti_common</a> (<a class="el" href="structrti__common__t.html">rti_common_t</a> *rti_common)</td></tr>
<tr class="memdesc:gadd2a2ad3c8a9f8e6cde5ecbcb83d7e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the fields of the rti_common struct.  <br /></td></tr>
<tr class="memitem:ga9a27b6186b947cfacb408dc3a0829f6e" id="r_ga9a27b6186b947cfacb408dc3a0829f6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9a27b6186b947cfacb408dc3a0829f6e">initialize_scheduling_node</a> (<a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *e, uint16_t id)</td></tr>
<tr class="memdesc:ga9a27b6186b947cfacb408dc3a0829f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the scheduling node with the specified ID.  <br /></td></tr>
<tr class="memitem:ga5f7d50fc74bdc38f889c38109c406468" id="r_ga5f7d50fc74bdc38f889c38109c406468"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5f7d50fc74bdc38f889c38109c406468">invalidate_min_delays</a> ()</td></tr>
<tr class="memdesc:ga5f7d50fc74bdc38f889c38109c406468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate the <span class="tt">min_delays</span>, <span class="tt">num_min_delays</span>, and the fields that indicate cycles of all nodes.  <br /></td></tr>
<tr class="memitem:gab38455d4faf77b4d86dcd77976afe1f1" id="r_gab38455d4faf77b4d86dcd77976afe1f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab38455d4faf77b4d86dcd77976afe1f1">is_in_cycle</a> (<a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *node)</td></tr>
<tr class="memdesc:gab38455d4faf77b4d86dcd77976afe1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the node is in a cycle (possibly a zero-delay cycle).  <br /></td></tr>
<tr class="memitem:ga94101c5bfb54d670a8f47f448e351a34" id="r_ga94101c5bfb54d670a8f47f448e351a34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga94101c5bfb54d670a8f47f448e351a34">is_in_zero_delay_cycle</a> (<a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *node)</td></tr>
<tr class="memdesc:ga94101c5bfb54d670a8f47f448e351a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the node is in a zero-delay cycle.  <br /></td></tr>
<tr class="memitem:ga52a9225745a4b229aee86fcc4617b904" id="r_ga52a9225745a4b229aee86fcc4617b904"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga52a9225745a4b229aee86fcc4617b904">lf_connect_to_federates</a> (int socket_descriptor)</td></tr>
<tr class="memdesc:ga52a9225745a4b229aee86fcc4617b904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for one incoming connection request from each federate, and, upon receiving it, create a thread to communicate with that federate.  <br /></td></tr>
<tr class="memitem:ga06003604b6defab443bdfe34f3ab17ee" id="r_ga06003604b6defab443bdfe34f3ab17ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga06003604b6defab443bdfe34f3ab17ee">lf_get_downstream_of</a> (int enclave_id, uint16_t **result)</td></tr>
<tr class="memdesc:ga06003604b6defab443bdfe34f3ab17ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the array of ids of enclaves directly downstream of the specified enclave.  <br /></td></tr>
<tr class="memitem:gaaba4ae9dd32581f9f34a7a81d9c7791c" id="r_gaaba4ae9dd32581f9f34a7a81d9c7791c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaaba4ae9dd32581f9f34a7a81d9c7791c">lf_get_upstream_delay_of</a> (int enclave_id, <a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> **result)</td></tr>
<tr class="memdesc:gaaba4ae9dd32581f9f34a7a81d9c7791c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the delays on the connections to direct upstream enclaves.  <br /></td></tr>
<tr class="memitem:ga8f432bb04e691f66f4f81cbbecb741ed" id="r_ga8f432bb04e691f66f4f81cbbecb741ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8f432bb04e691f66f4f81cbbecb741ed">lf_get_upstream_of</a> (int enclave_id, uint16_t **result)</td></tr>
<tr class="memdesc:ga8f432bb04e691f66f4f81cbbecb741ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the array of ids of enclaves directly upstream of the specified enclave.  <br /></td></tr>
<tr class="memitem:gaa057279652cc77f238cc73d0fc0e705e" id="r_gaa057279652cc77f238cc73d0fc0e705e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa057279652cc77f238cc73d0fc0e705e">notify_advance_grant_if_safe</a> (<a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *e)</td></tr>
<tr class="memdesc:gaa057279652cc77f238cc73d0fc0e705e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either send to a federate or unblock an enclave to give it a tag.  <br /></td></tr>
<tr class="memitem:ga0903cfa1c0fa064824b445c099cd2aa6" id="r_ga0903cfa1c0fa064824b445c099cd2aa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0903cfa1c0fa064824b445c099cd2aa6">notify_downstream_advance_grant_if_safe</a> (<a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *e, bool visited[])</td></tr>
<tr class="memdesc:ga0903cfa1c0fa064824b445c099cd2aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For all scheduling nodes downstream of the specified node, determine whether they should be notified of a TAG or PTAG and notify them if so.  <br /></td></tr>
<tr class="memitem:gae38c64692f527911c9cc748c03d2246d" id="r_gae38c64692f527911c9cc748c03d2246d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae38c64692f527911c9cc748c03d2246d">notify_downstream_next_event_tag</a> (<a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *e, <a class="el" href="structtag__t.html">tag_t</a> tag)</td></tr>
<tr class="memdesc:gae38c64692f527911c9cc748c03d2246d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify a downstream next event tag (DNET) signal to the specified scheduling node.  <br /></td></tr>
<tr class="memitem:gab226921e491807e98a406487cfdf6335" id="r_gab226921e491807e98a406487cfdf6335"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab226921e491807e98a406487cfdf6335">notify_provisional_tag_advance_grant</a> (<a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *e, <a class="el" href="structtag__t.html">tag_t</a> tag)</td></tr>
<tr class="memdesc:gab226921e491807e98a406487cfdf6335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify a provisional tag advance grant (PTAG) message to the specified scheduling node.  <br /></td></tr>
<tr class="memitem:ga21a88113d348968980a137c9e4e4148e" id="r_ga21a88113d348968980a137c9e4e4148e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga21a88113d348968980a137c9e4e4148e">notify_tag_advance_grant</a> (<a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *e, <a class="el" href="structtag__t.html">tag_t</a> tag)</td></tr>
<tr class="memdesc:ga21a88113d348968980a137c9e4e4148e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify a tag advance grant (TAG) message to the specified scheduling node.  <br /></td></tr>
<tr class="memitem:ga80aaf4eeed3e2902f8fe9de80b45777d" id="r_ga80aaf4eeed3e2902f8fe9de80b45777d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga80aaf4eeed3e2902f8fe9de80b45777d">process_args</a> (int argc, const char *argv[])</td></tr>
<tr class="memdesc:ga80aaf4eeed3e2902f8fe9de80b45777d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process the command-line arguments.  <br /></td></tr>
<tr class="memitem:gad7d4392b21b300612a5239fbb1ffa274" id="r_gad7d4392b21b300612a5239fbb1ffa274"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad7d4392b21b300612a5239fbb1ffa274">process_clock_sync_args</a> (int argc, const char *argv[])</td></tr>
<tr class="memdesc:gad7d4392b21b300612a5239fbb1ffa274"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process command-line arguments related to clock synchronization.  <br /></td></tr>
<tr class="memitem:gac6af5f2343ecf9ed87cdbebd98b94271" id="r_gac6af5f2343ecf9ed87cdbebd98b94271"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac6af5f2343ecf9ed87cdbebd98b94271">respond_to_erroneous_connections</a> (void *nothing)</td></tr>
<tr class="memdesc:gac6af5f2343ecf9ed87cdbebd98b94271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread to respond to new connections, which could be federates of other federations who are attempting to join the wrong federation.  <br /></td></tr>
<tr class="memitem:gafa27405a96dae1488b670aa25fc8ad1b" id="r_gafa27405a96dae1488b670aa25fc8ad1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gafa27405a96dae1488b670aa25fc8ad1b">rti_logical_tag_complete_locked</a> (<a class="el" href="structenclave__info__t.html">enclave_info_t</a> *enclave, <a class="el" href="structtag__t.html">tag_t</a> completed)</td></tr>
<tr class="memdesc:gafa27405a96dae1488b670aa25fc8ad1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inform the local RTI that <span class="tt">enclave</span> has completed tag <span class="tt">completed</span>.  <br /></td></tr>
<tr class="memitem:ga48640596070ecfb23f94532363b5cd6a" id="r_ga48640596070ecfb23f94532363b5cd6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtag__t.html">tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga48640596070ecfb23f94532363b5cd6a">rti_next_event_tag_locked</a> (<a class="el" href="structenclave__info__t.html">enclave_info_t</a> *enclave, <a class="el" href="structtag__t.html">tag_t</a> next_event_tag)</td></tr>
<tr class="memdesc:ga48640596070ecfb23f94532363b5cd6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the local RTI of a next event tag (NET).  <br /></td></tr>
<tr class="memitem:gaf921c9092b09500768f94e41b3a7c8f4" id="r_gaf921c9092b09500768f94e41b3a7c8f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf921c9092b09500768f94e41b3a7c8f4">rti_update_other_net_locked</a> (<a class="el" href="structenclave__info__t.html">enclave_info_t</a> *src, <a class="el" href="structenclave__info__t.html">enclave_info_t</a> *target, <a class="el" href="structtag__t.html">tag_t</a> net)</td></tr>
<tr class="memdesc:gaf921c9092b09500768f94e41b3a7c8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify the local RTI to update the next event tag (NET) of a target enclave.  <br /></td></tr>
<tr class="memitem:ga5b16bd2ead60426e3ace71eca1cfede5" id="r_ga5b16bd2ead60426e3ace71eca1cfede5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5b16bd2ead60426e3ace71eca1cfede5">send_physical_clock</a> (unsigned char message_type, <a class="el" href="structfederate__info__t.html">federate_info_t</a> *fed, <a class="el" href="group__Federated.html#ga54c375e3893ff5969d20df65b90c8335">socket_type_t</a> socket_type)</td></tr>
<tr class="memdesc:ga5b16bd2ead60426e3ace71eca1cfede5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take a snapshot of the physical clock time and send it to federate fed_id.  <br /></td></tr>
<tr class="memitem:gac1d01420f22f3dc5dbdef49ffebdb443" id="r_gac1d01420f22f3dc5dbdef49ffebdb443"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac1d01420f22f3dc5dbdef49ffebdb443">send_reject</a> (int *socket_id, unsigned char error_code)</td></tr>
<tr class="memdesc:gac1d01420f22f3dc5dbdef49ffebdb443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a MSG_TYPE_REJECT message to the specified socket and close the socket.  <br /></td></tr>
<tr class="memitem:ga6cc1fe69c154d09d88de1f1c06eb4b0d" id="r_ga6cc1fe69c154d09d88de1f1c06eb4b0d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga6cc1fe69c154d09d88de1f1c06eb4b0d">start_rti_server</a> (uint16_t port)</td></tr>
<tr class="memdesc:ga6cc1fe69c154d09d88de1f1c06eb4b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the socket server for the runtime infrastructure (RTI) and return the socket descriptor.  <br /></td></tr>
<tr class="memitem:gaf849510938f837c74cfe8f843cb7dcb2" id="r_gaf849510938f837c74cfe8f843cb7dcb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtag__advance__grant__t.html">tag_advance_grant_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf849510938f837c74cfe8f843cb7dcb2">tag_advance_grant_if_safe</a> (<a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *e)</td></tr>
<tr class="memdesc:gaf849510938f837c74cfe8f843cb7dcb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the specified scheduling node is eligible for a tag advance grant, (TAG) and, if so, return the details.  <br /></td></tr>
<tr class="memitem:ga13560f0cae54155219f4d8d9c487b0ef" id="r_ga13560f0cae54155219f4d8d9c487b0ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga13560f0cae54155219f4d8d9c487b0ef">tracepoint_rti_from_federate</a> (<a class="el" href="group__Tracing.html#gab02e9e69539d60297cedb38c2193a453">trace_event_t</a> event_type, int fed_id, <a class="el" href="structtag__t.html">tag_t</a> *tag)</td></tr>
<tr class="memdesc:ga13560f0cae54155219f4d8d9c487b0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace RTI receiving a message from a federate.  <br /></td></tr>
<tr class="memitem:ga0da8aecc05366988f8d929118be90bbe" id="r_ga0da8aecc05366988f8d929118be90bbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0da8aecc05366988f8d929118be90bbe">tracepoint_rti_to_federate</a> (<a class="el" href="group__Tracing.html#gab02e9e69539d60297cedb38c2193a453">trace_event_t</a> event_type, int fed_id, <a class="el" href="structtag__t.html">tag_t</a> *tag)</td></tr>
<tr class="memdesc:ga0da8aecc05366988f8d929118be90bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trace RTI sending a message to a federate.  <br /></td></tr>
<tr class="memitem:ga7190c8d1000afb0a5e8898011d041917" id="r_ga7190c8d1000afb0a5e8898011d041917"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7190c8d1000afb0a5e8898011d041917">update_federate_next_event_tag_locked</a> (uint16_t federate_id, <a class="el" href="structtag__t.html">tag_t</a> next_event_tag)</td></tr>
<tr class="memdesc:ga7190c8d1000afb0a5e8898011d041917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the next event tag of federate <span class="tt">federate_id</span>.  <br /></td></tr>
<tr class="memitem:ga93ef5ce52bd47e14977ea3571c1b152b" id="r_ga93ef5ce52bd47e14977ea3571c1b152b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga93ef5ce52bd47e14977ea3571c1b152b">update_min_delays</a> ()</td></tr>
<tr class="memdesc:ga93ef5ce52bd47e14977ea3571c1b152b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If necessary, update the <span class="tt">min_delays</span> and the fields that indicate cycles.  <br /></td></tr>
<tr class="memitem:ga21533a3d64de78b3766016c2166460c9" id="r_ga21533a3d64de78b3766016c2166460c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga21533a3d64de78b3766016c2166460c9">update_scheduling_node_next_event_tag_locked</a> (<a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *e, <a class="el" href="structtag__t.html">tag_t</a> next_event_tag)</td></tr>
<tr class="memdesc:ga21533a3d64de78b3766016c2166460c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the next event tag of an scheduling node.  <br /></td></tr>
<tr class="memitem:ga7f44f474f50286c4ba8c0ebac254bb28" id="r_ga7f44f474f50286c4ba8c0ebac254bb28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7f44f474f50286c4ba8c0ebac254bb28">usage</a> (int argc, const char *argv[])</td></tr>
<tr class="memdesc:ga7f44f474f50286c4ba8c0ebac254bb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a usage message.  <br /></td></tr>
<tr class="memitem:ga005cb43e8e6c7795c8f0db27e2424475" id="r_ga005cb43e8e6c7795c8f0db27e2424475"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga005cb43e8e6c7795c8f0db27e2424475">wait_for_federates</a> (int socket_descriptor)</td></tr>
<tr class="memdesc:ga005cb43e8e6c7795c8f0db27e2424475"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the runtime infrastructure (RTI) interaction with the federates and wait for the federates to exit.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<p>Functions for the runtime infrastructure for federated execution. </p>
<p>This group contains functions for the runtime infrastructure for federated execution. The message types and protocols are defined in <a class="el" href="net__common_8h.html">net_common.h</a>. </p>
<a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="ga0066544a32ab71d5601142354230452b" name="ga0066544a32ab71d5601142354230452b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0066544a32ab71d5601142354230452b">&#9670;&#160;</a></span>MAX_TIME_FOR_REPLY_TO_STOP_REQUEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_TIME_FOR_REPLY_TO_STOP_REQUEST&#160;&#160;&#160;<a class="el" href="group__Constants.html#ga30e47c4dd44d168c2982d3ec1d4e0825">SEC</a>(30)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>Time allowed for federates to reply to stop request. </p>

</div>
</div>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="ga39e986990bfc20d1512b61ab119ce628" name="ga39e986990bfc20d1512b61ab119ce628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39e986990bfc20d1512b61ab119ce628">&#9670;&#160;</a></span>clock_sync_stat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="#ga9705d612b9ce908ee485e92eb3f2769f">clock_sync_stat</a> <a class="el" href="#ga9705d612b9ce908ee485e92eb3f2769f">clock_sync_stat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>The status of clock synchronization. </p>

</div>
</div>
<a id="ga1567a1034e3b7c6528bc12fdc04a4c71" name="ga1567a1034e3b7c6528bc12fdc04a4c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1567a1034e3b7c6528bc12fdc04a4c71">&#9670;&#160;</a></span>enclave_info_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct enclave_info_t enclave_info_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__local_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_local.h</a>&gt;</code></p>

<p>Structure holding information about each enclave in the program. </p>
<p>The first field is the generic scheduling_node_info struct. </p>

</div>
</div>
<a id="ga50856f252373f4c456a34c6f26d385ce" name="ga50856f252373f4c456a34c6f26d385ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50856f252373f4c456a34c6f26d385ce">&#9670;&#160;</a></span>execution_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="#ga83ca4d4187a661b1395c9f860d61c97e">execution_mode_t</a> <a class="el" href="#ga83ca4d4187a661b1395c9f860d61c97e">execution_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__common_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_common.h</a>&gt;</code></p>

<p>Mode of execution of a federate. </p>

</div>
</div>
<a id="gacd32a9389f9882becea414555263cde1" name="gacd32a9389f9882becea414555263cde1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd32a9389f9882becea414555263cde1">&#9670;&#160;</a></span>federate_info_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct federate_info_t federate_info_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>Information about a federate known to the RTI, including its runtime state, mode of execution, and connectivity with other federates. </p>
<p>The list of upstream and downstream federates does not include those that are connected via a "physical" connection (one denoted with ~&gt;) because those connections do not impose any scheduling constraints. </p>

</div>
</div>
<a id="ga51ee50491dd9db504fa075ae0b490e14" name="ga51ee50491dd9db504fa075ae0b490e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51ee50491dd9db504fa075ae0b490e14">&#9670;&#160;</a></span>minimum_delay_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct minimum_delay_t minimum_delay_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__common_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_common.h</a>&gt;</code></p>

<p>Struct for minimum delays from upstream nodes. </p>

</div>
</div>
<a id="ga2df16421461ba5b27dc451b16865b750" name="ga2df16421461ba5b27dc451b16865b750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2df16421461ba5b27dc451b16865b750">&#9670;&#160;</a></span>rti_common_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct rti_common_t rti_common_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__common_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_common.h</a>&gt;</code></p>

<p>Common RTI data structure for both remote standalone RTI and local RTI used in enclaved execution. </p>
<p><a class="el" href="structrti__remote__t.html" title="Structure that an RTI instance uses to keep track of its own and its corresponding federates&#39; state.">rti_remote_t</a> and <a class="el" href="structrti__local__t.html" title="Structure holding information about the local RTI.">rti_local_t</a> will "inherit" from this data structure. The first field is an array of pointers to scheduling nodes. These will be scheduling nodes for the local RTI and federates for the remote RTI. </p>

</div>
</div>
<a id="ga224a440a405fa3f473a27ad65edca186" name="ga224a440a405fa3f473a27ad65edca186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga224a440a405fa3f473a27ad65edca186">&#9670;&#160;</a></span>rti_remote_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct rti_remote_t rti_remote_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>Structure that an RTI instance uses to keep track of its own and its corresponding federates' state. </p>
<p>It is a special case of <span class="tt"><a class="el" href="structrti__common__t.html" title="Common RTI data structure for both remote standalone RTI and local RTI used in enclaved execution.">rti_common_t</a></span> (declared in enclave.h). Inheritence is mimicked by having the first attributes to be the same as of <a class="el" href="structrti__common__t.html" title="Common RTI data structure for both remote standalone RTI and local RTI used in enclaved execution.">rti_common_t</a>, except that scheduling_nodes attribute here is of type <span class="tt">federate_info_t**</span>, while it is of type <span class="tt">scheduling_node_t**</span> in <span class="tt"><a class="el" href="structrti__common__t.html" title="Common RTI data structure for both remote standalone RTI and local RTI used in enclaved execution.">rti_common_t</a></span>.</p>
<dl class="section note"><dt>Note</dt><dd>IMPORTANT: If you make any change to this struct, you MUST also change <a class="el" href="structrti__common__t.html" title="Common RTI data structure for both remote standalone RTI and local RTI used in enclaved execution.">rti_common_t</a> in enclave.h! The change must exactly match. </dd></dl>

</div>
</div>
<a id="ga991b71a39df8e306998cbc9d15f9e381" name="ga991b71a39df8e306998cbc9d15f9e381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga991b71a39df8e306998cbc9d15f9e381">&#9670;&#160;</a></span>scheduling_node_state_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="#ga2c9591789f1d6afd603e0330e13f3744">scheduling_node_state_t</a> <a class="el" href="#ga2c9591789f1d6afd603e0330e13f3744">scheduling_node_state_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__common_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_common.h</a>&gt;</code></p>

<p>State of the scheduling node during execution. </p>

</div>
</div>
<a id="gad4b7689a045ef99a1c86753731fb8836" name="gad4b7689a045ef99a1c86753731fb8836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4b7689a045ef99a1c86753731fb8836">&#9670;&#160;</a></span>scheduling_node_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct scheduling_node_t scheduling_node_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__common_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_common.h</a>&gt;</code></p>

<p>Information about the scheduling nodes coordinated by the RTI. </p>
<p>The abstract scheduling node could either be an enclave or a federate. The information includes its runtime state, mode of execution, and connectivity with other scheduling nodes. The list of upstream and downstream scheduling nodes does not include those that are connected via a "physical" connection (one denoted with ~&gt;) because those connections do not impose any scheduling constraints. </p>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="ga9705d612b9ce908ee485e92eb3f2769f" name="ga9705d612b9ce908ee485e92eb3f2769f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9705d612b9ce908ee485e92eb3f2769f">&#9670;&#160;</a></span>clock_sync_stat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga9705d612b9ce908ee485e92eb3f2769f">clock_sync_stat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>The status of clock synchronization. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9705d612b9ce908ee485e92eb3f2769fafef85b2461484e7a55ae3f50d3ca996c" name="gga9705d612b9ce908ee485e92eb3f2769fafef85b2461484e7a55ae3f50d3ca996c"></a>clock_sync_off&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga9705d612b9ce908ee485e92eb3f2769faf21c0b4c30338f2717ebc9f53fa34558" name="gga9705d612b9ce908ee485e92eb3f2769faf21c0b4c30338f2717ebc9f53fa34558"></a>clock_sync_init&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga9705d612b9ce908ee485e92eb3f2769fa8423b23ffffdfc03fcb3f68cf4007531" name="gga9705d612b9ce908ee485e92eb3f2769fa8423b23ffffdfc03fcb3f68cf4007531"></a>clock_sync_on&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ga83ca4d4187a661b1395c9f860d61c97e" name="ga83ca4d4187a661b1395c9f860d61c97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83ca4d4187a661b1395c9f860d61c97e">&#9670;&#160;</a></span>execution_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga83ca4d4187a661b1395c9f860d61c97e">execution_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__common_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_common.h</a>&gt;</code></p>

<p>Mode of execution of a federate. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga83ca4d4187a661b1395c9f860d61c97eaf84c11ba888e499a8a282a3e6f5de7de" name="gga83ca4d4187a661b1395c9f860d61c97eaf84c11ba888e499a8a282a3e6f5de7de"></a>FAST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga83ca4d4187a661b1395c9f860d61c97eadbd89a052eecc45eaa443bcbecc7c5e4" name="gga83ca4d4187a661b1395c9f860d61c97eadbd89a052eecc45eaa443bcbecc7c5e4"></a>REALTIME&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ga2c9591789f1d6afd603e0330e13f3744" name="ga2c9591789f1d6afd603e0330e13f3744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c9591789f1d6afd603e0330e13f3744">&#9670;&#160;</a></span>scheduling_node_state_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ga2c9591789f1d6afd603e0330e13f3744">scheduling_node_state_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__common_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_common.h</a>&gt;</code></p>

<p>State of the scheduling node during execution. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2c9591789f1d6afd603e0330e13f3744a96c582a5af213ca7fb34f970d83875f5" name="gga2c9591789f1d6afd603e0330e13f3744a96c582a5af213ca7fb34f970d83875f5"></a>NOT_CONNECTED&#160;</td><td class="fielddoc"><p>The scheduling node has not connected. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2c9591789f1d6afd603e0330e13f3744a440c8b08fdd77c2aa90283c06dbe465a" name="gga2c9591789f1d6afd603e0330e13f3744a440c8b08fdd77c2aa90283c06dbe465a"></a>GRANTED&#160;</td><td class="fielddoc"><p>Most recent MSG_TYPE_NEXT_EVENT_TAG has been granted. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2c9591789f1d6afd603e0330e13f3744a1869818fd53ff519eb8e429301bdff73" name="gga2c9591789f1d6afd603e0330e13f3744a1869818fd53ff519eb8e429301bdff73"></a>PENDING&#160;</td><td class="fielddoc"><p>Waiting for upstream scheduling nodes. </p>
</td></tr>
</table>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ga5f9802f30e0cb2ceedf199ebb35c946b" name="ga5f9802f30e0cb2ceedf199ebb35c946b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f9802f30e0cb2ceedf199ebb35c946b">&#9670;&#160;</a></span>_logical_tag_complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _logical_tag_complete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>completed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__common_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_common.h</a>&gt;</code></p>

<p>Update the completed tag for the specified node. </p>
<p>This checks whether any downstream nodes become eligible to receive TAG or PTAG, and sends those signals if appropriate.</p>
<p>The function is prepended with an underscore because a function called <span class="tt">logical_tag_complete</span> is code-generated by the compiler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The scheduling node. </td></tr>
    <tr><td class="paramname">completed</td><td>The completed tag of the scheduling node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga272b481a0cc2f86f21c75e8efa19a551" name="ga272b481a0cc2f86f21c75e8efa19a551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga272b481a0cc2f86f21c75e8efa19a551">&#9670;&#160;</a></span>clock_synchronization_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * clock_synchronization_thread </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>noargs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>A (quasi-)periodic thread that performs clock synchronization with each federate. </p>
<p>This starts by waiting a time given by _RTI.clock_sync_period_ns and then iterates over the federates, performing a complete clock synchronization interaction with each federate before proceeding to the next federate. The interaction starts with this RTI sending a snapshot of its physical clock to the federate (message T1). It then waits for a reply and then sends another snapshot of its physical clock (message T4). It then follows that T4 message with a coded probe message that the federate can use to discard the session if the network is congested.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">noargs</td><td>Ignored (present for compatibility). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL. </dd></dl>

</div>
</div>
<a id="ga00b9b047401cd08937d21ae84ee2ef79" name="ga00b9b047401cd08937d21ae84ee2ef79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00b9b047401cd08937d21ae84ee2ef79">&#9670;&#160;</a></span>downstream_next_event_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtag__t.html">tag_t</a> downstream_next_event_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>node_sending_new_net_id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__common_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_common.h</a>&gt;</code></p>

<p>Determine whether the specified scheduling node is needed to receive a downstream next event tag (DNET), and, if so, return the details. </p>
<p>This function is called upon receiving a NET from one of the specified node's downstream nodes.</p>
<p>This function calculates the minimum tag M over all downstream scheduling nodes of the most recent NET from that node minus the "after delay" (see function get_dnet_candidate). If M is earlier than the startup tag, then set the result as the NEVER_TAG.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The target node that may receive a new DNET. </td></tr>
    <tr><td class="paramname">node_sending_new_net_id</td><td>The ID of the node that sends a new NET. If this node's new NET does not change the DNET value, we can exit this function immediately. If it does, we have to look up the target node's downstream federates to compute the exact new DNET value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If needed, return the tag value. Otherwise, return the NEVER_TAG. </dd></dl>

</div>
</div>
<a id="gad5f8cfd324d9403aa800a88020276969" name="gad5f8cfd324d9403aa800a88020276969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5f8cfd324d9403aa800a88020276969">&#9670;&#160;</a></span>earliest_future_incoming_message_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtag__t.html">tag_t</a> earliest_future_incoming_message_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__common_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_common.h</a>&gt;</code></p>

<p>Given a node (enclave or federate), find the tag of the earliest possible incoming message (EIMT) from upstream enclaves or federates, which will be the smallest upstream NET plus the least delay. </p>
<p>This could be NEVER_TAG if the RTI has not seen a NET from some upstream node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The target node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The earliest possible incoming message tag. </dd></dl>

</div>
</div>
<a id="gadaad58c39361263d511f49b0952bcaee" name="gadaad58c39361263d511f49b0952bcaee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadaad58c39361263d511f49b0952bcaee">&#9670;&#160;</a></span>eimt_strict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtag__t.html">tag_t</a> eimt_strict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__common_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_common.h</a>&gt;</code></p>

<p>Given a node (enclave or federate), find the earliest incoming message tag (EIMT) from any immediately upstream node that is not part of zero-delay cycle (ZDC). </p>
<p>These tags are treated strictly by the RTI when deciding whether to grant a PTAG. Since the upstream node is not part of a ZDC, there is no need to block on the input from that node since we can simply wait for it to complete its tag without chance of introducing a deadlock. This will return FOREVER_TAG if there are no non-ZDC upstream nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The target node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The earliest possible incoming message tag from a non-ZDC upstream node. </dd></dl>

</div>
</div>
<a id="gae0b396a4e41b93505274bbfb55b7a510" name="gae0b396a4e41b93505274bbfb55b7a510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0b396a4e41b93505274bbfb55b7a510">&#9670;&#160;</a></span>federate_info_thread_TCP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * federate_info_thread_TCP </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>fed</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>Thread handling TCP communication with a federate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fed</td><td>A pointer to the federate's struct that has the socket descriptor for the federate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL. </dd></dl>

</div>
</div>
<a id="gaa202c053941549eb84d77776c67b5137" name="gaa202c053941549eb84d77776c67b5137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa202c053941549eb84d77776c67b5137">&#9670;&#160;</a></span>free_local_rti()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_local_rti </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__local_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_local.h</a>&gt;</code></p>

<p>Free memory associated with the local the RTI and the local RTI iself. </p>

</div>
</div>
<a id="gaa8f3d17093904564d4a1eebd526a2164" name="gaa8f3d17093904564d4a1eebd526a2164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8f3d17093904564d4a1eebd526a2164">&#9670;&#160;</a></span>free_scheduling_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_scheduling_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> **</td>          <td class="paramname"><span class="paramname"><em>scheduling_nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>number_of_scheduling_nodes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__common_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_common.h</a>&gt;</code></p>

<p>Free dynamically allocated memory on the scheduling nodes and the scheduling node array itself. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scheduling_nodes</td><td>The scheduling nodes. </td></tr>
    <tr><td class="paramname">number_of_scheduling_nodes</td><td>The number of scheduling nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac81735735888368a08b2b16cf8d440ea" name="gac81735735888368a08b2b16cf8d440ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac81735735888368a08b2b16cf8d440ea">&#9670;&#160;</a></span>get_dnet_candidate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtag__t.html">tag_t</a> get_dnet_candidate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>next_event_tag</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>minimum_delay</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__common_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_common.h</a>&gt;</code></p>

<p>Find the tag g that is the latest tag that satisfies lf_tag_add(g, minimum_delay) &lt; next_event_tag. </p>
<p>This function behaves like the tag subtraction, next_event_tag - minimum_delay. minimum_delay cannot be NEVER.</p>
<p>This function is called in function downstream_next_event_tag. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_event_tag</td><td>The next event tag of a downstream node. </td></tr>
    <tr><td class="paramname">minimum_delay</td><td>The minimum delay between the target upstream node and the downstream node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3f4f3aae4aa73c87569b677f2c0957b7" name="ga3f4f3aae4aa73c87569b677f2c0957b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f4f3aae4aa73c87569b677f2c0957b7">&#9670;&#160;</a></span>handle_address_ad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_address_ad </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>federate_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>Handle address advertisement messages (. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Federated.html#gae004cb4e5add42afe5483f6706e11d35" title="Byte identifying a message advertising the port for the TCP connection server of a federate.">MSG_TYPE_ADDRESS_ADVERTISEMENT</a> in <a class="el" href="net__common_8h.html" title="Common message types and definitions for federated Lingua Franca programs.">net_common.h</a>).</dd></dl>
<p>The federate is expected to send its server port number as the next byte. The RTI will keep a record of this number in the .server_port field of the _RTI.federates[federate_id] array of structs.</p>
<p>The server_hostname and server_ip_addr fields are assigned in <a class="el" href="#ga52a9225745a4b229aee86fcc4617b904" title="Wait for one incoming connection request from each federate, and, upon receiving it,...">lf_connect_to_federates()</a> upon accepting the socket from the remote federate.</p>
<p>This function assumes the caller does not hold the mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">federate_id</td><td>The id of the remote federate that is sending the address advertisement. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0424648d3659346e9c7c645cca35d470" name="ga0424648d3659346e9c7c645cca35d470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0424648d3659346e9c7c645cca35d470">&#9670;&#160;</a></span>handle_address_query()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_address_query </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>fed_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>Handle address query messages. </p>
<p>This function reads the body of a MSG_TYPE_ADDRESS_QUERY (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="net__common_8h.html" title="Common message types and definitions for federated Lingua Franca programs.">net_common.h</a>) message which is the requested destination federate ID and replies with the stored port value for the socket server of that federate. The port values are initialized to -1. If no <a class="el" href="group__Federated.html#gae004cb4e5add42afe5483f6706e11d35" title="Byte identifying a message advertising the port for the TCP connection server of a federate.">MSG_TYPE_ADDRESS_ADVERTISEMENT</a> message has been received from the destination federate, the <a class="el" href="group__RTI.html" title="Functions for the runtime infrastructure for federated execution.">RTI</a> will simply reply with -1 for the port. The sending federate is responsible for checking back with the <a class="el" href="group__RTI.html" title="Functions for the runtime infrastructure for federated execution.">RTI</a> after a period of time.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fed_id</td><td>The federate sending a MSG_TYPE_ADDRESS_QUERY message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1ffcd0bc844a81aa45cfaa4e1e697ef1" name="ga1ffcd0bc844a81aa45cfaa4e1e697ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ffcd0bc844a81aa45cfaa4e1e697ef1">&#9670;&#160;</a></span>handle_latest_tag_confirmed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_latest_tag_confirmed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfederate__info__t.html">federate_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>fed</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>Handle a latest tag confirmed (LTC) message. </p>
<p>This function assumes the caller does not hold the mutex.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Federated.html#gada47c9f6736992a3df380526d87089f9" title="Byte identifying a latest tag confirmed (LTC) message sent by a federate to the RTI.">MSG_TYPE_LATEST_TAG_CONFIRMED</a> in <a class="el" href="net__common_8h.html">net_common.h</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fed</td><td>The federate that has completed a logical tag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad68a1cbfc6299b091b8f7b0e97f8bb5b" name="gad68a1cbfc6299b091b8f7b0e97f8bb5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad68a1cbfc6299b091b8f7b0e97f8bb5b">&#9670;&#160;</a></span>handle_next_event_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_next_event_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfederate__info__t.html">federate_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>fed</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>Handle a next event tag (NET) message. </p>
<p>This function assumes the caller does not hold the mutex.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__Federated.html#gaf662a6a84cd64cddad92e20e26af877e" title="Byte identifying a next event tag (NET) message sent from a federate in centralized coordination.">MSG_TYPE_NEXT_EVENT_TAG</a> in <a class="el" href="net__common_8h.html">net_common.h</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fed</td><td>The federate sending a NET message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad69c4cb2041a1a262bce829c49ae9246" name="gad69c4cb2041a1a262bce829c49ae9246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad69c4cb2041a1a262bce829c49ae9246">&#9670;&#160;</a></span>handle_physical_clock_sync_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_physical_clock_sync_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfederate__info__t.html">federate_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>my_fed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Federated.html#ga54c375e3893ff5969d20df65b90c8335">socket_type_t</a></td>          <td class="paramname"><span class="paramname"><em>socket_type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>Handle clock synchronization T3 messages from federates. </p>
<p>These will come in on the TCP channel during initialization and on the UDP channel subsequently. In both cases, this function will reply with a T4 message. If the channel is the UDP channel, then it will follow the T4 message immediately with a "coded probe" message, which will be used by the federate to decide whether to discard this clock synchronization round.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">my_fed</td><td>The sending federate. </td></tr>
    <tr><td class="paramname">socket_type</td><td>The RTI's socket type used for the communication (TCP or UDP) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga307edbac9eb75981db9dc7c0fcfc73e6" name="ga307edbac9eb75981db9dc7c0fcfc73e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga307edbac9eb75981db9dc7c0fcfc73e6">&#9670;&#160;</a></span>handle_port_absent_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_port_absent_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfederate__info__t.html">federate_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sending_federate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>Handle a port absent message being received rom a federate via the RIT. </p>
<p>This function assumes the caller does not hold the mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sending_federate</td><td>The sending federate. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer to read into (the first byte is already there). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga41ca594227fe9bb62f67b21cc2e7b6d6" name="ga41ca594227fe9bb62f67b21cc2e7b6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41ca594227fe9bb62f67b21cc2e7b6d6">&#9670;&#160;</a></span>handle_stop_request_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_stop_request_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfederate__info__t.html">federate_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>fed</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>Handle a MSG_TYPE_STOP_REQUEST message. </p>
<p>This function assumes the caller does not hold the mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fed</td><td>The federate sending a MSG_TYPE_STOP_REQUEST message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac4d4e5a1df9c31133d942a6e50e4c163" name="gac4d4e5a1df9c31133d942a6e50e4c163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4d4e5a1df9c31133d942a6e50e4c163">&#9670;&#160;</a></span>handle_stop_request_reply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_stop_request_reply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfederate__info__t.html">federate_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>fed</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>Handle a MSG_TYPE_STOP_REQUEST_REPLY message. </p>
<p>This function assumes the caller does not hold the mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fed</td><td>The federate replying the MSG_TYPE_STOP_REQUEST </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9fca6a5c7e73b40db2f6ef6f50c7a112" name="ga9fca6a5c7e73b40db2f6ef6f50c7a112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fca6a5c7e73b40db2f6ef6f50c7a112">&#9670;&#160;</a></span>handle_timed_message()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_timed_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfederate__info__t.html">federate_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>sending_federate</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>Handle a timed message being received from a federate by the RTI to relay to another federate. </p>
<p>This function assumes the caller does not hold the mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sending_federate</td><td>The sending federate. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer to read into (the first byte is already there). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0a2eadb2f35483bc7ce62a5845110330" name="ga0a2eadb2f35483bc7ce62a5845110330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a2eadb2f35483bc7ce62a5845110330">&#9670;&#160;</a></span>handle_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void handle_timestamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfederate__info__t.html">federate_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>my_fed</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>A function to handle timestamp messages. </p>
<p>This function assumes the caller does not hold the mutex. </p>

</div>
</div>
<a id="gaf934cc54979bcf640a7868377daab5e2" name="gaf934cc54979bcf640a7868377daab5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf934cc54979bcf640a7868377daab5e2">&#9670;&#160;</a></span>initialize_enclave_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_enclave_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenclave__info__t.html">enclave_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>enclave</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>idx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>env</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__local_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_local.h</a>&gt;</code></p>

<p>Initialize the enclave object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enclave</td><td>The enclave object to initialize. </td></tr>
    <tr><td class="paramname">idx</td><td>The index of the enclave. </td></tr>
    <tr><td class="paramname">env</td><td>The environment of the enclave. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab32a595d53f125832570251023d10c46" name="gab32a595d53f125832570251023d10c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab32a595d53f125832570251023d10c46">&#9670;&#160;</a></span>initialize_federate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_federate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfederate__info__t.html">federate_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>fed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>Initialize the federate with the specified ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fed</td><td>The federate to initialize. </td></tr>
    <tr><td class="paramname">id</td><td>The federate ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga167855af2f7fb010609dceda0a59b43d" name="ga167855af2f7fb010609dceda0a59b43d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga167855af2f7fb010609dceda0a59b43d">&#9670;&#160;</a></span>initialize_local_rti()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_local_rti </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenvironment__t.html">environment_t</a> *</td>          <td class="paramname"><span class="paramname"><em>envs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num_envs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__local_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_local.h</a>&gt;</code></p>

<p>Dynamically create and initialize the local RTI. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">envs</td><td>Array of environments. </td></tr>
    <tr><td class="paramname">num_envs</td><td>Number of environments. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0aefafd71cb0b057a604a04f1af61174" name="ga0aefafd71cb0b057a604a04f1af61174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aefafd71cb0b057a604a04f1af61174">&#9670;&#160;</a></span>initialize_RTI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_RTI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrti__remote__t.html">rti_remote_t</a> *</td>          <td class="paramname"><span class="paramname"><em>rti</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>Initialize the _RTI instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rti</td><td>The RTI instance to initialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadd2a2ad3c8a9f8e6cde5ecbcb83d7e8d" name="gadd2a2ad3c8a9f8e6cde5ecbcb83d7e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd2a2ad3c8a9f8e6cde5ecbcb83d7e8d">&#9670;&#160;</a></span>initialize_rti_common()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_rti_common </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrti__common__t.html">rti_common_t</a> *</td>          <td class="paramname"><span class="paramname"><em>rti_common</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__common_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_common.h</a>&gt;</code></p>

<p>Initialize the fields of the rti_common struct. </p>
<p>It also stores the pointer to the struct and uses it internally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rti_common</td><td>The <a class="el" href="structrti__common__t.html" title="Common RTI data structure for both remote standalone RTI and local RTI used in enclaved execution.">rti_common_t</a> struct to initialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9a27b6186b947cfacb408dc3a0829f6e" name="ga9a27b6186b947cfacb408dc3a0829f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a27b6186b947cfacb408dc3a0829f6e">&#9670;&#160;</a></span>initialize_scheduling_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void initialize_scheduling_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__common_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_common.h</a>&gt;</code></p>

<p>Initialize the scheduling node with the specified ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The scheduling node. </td></tr>
    <tr><td class="paramname">id</td><td>The scheduling node ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5f7d50fc74bdc38f889c38109c406468" name="ga5f7d50fc74bdc38f889c38109c406468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f7d50fc74bdc38f889c38109c406468">&#9670;&#160;</a></span>invalidate_min_delays()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void invalidate_min_delays </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__common_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_common.h</a>&gt;</code></p>

<p>Invalidate the <span class="tt">min_delays</span>, <span class="tt">num_min_delays</span>, and the fields that indicate cycles of all nodes. </p>
<p>This should be called whenever the structure of the connections have changed. </p>

</div>
</div>
<a id="gab38455d4faf77b4d86dcd77976afe1f1" name="gab38455d4faf77b4d86dcd77976afe1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab38455d4faf77b4d86dcd77976afe1f1">&#9670;&#160;</a></span>is_in_cycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_in_cycle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__common_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_common.h</a>&gt;</code></p>

<p>Return true if the node is in a cycle (possibly a zero-delay cycle). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga94101c5bfb54d670a8f47f448e351a34" name="ga94101c5bfb54d670a8f47f448e351a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94101c5bfb54d670a8f47f448e351a34">&#9670;&#160;</a></span>is_in_zero_delay_cycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_in_zero_delay_cycle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__common_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_common.h</a>&gt;</code></p>

<p>Return true if the node is in a zero-delay cycle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga52a9225745a4b229aee86fcc4617b904" name="ga52a9225745a4b229aee86fcc4617b904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52a9225745a4b229aee86fcc4617b904">&#9670;&#160;</a></span>lf_connect_to_federates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lf_connect_to_federates </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>socket_descriptor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>Wait for one incoming connection request from each federate, and, upon receiving it, create a thread to communicate with that federate. </p>
<p>Return when all federates have connected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_descriptor</td><td>The socket on which to accept connections. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga06003604b6defab443bdfe34f3ab17ee" name="ga06003604b6defab443bdfe34f3ab17ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06003604b6defab443bdfe34f3ab17ee">&#9670;&#160;</a></span>lf_get_downstream_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lf_get_downstream_of </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>enclave_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t **</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__local_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_local.h</a>&gt;</code></p>

<p>Get the array of ids of enclaves directly downstream of the specified enclave. </p>
<p>This updates the specified result pointer to point to a statically allocated array of IDs and returns the length of the array. The implementation is code-generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enclave_id</td><td>The enclave for which to report downstream IDs. </td></tr>
    <tr><td class="paramname">result</td><td>The pointer to dereference and update to point to the resulting array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of direct downstream enclaves. </dd></dl>

</div>
</div>
<a id="gaaba4ae9dd32581f9f34a7a81d9c7791c" name="gaaba4ae9dd32581f9f34a7a81d9c7791c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaba4ae9dd32581f9f34a7a81d9c7791c">&#9670;&#160;</a></span>lf_get_upstream_delay_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lf_get_upstream_delay_of </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>enclave_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__API.html#gaf5b4e62d03782997d813be6145316f4b">interval_t</a> **</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__local_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_local.h</a>&gt;</code></p>

<p>Retrieve the delays on the connections to direct upstream enclaves. </p>
<p>This updates the result pointer to point to a statically allocated array of delays. The implementation is code-generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enclave_id</td><td>The enclave for which to search for upstream delays. </td></tr>
    <tr><td class="paramname">result</td><td>The pointer to dereference and update to point to the resulting array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int The number of direct upstream enclaves. </dd></dl>

</div>
</div>
<a id="ga8f432bb04e691f66f4f81cbbecb741ed" name="ga8f432bb04e691f66f4f81cbbecb741ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f432bb04e691f66f4f81cbbecb741ed">&#9670;&#160;</a></span>lf_get_upstream_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lf_get_upstream_of </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>enclave_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t **</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__local_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_local.h</a>&gt;</code></p>

<p>Get the array of ids of enclaves directly upstream of the specified enclave. </p>
<p>This updates the specified result pointer to point to a statically allocated array of IDs and returns the length of the array. The implementation is code-generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enclave_id</td><td>The enclave for which to report upstream IDs. </td></tr>
    <tr><td class="paramname">result</td><td>The pointer to dereference and update to point to the resulting array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of direct upstream enclaves. </dd></dl>

</div>
</div>
<a id="gaa057279652cc77f238cc73d0fc0e705e" name="gaa057279652cc77f238cc73d0fc0e705e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa057279652cc77f238cc73d0fc0e705e">&#9670;&#160;</a></span>notify_advance_grant_if_safe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void notify_advance_grant_if_safe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__common_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_common.h</a>&gt;</code></p>

<p>Either send to a federate or unblock an enclave to give it a tag. </p>
<p>This function requires two different implementations, one for enclaves and one for federates.</p>
<p>This assumes the caller holds the RTI mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The scheduling node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0903cfa1c0fa064824b445c099cd2aa6" name="ga0903cfa1c0fa064824b445c099cd2aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0903cfa1c0fa064824b445c099cd2aa6">&#9670;&#160;</a></span>notify_downstream_advance_grant_if_safe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void notify_downstream_advance_grant_if_safe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>visited</em></span>[]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__common_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_common.h</a>&gt;</code></p>

<p>For all scheduling nodes downstream of the specified node, determine whether they should be notified of a TAG or PTAG and notify them if so. </p>
<p>This assumes the caller holds the RTI mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The upstream node. </td></tr>
    <tr><td class="paramname">visited</td><td>An array of booleans used to determine whether a node has been visited (initially all false). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae38c64692f527911c9cc748c03d2246d" name="gae38c64692f527911c9cc748c03d2246d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae38c64692f527911c9cc748c03d2246d">&#9670;&#160;</a></span>notify_downstream_next_event_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void notify_downstream_next_event_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__common_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_common.h</a>&gt;</code></p>

<p>Notify a downstream next event tag (DNET) signal to the specified scheduling node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The target node. </td></tr>
    <tr><td class="paramname">tag</td><td>The downstream next event tag for e. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab226921e491807e98a406487cfdf6335" name="gab226921e491807e98a406487cfdf6335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab226921e491807e98a406487cfdf6335">&#9670;&#160;</a></span>notify_provisional_tag_advance_grant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void notify_provisional_tag_advance_grant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__common_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_common.h</a>&gt;</code></p>

<p>Notify a provisional tag advance grant (PTAG) message to the specified scheduling node. </p>
<p>Do not notify it if a previously sent PTAG or TAG was greater or equal.</p>
<p>This function will keep a record of this PTAG in the node's last_provisionally_granted field.</p>
<p>This function assumes that the caller holds the RTI mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The scheduling node. </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to grant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga21a88113d348968980a137c9e4e4148e" name="ga21a88113d348968980a137c9e4e4148e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21a88113d348968980a137c9e4e4148e">&#9670;&#160;</a></span>notify_tag_advance_grant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void notify_tag_advance_grant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__common_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_common.h</a>&gt;</code></p>

<p>Notify a tag advance grant (TAG) message to the specified scheduling node. </p>
<p>Do not notify it if a previously sent PTAG was greater or if a previously sent TAG was greater or equal.</p>
<p>This function will keep a record of this TAG in the node's last_granted field.</p>
<p>This function assumes that the caller holds the RTI mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The scheduling node. </td></tr>
    <tr><td class="paramname">tag</td><td>The tag to grant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga80aaf4eeed3e2902f8fe9de80b45777d" name="ga80aaf4eeed3e2902f8fe9de80b45777d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80aaf4eeed3e2902f8fe9de80b45777d">&#9670;&#160;</a></span>process_args()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int process_args </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>[]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>Process the command-line arguments. </p>
<p>If the command line arguments are not understood, then print a usage message and return 0. Otherwise, return 1.</p>
<dl class="section return"><dt>Returns</dt><dd>1 if the arguments processed successfully, 0 otherwise. </dd></dl>

</div>
</div>
<a id="gad7d4392b21b300612a5239fbb1ffa274" name="gad7d4392b21b300612a5239fbb1ffa274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7d4392b21b300612a5239fbb1ffa274">&#9670;&#160;</a></span>process_clock_sync_args()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int process_clock_sync_args </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>[]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>Process command-line arguments related to clock synchronization. </p>
<p>This will return the last read position of argv if all related arguments are parsed or an invalid argument is read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>The number of arguments in the list. </td></tr>
    <tr><td class="paramname">argv</td><td>The list of arguments as a string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current position (head) of argv. </dd></dl>

</div>
</div>
<a id="gac6af5f2343ecf9ed87cdbebd98b94271" name="gac6af5f2343ecf9ed87cdbebd98b94271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6af5f2343ecf9ed87cdbebd98b94271">&#9670;&#160;</a></span>respond_to_erroneous_connections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * respond_to_erroneous_connections </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>nothing</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>Thread to respond to new connections, which could be federates of other federations who are attempting to join the wrong federation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nothing</td><td>Nothing needed here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL. </dd></dl>

</div>
</div>
<a id="gafa27405a96dae1488b670aa25fc8ad1b" name="gafa27405a96dae1488b670aa25fc8ad1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa27405a96dae1488b670aa25fc8ad1b">&#9670;&#160;</a></span>rti_logical_tag_complete_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rti_logical_tag_complete_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenclave__info__t.html">enclave_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>enclave</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>completed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__local_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_local.h</a>&gt;</code></p>

<p>Inform the local RTI that <span class="tt">enclave</span> has completed tag <span class="tt">completed</span>. </p>
<p>This will update the data structures and can release other enclaves waiting on a TAG.</p>
<p>This assumes the caller is holding the environment mutex of the source enclave.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enclave</td><td>The enclave </td></tr>
    <tr><td class="paramname">completed</td><td>The tag just completed by the enclave. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga48640596070ecfb23f94532363b5cd6a" name="ga48640596070ecfb23f94532363b5cd6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48640596070ecfb23f94532363b5cd6a">&#9670;&#160;</a></span>rti_next_event_tag_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtag__t.html">tag_t</a> rti_next_event_tag_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenclave__info__t.html">enclave_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>enclave</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>next_event_tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__local_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_local.h</a>&gt;</code></p>

<p>Notify the local RTI of a next event tag (NET). </p>
<p>This function call may block. A call to this function serves two purposes. 1) It is a promise that, unless receiving events from other enclaves, this enclave will not produce any event until the next_event_tag (NET) argument. 2) It is a request for permission to advance the logical tag of the enclave until the NET.</p>
<p>This function call will block until the enclave has been granted a TAG, which might not be the tag requested.</p>
<p>This assumes the caller is holding the environment mutex of the source enclave.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enclave</td><td>The enclave requesting to advance to the NET. </td></tr>
    <tr><td class="paramname">next_event_tag</td><td>The tag of the next event in the enclave </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structtag__t.html" title="A tag is a time, microstep pair.">tag_t</a> A tag which the enclave can safely advance its time to. It might be smaller or larger than the requested tag. </dd></dl>

</div>
</div>
<a id="gaf921c9092b09500768f94e41b3a7c8f4" name="gaf921c9092b09500768f94e41b3a7c8f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf921c9092b09500768f94e41b3a7c8f4">&#9670;&#160;</a></span>rti_update_other_net_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rti_update_other_net_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structenclave__info__t.html">enclave_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structenclave__info__t.html">enclave_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>target</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>net</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__local_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_local.h</a>&gt;</code></p>

<p>Notify the local RTI to update the next event tag (NET) of a target enclave. </p>
<p>This function is called after scheduling an event onto the event queue of another enclave. The source enclave must call this function to potentially update the NET of the target enclave.</p>
<p>This assumes the caller is holding the environment mutex of the target enclave.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The enclave that has scheduled an event. </td></tr>
    <tr><td class="paramname">target</td><td>The enclave of which we want to update the NET of. </td></tr>
    <tr><td class="paramname">net</td><td>The proposed next event tag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5b16bd2ead60426e3ace71eca1cfede5" name="ga5b16bd2ead60426e3ace71eca1cfede5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b16bd2ead60426e3ace71eca1cfede5">&#9670;&#160;</a></span>send_physical_clock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void send_physical_clock </td>
          <td>(</td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>message_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfederate__info__t.html">federate_info_t</a> *</td>          <td class="paramname"><span class="paramname"><em>fed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Federated.html#ga54c375e3893ff5969d20df65b90c8335">socket_type_t</a></td>          <td class="paramname"><span class="paramname"><em>socket_type</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>Take a snapshot of the physical clock time and send it to federate fed_id. </p>
<p>This version assumes the caller holds the mutex lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message_type</td><td>The type of the clock sync message (see <a class="el" href="net__common_8h.html">net_common.h</a>). </td></tr>
    <tr><td class="paramname">fed</td><td>The federate to send the physical time to. </td></tr>
    <tr><td class="paramname">socket_type</td><td>The socket type (TCP or UDP). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac1d01420f22f3dc5dbdef49ffebdb443" name="gac1d01420f22f3dc5dbdef49ffebdb443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1d01420f22f3dc5dbdef49ffebdb443">&#9670;&#160;</a></span>send_reject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void send_reject </td>
          <td>(</td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>socket_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>error_code</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>Send a MSG_TYPE_REJECT message to the specified socket and close the socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_id</td><td>Pointer to the socket ID. </td></tr>
    <tr><td class="paramname">error_code</td><td>An error code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6cc1fe69c154d09d88de1f1c06eb4b0d" name="ga6cc1fe69c154d09d88de1f1c06eb4b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cc1fe69c154d09d88de1f1c06eb4b0d">&#9670;&#160;</a></span>start_rti_server()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t start_rti_server </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>port</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>Start the socket server for the runtime infrastructure (RTI) and return the socket descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port on which to listen for socket connections, or 0 to use the default port range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf849510938f837c74cfe8f843cb7dcb2" name="gaf849510938f837c74cfe8f843cb7dcb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf849510938f837c74cfe8f843cb7dcb2">&#9670;&#160;</a></span>tag_advance_grant_if_safe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtag__advance__grant__t.html">tag_advance_grant_t</a> tag_advance_grant_if_safe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>e</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__common_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_common.h</a>&gt;</code></p>

<p>Determine whether the specified scheduling node is eligible for a tag advance grant, (TAG) and, if so, return the details. </p>
<p>This is called upon receiving a LTC, NET or resign from an upstream node.</p>
<p>This function calculates the minimum M over all upstream scheduling nodes of the "after" delay plus the most recently received LTC from that node. If M is greater than the most recent TAG to e or greater than or equal to the most recent PTAG, then return TAG(M).</p>
<p>If the above conditions do not result in returning a TAG, then find the minimum M of the earliest possible future message from upstream federates. This is calculated by transitively looking at the most recently received NET calls from upstream scheduling nodes. If M is greater than the NET of e or the most recent PTAG to e, then return a TAG with tag equal to the NET of e or the PTAG. If M is equal to the NET of the federate, then return PTAG(M).</p>
<p>This should be called whenever an immediately upstream federate sends to the RTI an LTC (latest tag confirmed), or when a transitive upstream federate sends a NET (Next Event Tag) message. It is also called when an upstream federate resigns from the federation.</p>
<p>This function assumes that the caller holds the RTI mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The scheduling node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If granted, return the tag value and whether it is provisional. Otherwise, return the NEVER_TAG. </dd></dl>

</div>
</div>
<a id="ga13560f0cae54155219f4d8d9c487b0ef" name="ga13560f0cae54155219f4d8d9c487b0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13560f0cae54155219f4d8d9c487b0ef">&#9670;&#160;</a></span>tracepoint_rti_from_federate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tracepoint_rti_from_federate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Tracing.html#gab02e9e69539d60297cedb38c2193a453">trace_event_t</a></td>          <td class="paramname"><span class="paramname"><em>event_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fed_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tracepoint_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/tracepoint.h</a>&gt;</code></p>

<p>Trace RTI receiving a message from a federate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_type</td><td>The type of event. Possible values are:</td></tr>
    <tr><td class="paramname">fed_id</td><td>The fedaerate ID. </td></tr>
    <tr><td class="paramname">tag</td><td>Pointer to the tag that has been sent, or NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0da8aecc05366988f8d929118be90bbe" name="ga0da8aecc05366988f8d929118be90bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0da8aecc05366988f8d929118be90bbe">&#9670;&#160;</a></span>tracepoint_rti_to_federate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tracepoint_rti_to_federate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Tracing.html#gab02e9e69539d60297cedb38c2193a453">trace_event_t</a></td>          <td class="paramname"><span class="paramname"><em>event_type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fed_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a> *</td>          <td class="paramname"><span class="paramname"><em>tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="tracepoint_8h.html">/Users/runner/work/reactor-c/reactor-c/include/core/tracepoint.h</a>&gt;</code></p>

<p>Trace RTI sending a message to a federate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_type</td><td>The type of event. Possible values are:</td></tr>
    <tr><td class="paramname">fed_id</td><td>The fedaerate ID. </td></tr>
    <tr><td class="paramname">tag</td><td>Pointer to the tag that has been sent, or NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7190c8d1000afb0a5e8898011d041917" name="ga7190c8d1000afb0a5e8898011d041917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7190c8d1000afb0a5e8898011d041917">&#9670;&#160;</a></span>update_federate_next_event_tag_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void update_federate_next_event_tag_locked </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>federate_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>next_event_tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>Update the next event tag of federate <span class="tt">federate_id</span>. </p>
<p>It will update the recorded next event tag of federate <span class="tt">federate_id</span> to the minimum of <span class="tt">next_event_tag</span> and the minimum tag of in-transit messages (if any) to the federate.</p>
<p>Will try to see if the RTI can grant new TAG or PTAG messages to any downstream federates based on this new next event tag.</p>
<p>This function assumes that the caller is holding the _RTI.mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">federate_id</td><td>The id of the federate that needs to be updated. </td></tr>
    <tr><td class="paramname">next_event_tag</td><td>The next event tag for <span class="tt">federate_id</span>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga93ef5ce52bd47e14977ea3571c1b152b" name="ga93ef5ce52bd47e14977ea3571c1b152b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93ef5ce52bd47e14977ea3571c1b152b">&#9670;&#160;</a></span>update_min_delays()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void update_min_delays </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__common_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_common.h</a>&gt;</code></p>

<p>If necessary, update the <span class="tt">min_delays</span> and the fields that indicate cycles. </p>
<p>These fields will be updated only if they have not been previously updated or if invalidate_min_delays has been called since they were last updated. </p>

</div>
</div>
<a id="ga21533a3d64de78b3766016c2166460c9" name="ga21533a3d64de78b3766016c2166460c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21533a3d64de78b3766016c2166460c9">&#9670;&#160;</a></span>update_scheduling_node_next_event_tag_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void update_scheduling_node_next_event_tag_locked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscheduling__node__t.html">scheduling_node_t</a> *</td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtag__t.html">tag_t</a></td>          <td class="paramname"><span class="paramname"><em>next_event_tag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__common_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_common.h</a>&gt;</code></p>

<p>Update the next event tag of an scheduling node. </p>
<p>This will notify downstream scheduling nodes with a TAG or PTAG if appropriate.</p>
<p>This function assumes that the caller is holding the RTI mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The scheduling node. </td></tr>
    <tr><td class="paramname">next_event_tag</td><td>The next event tag for e. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7f44f474f50286c4ba8c0ebac254bb28" name="ga7f44f474f50286c4ba8c0ebac254bb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f44f474f50286c4ba8c0ebac254bb28">&#9670;&#160;</a></span>usage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usage </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>argc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>argv</em></span>[]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>Print a usage message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>The number of arguments in the list. </td></tr>
    <tr><td class="paramname">argv</td><td>The list of arguments as a string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga005cb43e8e6c7795c8f0db27e2424475" name="ga005cb43e8e6c7795c8f0db27e2424475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga005cb43e8e6c7795c8f0db27e2424475">&#9670;&#160;</a></span>wait_for_federates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wait_for_federates </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>socket_descriptor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="rti__remote_8h.html">/Users/runner/work/reactor-c/reactor-c/core/federated/RTI/rti_remote.h</a>&gt;</code></p>

<p>Start the runtime infrastructure (RTI) interaction with the federates and wait for the federates to exit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">socket_descriptor</td><td>The socket descriptor returned by <a class="el" href="#ga6cc1fe69c154d09d88de1f1c06eb4b0d" title="Start the socket server for the runtime infrastructure (RTI) and return the socket descriptor.">start_rti_server()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on <span class="timestamp"></span> for reactor-c by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
